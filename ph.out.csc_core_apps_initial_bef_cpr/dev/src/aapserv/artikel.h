#ifndef __PP_ARTIKEL_H_
#define __PP_ARTIKEL_H_

/******************************************************************************/
/* c:\git\pharmos.outbound.csc_core_applications\dev\src\aapserv\Artikel ******/
/* produced by DADE 6.22.2 ****************************************************/
/******************************************************************************/

/* ppunixc */
#include <bufkon.h>

/* Length-Define of ARTBUYINGOPTIONS ******************************************/

#define L_ARTBUYINGOPTIONS_ARTIKEL_NR 11
#define L_ARTBUYINGOPTIONS_ETARTKLASSE1 5
#define L_ARTBUYINGOPTIONS_KZPSYCHOSTOFFE 1

/* Length-Define of ARTCHARGE *************************************************/

#define L_ARTCHARGE_BRANCHNO 6
#define L_ARTCHARGE_ARTICLENO 11
#define L_ARTCHARGE_EXPIRYDATE 11
#define L_ARTCHARGE_CHARGENNR 25
#define L_ARTCHARGE_STOCK 11
#define L_ARTCHARGE_STATECHARGE 1

/* Length-Define of ARTINFBG **************************************************/

#define L_ARTINFBG_ARTIKEL_NR 11
#define L_ARTINFBG_HEALTHFUNDCODE 5
#define L_ARTINFBG_ARTIKEL_LANGNAME 50

/* Length-Define of ARTINSERT *************************************************/

#define L_ARTINSERT_ARTICLENO 11
#define L_ARTINSERT_ARTINFOTYPE 6
#define L_ARTINSERT_SEQUENCENO 6
#define L_ARTINSERT_INFOTEXT 256

/* Length-Define of ARTLANGNAME ***********************************************/

#define L_ARTLANGNAME_ARTIKEL_NR 11
#define L_ARTLANGNAME_ARTIKEL_LANGNAME 50

/* Length-Define of ARTPRICE **************************************************/

#define L_ARTPRICE_ARTIKEL_NR 11
#define L_ARTPRICE_PREISEKAPO 9
#define N_ARTPRICE_PREISEKAPO 2
#define L_ARTPRICE_PREISEKGROSSO 9
#define N_ARTPRICE_PREISEKGROSSO 2
#define L_ARTPRICE_PREIS_TYP 6

/* Length-Define of ARTPSYCHO *************************************************/

#define L_ARTPSYCHO_ARTIKEL_NR 11
#define L_ARTPSYCHO_ETARTKLASSE1 5
#define L_ARTPSYCHO_KZPSYCHOSTOFFE 1

/* Length-Define of ARTICLEAGENTGROUP *****************************************/

#define L_ARTICLEAGENTGROUP_PREISEKAPO 9
#define N_ARTICLEAGENTGROUP_PREISEKAPO 2
#define L_ARTICLEAGENTGROUP_FILIALNR 6
#define L_ARTICLEAGENTGROUP_ARTIKEL_NR 11
#define L_ARTICLEAGENTGROUP_BESTAND 11
#define L_ARTICLEAGENTGROUP_DARREICHFORM 3
#define L_ARTICLEAGENTGROUP_EINHEIT 9
#define L_ARTICLEAGENTGROUP_ARTIKEL_NAME 30
#define L_ARTICLEAGENTGROUP_WIRKSTOFF_NR 3
#define L_ARTICLEAGENTGROUP_ARTIKEL_LANGNAME 50

/* Length-Define of ARTICLELPPRREIMB ******************************************/

#define L_ARTICLELPPRREIMB_ARTICLENO 11
#define L_ARTICLELPPRREIMB_CODE_LPPR 15
#define L_ARTICLELPPRREIMB_DATEFROM 11
#define L_ARTICLELPPRREIMB_REIMBURSEMENT_VAL 9
#define N_ARTICLELPPRREIMB_REIMBURSEMENT_VAL 2
#define L_ARTICLELPPRREIMB_LPPR_DESC 400
#define L_ARTICLELPPRREIMB_REIMBCALCFLAG 6

/* Length-Define of ARTICLEQUOTADETAIL ****************************************/

#define L_ARTICLEQUOTADETAIL_BRANCHNO 6
#define L_ARTICLEQUOTADETAIL_CUSTOMERNO 11
#define L_ARTICLEQUOTADETAIL_ARTICLENO 11
#define L_ARTICLEQUOTADETAIL_QUOTA 11
#define L_ARTICLEQUOTADETAIL_VALIDITY 1
#define L_ARTICLEQUOTADETAIL_KZKDKLASSE 3
#define L_ARTICLEQUOTADETAIL_EINHEIT 9
#define L_ARTICLEQUOTADETAIL_ARTIKEL_NAME 30

/* Length-Define of ARTICLEQUOTAEKG *******************************************/

#define L_ARTICLEQUOTAEKG_BRANCHNO 6
#define L_ARTICLEQUOTAEKG_GROUP_NAME 30
#define L_ARTICLEQUOTAEKG_ARTICLENO 11
#define L_ARTICLEQUOTAEKG_QUOTA 11
#define L_ARTICLEQUOTAEKG_KUMQTY 11
#define L_ARTICLEQUOTAEKG_VALIDITY 1
#define L_ARTICLEQUOTAEKG_DATEUPDATE 11
#define L_ARTICLEQUOTAEKG_UID_ANLAGE 11
#define L_ARTICLEQUOTAEKG_DATEFROM 11
#define L_ARTICLEQUOTAEKG_DATETO 11
#define L_ARTICLEQUOTAEKG_PHARMACYGROUPID 3
#define L_ARTICLEQUOTAEKG_SNOBATCHCHANGE 1
#define L_ARTICLEQUOTAEKG_EINHEIT 9
#define L_ARTICLEQUOTAEKG_ARTIKEL_NAME 30

/* Length-Define of ARTICLETAX ************************************************/

#define L_ARTICLETAX_SALESTAXRATE 5
#define N_ARTICLETAX_SALESTAXRATE 2
#define L_ARTICLETAX_ARTIKEL_NR 11

/* Length-Define of ARTIKELLPPR ***********************************************/

#define L_ARTIKELLPPR_ARTICLENO 11
#define L_ARTIKELLPPR_REIMBURSEMENT_TYPE 1
#define L_ARTIKELLPPR_REIMBURSEMENTPRICE 9
#define N_ARTIKELLPPR_REIMBURSEMENTPRICE 3
#define L_ARTIKELLPPR_CODE_LPPR 15
#define L_ARTIKELLPPR_REIMBURSEMENT_PERC 5
#define N_ARTIKELLPPR_REIMBURSEMENT_PERC 2

/* Length-Define of ARTIKELQUOTA **********************************************/

#define L_ARTIKELQUOTA_BRANCHNO 6
#define L_ARTIKELQUOTA_CUSTOMERNO 11
#define L_ARTIKELQUOTA_MATCHCODE 12
#define L_ARTIKELQUOTA_ARTICLENO 11
#define L_ARTIKELQUOTA_QUOTA 11
#define L_ARTIKELQUOTA_KUMQTY 11
#define L_ARTIKELQUOTA_VALIDITY 1
#define L_ARTIKELQUOTA_DATEUPDATE 11
#define L_ARTIKELQUOTA_UID_ANLAGE 11
#define L_ARTIKELQUOTA_SDAFUEQUOTA 1
#define L_ARTIKELQUOTA_DATEFROM 11
#define L_ARTIKELQUOTA_DATETO 11
#define L_ARTIKELQUOTA_PHARMACYGROUPID 3
#define L_ARTIKELQUOTA_SNOBATCHCHANGE 1
#define L_ARTIKELQUOTA_QUOTAINHERITANCE 6
#define L_ARTIKELQUOTA_EINHEIT 9
#define L_ARTIKELQUOTA_ARTIKEL_NAME 30

/* Length-Define of ARTIKELQUOTAPF ********************************************/

#define L_ARTIKELQUOTAPF_BRANCHNO 6
#define L_ARTIKELQUOTAPF_CUSTOMERNO 11
#define L_ARTIKELQUOTAPF_ARTICLENO 11
#define L_ARTIKELQUOTAPF_QUOTA 11
#define L_ARTIKELQUOTAPF_KUMQTY 11
#define L_ARTIKELQUOTAPF_VALIDITY 1
#define L_ARTIKELQUOTAPF_DATEUPDATE 11
#define L_ARTIKELQUOTAPF_UID_ANLAGE 11
#define L_ARTIKELQUOTAPF_SDAFUEQUOTA 1
#define L_ARTIKELQUOTAPF_DATEFROM 11
#define L_ARTIKELQUOTAPF_DATETO 11
#define L_ARTIKELQUOTAPF_SNOBATCHCHANGE 1
#define L_ARTIKELQUOTAPF_KZKDKLASSE 3
#define L_ARTIKELQUOTAPF_WERT 11

/* Length-Define of ARTIKELRESERVE ********************************************/

#define L_ARTIKELRESERVE_BRANCHNO 6
#define L_ARTIKELRESERVE_CUSTOMERNO 11
#define L_ARTIKELRESERVE_PHARMACYGROUPID 3
#define L_ARTIKELRESERVE_ARTICLENO 11
#define L_ARTIKELRESERVE_RESERVTYPE 6
#define L_ARTIKELRESERVE_MAXQTY 11
#define L_ARTIKELRESERVE_RESERVEDQTY 11
#define L_ARTIKELRESERVE_RESERVEPCT 6

/* Length-Define of ARTIKELTEXT ***********************************************/

#define L_ARTIKELTEXT_BRANCHNO 6
#define L_ARTIKELTEXT_TEXTKEY 6
#define L_ARTIKELTEXT_TEXT 240
#define L_ARTIKELTEXT_DISPLAYONSCREEN 1
#define L_ARTIKELTEXT_TEXTHOSPITAL 480

/* Length-Define of ARTIKELVERFALL ********************************************/

#define L_ARTIKELVERFALL_FILIALNR 6
#define L_ARTIKELVERFALL_ARTIKEL_NR 11
#define L_ARTIKELVERFALL_DATUMVERFALL 11

/* Length-Define of ATICLEAUX *************************************************/

#define L_ATICLEAUX_BRANCHNO 6
#define L_ATICLEAUX_ARTICLENO 11
#define L_ATICLEAUX_RANKING 6
#define L_ATICLEAUX_AUXBRANCHNO 6

/* Length-Define of CCODE *****************************************************/

#define L_CCODE_BRANCHNO 6
#define L_CCODE_INFOCODE 2
#define L_CCODE_ARTICLEACTIV 1
#define L_CCODE_AUXDELIVERY 1
#define L_CCODE_SERACODE 20
#define L_CCODE_PRINTCODE 30
#define L_CCODE_XMLCODE 5
#define L_CCODE_XMLTEXT 100

/* Length-Define of CHECKIMEXBLOCKEXIST ***************************************/

#define L_CHECKIMEXBLOCKEXIST_ARTICLENO 11

/* Length-Define of CHECKIMPORTARTICLE ****************************************/

#define L_CHECKIMPORTARTICLE_ARTIKEL_NR 11
#define L_CHECKIMPORTARTICLE_IMPORTARTICLE 6

/* Length-Define of CHECKLISTE5ZENTRAL ****************************************/

#define L_CHECKLISTE5ZENTRAL_ARTIKEL_NR 11

/* Length-Define of CODEBLOCAGEINFO *******************************************/

#define L_CODEBLOCAGEINFO_PRINTCODE 30
#define L_CODEBLOCAGEINFO_FILIALNR 6
#define L_CODEBLOCAGEINFO_ARTIKEL_NR 11

/* Length-Define of DISPOINFO *************************************************/

#define L_DISPOINFO_BEZEICHNUNG 30
#define L_DISPOINFO_DISPO_HINWEIS 240
#define L_DISPOINFO_BEMERKUNG 240
#define L_DISPOINFO_PZN 11
#define L_DISPOINFO_ARTIKEL_NR 11
#define L_DISPOINFO_HERSTELLER_NR 11

/* Length-Define of HERSTELLER ************************************************/

#define L_HERSTELLER_NAME 30
#define L_HERSTELLER_ARTIKEL_NR 11

/* Length-Define of LPPRCODE **************************************************/

#define L_LPPRCODE_CODE_LPPR 15
#define L_LPPRCODE_REIMBURSEMENT_VAL 9
#define N_LPPRCODE_REIMBURSEMENT_VAL 2

/* Length-Define of MAXARTICLEQUOTA *******************************************/

#define L_MAXARTICLEQUOTA_ARTICLENO 11
#define L_MAXARTICLEQUOTA_MAXQUOTA 11

/* Length-Define of OCCASION **************************************************/

#define L_OCCASION_CUSTOMERNO 11
#define L_OCCASION_ARTICLENO 11
#define L_OCCASION_BRANCHNO 6
#define L_OCCASION_DISCOUNTVALUEPCT 5
#define N_OCCASION_DISCOUNTVALUEPCT 2

/* Length-Define of PHARMGRP **************************************************/

#define L_PHARMGRP_PHARMACYGROUPID 3
#define L_PHARMGRP_GROUP_NAME 30
#define L_PHARMGRP_GROUP_TYPE 1
#define L_PHARMGRP_PERCENT 5
#define N_PHARMGRP_PERCENT 2
#define L_PHARMGRP_CONTRIBUTION 3
#define N_PHARMGRP_CONTRIBUTION 2
#define L_PHARMGRP_CUSTOMERNO 11
#define L_PHARMGRP_OMG_OWN_CONT 1
#define L_PHARMGRP_PRICE_BASIS_PURCH 1
#define L_PHARMGRP_RECLAIM_OMG_DISC 1
#define L_PHARMGRP_SPECIALGROUP 6
#define L_PHARMGRP_SPECIALGROUPREFNO 11
#define L_PHARMGRP_GROUPING_VIS 6
#define L_PHARMGRP_BRANCHNO 6

/* Length-Define of PREISANZTYP ***********************************************/

#define L_PREISANZTYP_ARTIKEL_NR 11
#define L_PREISANZTYP_PREISEKAPO 9
#define N_PREISANZTYP_PREISEKAPO 2
#define L_PREISANZTYP_PREISEKGROSSO 9
#define N_PREISANZTYP_PREISEKGROSSO 2
#define L_PREISANZTYP_PREISEKGROSSONA 9
#define N_PREISANZTYP_PREISEKGROSSONA 2
#define L_PREISANZTYP_PREIS_TYP 6

/* Length-Define of PRICEHIST *************************************************/

#define L_PRICEHIST_ARTIKEL_NR 11
#define L_PRICEHIST_DATUMGUELTIGAB 11
#define L_PRICEHIST_GROSSO 9
#define N_PRICEHIST_GROSSO 2
#define L_PRICEHIST_AEP 9
#define N_PRICEHIST_AEP 2
#define L_PRICEHIST_AVP 9
#define N_PRICEHIST_AVP 2

/* Length-Define of PROMOANZ **************************************************/

#define L_PROMOANZ_PROMOTION_NO 6
#define L_PROMOANZ_NAME 30
#define L_PROMOANZ_DESCRIPTION 40
#define L_PROMOANZ_PROMOTION_TYPE 6

/* Length-Define of REIMPORT **************************************************/

#define L_REIMPORT_DARREICHFORM 3
#define L_REIMPORT_PREISEKAPO 9
#define N_REIMPORT_PREISEKAPO 2
#define L_REIMPORT_EINHEIT 9
#define L_REIMPORT_ARTIKEL_NAME 30
#define L_REIMPORT_BESTAND 11
#define L_REIMPORT_PZN 11

/* Length-Define of STELLER ***************************************************/

#define L_STELLER_ARTICLE_NO_PACK 11
#define L_STELLER_ARTICLE_NO_ELEMENT 11
#define L_STELLER_QUANTITY 11
#define L_STELLER_FILIALNR 6
#define L_STELLER_BESTAND 11
#define L_STELLER_DARREICHFORM 3
#define L_STELLER_EINHEIT 9
#define L_STELLER_ARTIKEL_NAME 30
#define L_STELLER_ARTIKEL_LANGNAME 50

/* Length-Define of STELLERTYP ************************************************/

#define L_STELLERTYP_ARTICLE_NO_PACK 11
#define L_STELLERTYP_DATEFROM 11
#define L_STELLERTYP_DATETO 11
#define L_STELLERTYP_COMPACK_TYPE 6

/* Length-Define of STOCKRESERVATION ******************************************/

#define L_STOCKRESERVATION_BRANCHNO 6
#define L_STOCKRESERVATION_CUSTOMERNO 11
#define L_STOCKRESERVATION_ARTICLE_CODE 25
#define L_STOCKRESERVATION_ARTICLENO 11
#define L_STOCKRESERVATION_RESERVEDQTY 11
#define L_STOCKRESERVATION_DATEFROM 11
#define L_STOCKRESERVATION_TIMEFROM 11
#define L_STOCKRESERVATION_DATETO 11
#define L_STOCKRESERVATION_TIMETO 11
#define L_STOCKRESERVATION_KDAUFTRAGNR 11
#define L_STOCKRESERVATION_RESERVTYPE 6

/* Length-Define of STOCKRESERVATIONARTICLERESERV *****************************/

#define L_STOCKRESERVATIONARTICLERESERV_BRANCHNO 6
#define L_STOCKRESERVATIONARTICLERESERV_PHARMACYGROUPID 3
#define L_STOCKRESERVATIONARTICLERESERV_ARTICLENO 11
#define L_STOCKRESERVATIONARTICLERESERV_RESERVTYPE 6
#define L_STOCKRESERVATIONARTICLERESERV_MAXQTY 11
#define L_STOCKRESERVATIONARTICLERESERV_RESERVEDQTY 11

/* Length-Define of STOCKRESERVATIONARTIKELLOKAL ******************************/

#define L_STOCKRESERVATIONARTIKELLOKAL_FILIALNR 6
#define L_STOCKRESERVATIONARTIKELLOKAL_ARTIKEL_NR 11
#define L_STOCKRESERVATIONARTIKELLOKAL_BESTAND 11
#define L_STOCKRESERVATIONARTIKELLOKAL_LAGERBEREICHNR 6
#define L_STOCKRESERVATIONARTIKELLOKAL_STATIONNR 2
#define L_STOCKRESERVATIONARTIKELLOKAL_LAGERFACHNR 10

/* Length-Define of STOCKRESERVATIONIBTREQUEST ********************************/

#define L_STOCKRESERVATIONIBTREQUEST_IBTREQUESTID 11
#define L_STOCKRESERVATIONIBTREQUEST_BRANCHNO 6
#define L_STOCKRESERVATIONIBTREQUEST_CSCORDERNO 11
#define L_STOCKRESERVATIONIBTREQUEST_CSCORDERPOSNO 11
#define L_STOCKRESERVATIONIBTREQUEST_DATEFROM 11
#define L_STOCKRESERVATIONIBTREQUEST_IBTBRANCHNO 6
#define L_STOCKRESERVATIONIBTREQUEST_IBTCUSTOMERNO 11
#define L_STOCKRESERVATIONIBTREQUEST_TIMEFROM 11
#define L_STOCKRESERVATIONIBTREQUEST_PROCESSINGSTATE 6
#define L_STOCKRESERVATIONIBTREQUEST_CUSTOMERNO 11
#define L_STOCKRESERVATIONIBTREQUEST_ARTICLENO 11
#define L_STOCKRESERVATIONIBTREQUEST_QUANTITY 11

/* Length-Define of STOCKRESERVATIONNACHLIEFERPOS *****************************/

#define L_STOCKRESERVATIONNACHLIEFERPOS_KDAUFTRAGNR 11
#define L_STOCKRESERVATIONNACHLIEFERPOS_POSNR 11
#define L_STOCKRESERVATIONNACHLIEFERPOS_DATUM 11
#define L_STOCKRESERVATIONNACHLIEFERPOS_POSTYP 6
#define L_STOCKRESERVATIONNACHLIEFERPOS_IDFNR 11
#define L_STOCKRESERVATIONNACHLIEFERPOS_ARTIKEL_NR 11
#define L_STOCKRESERVATIONNACHLIEFERPOS_MENGE 11
#define L_STOCKRESERVATIONNACHLIEFERPOS_STATUS 11

/* Length-Define of STOCKRESERVATIONORDER *************************************/

#define L_STOCKRESERVATIONORDER_DATUM 11
#define L_STOCKRESERVATIONORDER_KDAUFTRAGNR 11
#define L_STOCKRESERVATIONORDER_KDAUFTRAGSTAT 16
#define L_STOCKRESERVATIONORDER_IDFNR 11
#define L_STOCKRESERVATIONORDER_FILIALNR 6
#define L_STOCKRESERVATIONORDER_KDAUFTRAGART 2
#define L_STOCKRESERVATIONORDER_KUNDENNR 11
#define L_STOCKRESERVATIONORDER_ZUGRUND 16

/* Length-Define of STOCKRESERVEDIBTREQUEST ***********************************/


/* Length-Define of SUPPLINFO *************************************************/

#define L_SUPPLINFO_ARTICLENO 11
#define L_SUPPLINFO_AVAILABILITYINFO 254
#define L_SUPPLINFO_PROGLIEFERDATUM 11
#define L_SUPPLINFO_LIEFERDATUM 11

/* Length-Define of DELAYEDART ************************************************/

#define L_DELAYEDART_BRANCHNO 6
#define L_DELAYEDART_NARCOTIC 1
#define L_DELAYEDART_COLDCHAIN 1
#define L_DELAYEDART_COOL08 1
#define L_DELAYEDART_COOL20 1

/* Length-Define of DISCOUNTANZ ***********************************************/

#define L_DISCOUNTANZ_BRANCHNO 6
#define L_DISCOUNTANZ_ARTICLENO 11
#define L_DISCOUNTANZ_DISCOUNTGRPNO 11
#define L_DISCOUNTANZ_PHARMACYGROUPID 3
#define L_DISCOUNTANZ_CUSTOMERNO 11
#define L_DISCOUNTANZ_GRPDISCOUNTTYP 6
#define L_DISCOUNTANZ_DATEFROM 11
#define L_DISCOUNTANZ_DATETO 11
#define L_DISCOUNTANZ_BASEQTY 11
#define L_DISCOUNTANZ_DISCOUNTSPEC 6
#define L_DISCOUNTANZ_DISCOUNTTYPE 6
#define L_DISCOUNTANZ_DISCOUNTQTY 6
#define L_DISCOUNTANZ_DISCOUNTVALUEPCT 5
#define N_DISCOUNTANZ_DISCOUNTVALUEPCT 2
#define L_DISCOUNTANZ_PREIS_TYP 6
#define L_DISCOUNTANZ_DISCOUNTQTYPCT 5
#define N_DISCOUNTANZ_DISCOUNTQTYPCT 2
#define L_DISCOUNTANZ_SURCHARGEPCT 5
#define N_DISCOUNTANZ_SURCHARGEPCT 2
#define L_DISCOUNTANZ_PHARMGRPEXCLUDED 3
#define L_DISCOUNTANZ_FIXEDPRICE 9
#define N_DISCOUNTANZ_FIXEDPRICE 2
#define L_DISCOUNTANZ_REFUNDPCT 5
#define N_DISCOUNTANZ_REFUNDPCT 2
#define L_DISCOUNTANZ_INTERNALDISCOUNT 1
#define L_DISCOUNTANZ_DISCOUNTARTICLE 11
#define L_DISCOUNTANZ_UPDATESIGN 1
#define L_DISCOUNTANZ_BASE_VALUE 10
#define N_DISCOUNTANZ_BASE_VALUE 2
#define L_DISCOUNTANZ_BASE_MULT_STD_QTY 11
#define L_DISCOUNTANZ_NO_MULTIPLE_QTY 1
#define L_DISCOUNTANZ_FIXEDDISCOUNTVALUE 9
#define N_DISCOUNTANZ_FIXEDDISCOUNTVALUE 2
#define L_DISCOUNTANZ_MANUFACTURERNO 11
#define L_DISCOUNTANZ_ARTCATEGORYNO 11
#define L_DISCOUNTANZ_PAYMENTTARGETNO 6
#define L_DISCOUNTANZ_GROSSPROFITPCT 5
#define N_DISCOUNTANZ_GROSSPROFITPCT 2
#define L_DISCOUNTANZ_ADDONDISCOUNTOK 1
#define L_DISCOUNTANZ_PAYMENTTERMTYPE 1
#define L_DISCOUNTANZ_TARGETQTY 11
#define L_DISCOUNTANZ_EXCEEDANCEPCT 5
#define N_DISCOUNTANZ_EXCEEDANCEPCT 2
#define L_DISCOUNTANZ_ARTICLE_NO_PACK 11
#define L_DISCOUNTANZ_REFUNDVALUE 9
#define N_DISCOUNTANZ_REFUNDVALUE 2
#define L_DISCOUNTANZ_PROMOTION_NO 6
#define L_DISCOUNTANZ_DISCOUNTAPPLYTO 6
#define L_DISCOUNTANZ_DISCOUNTCALCFROM 6

/* Length-Define of STOCKENTRY ************************************************/

#define L_STOCKENTRY_DATE 11
#define L_STOCKENTRY_BRANCHNO 6
#define L_STOCKENTRY_ARTICLENO 11
#define L_STOCKENTRY_BESTAND 11
#define L_STOCKENTRY_EINHEIT 9
#define L_STOCKENTRY_ARTIKEL_NAME 30

/* Length/Count-Define of STOCKRESERVATION ************************************/

#define LS_STOCKRESERVATION_BRANCHNO 5 + 1
#define LS_STOCKRESERVATION_CUSTOMERNO 10 + 1
#define LS_STOCKRESERVATION_ARTICLE_CODE 25 + 1
#define LS_STOCKRESERVATION_ARTICLENO 10 + 1
#define LS_STOCKRESERVATION_RESERVEDQTY 10 + 1
#define LS_STOCKRESERVATION_DATEFROM 10 + 1
#define LS_STOCKRESERVATION_TIMEFROM 10 + 1
#define LS_STOCKRESERVATION_DATETO 10 + 1
#define LS_STOCKRESERVATION_TIMETO 10 + 1
#define LS_STOCKRESERVATION_KDAUFTRAGNR 10 + 1
#define LS_STOCKRESERVATION_RESERVTYPE 5 + 1

#define STOCKRESERVATIONBRANCHNO 0
#define STOCKRESERVATIONCUSTOMERNO 1
#define STOCKRESERVATIONARTICLE_CODE 2
#define STOCKRESERVATIONARTICLENO 3
#define STOCKRESERVATIONRESERVEDQTY 4
#define STOCKRESERVATIONDATEFROM 5
#define STOCKRESERVATIONTIMEFROM 6
#define STOCKRESERVATIONDATETO 7
#define STOCKRESERVATIONTIMETO 8
#define STOCKRESERVATIONKDAUFTRAGNR 9
#define STOCKRESERVATIONRESERVTYPE 10

/* Length/Count-Define of STOCKRESERVATIONARTICLERESERV ***********************/

#define LS_STOCKRESERVATIONARTICLERESERV_BRANCHNO 5 + 1
#define LS_STOCKRESERVATIONARTICLERESERV_PHARMACYGROUPID 3 + 1
#define LS_STOCKRESERVATIONARTICLERESERV_ARTICLENO 10 + 1
#define LS_STOCKRESERVATIONARTICLERESERV_RESERVTYPE 5 + 1
#define LS_STOCKRESERVATIONARTICLERESERV_MAXQTY 10 + 1
#define LS_STOCKRESERVATIONARTICLERESERV_RESERVEDQTY 10 + 1

#define STOCKRESERVATIONARTICLERESERVBRANCHNO 0
#define STOCKRESERVATIONARTICLERESERVPHARMACYGROUPID 1
#define STOCKRESERVATIONARTICLERESERVARTICLENO 2
#define STOCKRESERVATIONARTICLERESERVRESERVTYPE 3
#define STOCKRESERVATIONARTICLERESERVMAXQTY 4
#define STOCKRESERVATIONARTICLERESERVRESERVEDQTY 5

/* Length/Count-Define of STOCKRESERVATIONARTIKELLOKAL ************************/

#define LS_STOCKRESERVATIONARTIKELLOKAL_FILIALNR 5 + 1
#define LS_STOCKRESERVATIONARTIKELLOKAL_ARTIKEL_NR 10 + 1
#define LS_STOCKRESERVATIONARTIKELLOKAL_BESTAND 10 + 1
#define LS_STOCKRESERVATIONARTIKELLOKAL_LAGERBEREICHNR 5 + 1
#define LS_STOCKRESERVATIONARTIKELLOKAL_STATIONNR 2 + 1
#define LS_STOCKRESERVATIONARTIKELLOKAL_LAGERFACHNR 10 + 1

#define STOCKRESERVATIONARTIKELLOKALFILIALNR 0
#define STOCKRESERVATIONARTIKELLOKALARTIKEL_NR 1
#define STOCKRESERVATIONARTIKELLOKALBESTAND 2
#define STOCKRESERVATIONARTIKELLOKALLAGERBEREICHNR 3
#define STOCKRESERVATIONARTIKELLOKALSTATIONNR 4
#define STOCKRESERVATIONARTIKELLOKALLAGERFACHNR 5

/* Length/Count-Define of STOCKRESERVATIONIBTREQUEST **************************/

#define LS_STOCKRESERVATIONIBTREQUEST_IBTREQUESTID 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_BRANCHNO 5 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_CSCORDERNO 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_CSCORDERPOSNO 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_DATEFROM 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_IBTBRANCHNO 5 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_IBTCUSTOMERNO 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_TIMEFROM 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_PROCESSINGSTATE 5 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_CUSTOMERNO 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_ARTICLENO 10 + 1
#define LS_STOCKRESERVATIONIBTREQUEST_QUANTITY 10 + 1

#define STOCKRESERVATIONIBTREQUESTIBTREQUESTID 0
#define STOCKRESERVATIONIBTREQUESTBRANCHNO 1
#define STOCKRESERVATIONIBTREQUESTCSCORDERNO 2
#define STOCKRESERVATIONIBTREQUESTCSCORDERPOSNO 3
#define STOCKRESERVATIONIBTREQUESTDATEFROM 4
#define STOCKRESERVATIONIBTREQUESTIBTBRANCHNO 5
#define STOCKRESERVATIONIBTREQUESTIBTCUSTOMERNO 6
#define STOCKRESERVATIONIBTREQUESTTIMEFROM 7
#define STOCKRESERVATIONIBTREQUESTPROCESSINGSTATE 8
#define STOCKRESERVATIONIBTREQUESTCUSTOMERNO 9
#define STOCKRESERVATIONIBTREQUESTARTICLENO 10
#define STOCKRESERVATIONIBTREQUESTQUANTITY 11

/* Length/Count-Define of STOCKRESERVATIONNACHLIEFERPOS ***********************/

#define LS_STOCKRESERVATIONNACHLIEFERPOS_KDAUFTRAGNR 10 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_POSNR 10 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_DATUM 10 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_POSTYP 5 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_IDFNR 10 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_ARTIKEL_NR 10 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_MENGE 10 + 1
#define LS_STOCKRESERVATIONNACHLIEFERPOS_STATUS 10 + 1

#define STOCKRESERVATIONNACHLIEFERPOSKDAUFTRAGNR 0
#define STOCKRESERVATIONNACHLIEFERPOSPOSNR 1
#define STOCKRESERVATIONNACHLIEFERPOSDATUM 2
#define STOCKRESERVATIONNACHLIEFERPOSPOSTYP 3
#define STOCKRESERVATIONNACHLIEFERPOSIDFNR 4
#define STOCKRESERVATIONNACHLIEFERPOSARTIKEL_NR 5
#define STOCKRESERVATIONNACHLIEFERPOSMENGE 6
#define STOCKRESERVATIONNACHLIEFERPOSSTATUS 7

/* Length/Count-Define of STOCKRESERVATIONORDER *******************************/

#define LS_STOCKRESERVATIONORDER_DATUM 10 + 1
#define LS_STOCKRESERVATIONORDER_KDAUFTRAGNR 10 + 1
#define LS_STOCKRESERVATIONORDER_KDAUFTRAGSTAT 16 + 1
#define LS_STOCKRESERVATIONORDER_IDFNR 10 + 1
#define LS_STOCKRESERVATIONORDER_FILIALNR 5 + 1
#define LS_STOCKRESERVATIONORDER_KDAUFTRAGART 2 + 1
#define LS_STOCKRESERVATIONORDER_KUNDENNR 10 + 1
#define LS_STOCKRESERVATIONORDER_ZUGRUND 16 + 1

#define STOCKRESERVATIONORDERDATUM 0
#define STOCKRESERVATIONORDERKDAUFTRAGNR 1
#define STOCKRESERVATIONORDERKDAUFTRAGSTAT 2
#define STOCKRESERVATIONORDERIDFNR 3
#define STOCKRESERVATIONORDERFILIALNR 4
#define STOCKRESERVATIONORDERKDAUFTRAGART 5
#define STOCKRESERVATIONORDERKUNDENNR 6
#define STOCKRESERVATIONORDERZUGRUND 7

#define STOCKRESERVATION_H
#define STOCKRESERVATION_ANZ ( sizeof(STOCKRESERVATION_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVATIONARTICLERESERV_H
#define STOCKRESERVATIONARTICLERESERV_ANZ ( sizeof(STOCKRESERVATIONARTICLERESERV_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVATIONARTIKELLOKAL_H
#define STOCKRESERVATIONARTIKELLOKAL_ANZ ( sizeof(STOCKRESERVATIONARTIKELLOKAL_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVATIONIBTREQUEST_H
#define STOCKRESERVATIONIBTREQUEST_ANZ ( sizeof(STOCKRESERVATIONIBTREQUEST_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVATIONNACHLIEFERPOS_H
#define STOCKRESERVATIONNACHLIEFERPOS_ANZ ( sizeof(STOCKRESERVATIONNACHLIEFERPOS_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVATIONORDER_H
#define STOCKRESERVATIONORDER_ANZ ( sizeof(STOCKRESERVATIONORDER_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVEDIBTREQUEST_H
#define STOCKRESERVEDIBTREQUEST_ANZ ( sizeof(STOCKRESERVEDIBTREQUEST_BES) / sizeof(struct buf_desc) )

/* SqlDefine of ARTBUYINGOPTIONS **********************************************/


#define ARTBUYINGOPTIONS_PLISTE \
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELZENTRAL.ETARTKLASSE1,"\
        "ARTIKELZENTRAL.KZPSYCHOSTOFFE"

/* SqlDefine of ARTCHARGE *****************************************************/


#define ARTCHARGE_PLISTE \
        "ARTICLECHARGE.BRANCHNO,"\
        "ARTICLECHARGE.ARTICLENO,"\
        "ARTICLECHARGE.EXPIRYDATE,"\
        "ARTICLECHARGE.CHARGENNR,"\
        "ARTICLECHARGE.STOCK,"\
        "ARTICLECHARGE.STATECHARGE"

/* SqlDefine of ARTINFBG ******************************************************/


#define ARTINFBG_PLISTE \
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELZENTRAL.HEALTHFUNDCODE,"\
        "ARTIKELZENTRAL.ARTIKEL_LANGNAME"

/* SqlDefine of ARTINSERT *****************************************************/


#define ARTINSERT_PLISTE \
        "ARTINFOTEXT.ARTICLENO,"\
        "ARTINFOTEXT.ARTINFOTYPE,"\
        "ARTINFOTEXT.SEQUENCENO,"\
        "ARTINFOTEXT.INFOTEXT"

/* SqlDefine of ARTLANGNAME ***************************************************/


#define ARTLANGNAME_PLISTE \
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELZENTRAL.ARTIKEL_LANGNAME"

/* SqlDefine of ARTPRICE ******************************************************/


#define ARTPRICE_PLISTE \
        "ARTIKELPREIS.ARTIKEL_NR,"\
        "ARTIKELPREIS.PREISEKAPO,"\
        "ARTIKELPREIS.PREISEKGROSSO,"\
        "ARTIKELPREIS.PREIS_TYP"

/* SqlDefine of ARTPSYCHO *****************************************************/


#define ARTPSYCHO_PLISTE \
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELZENTRAL.ETARTKLASSE1,"\
        "ARTIKELZENTRAL.KZPSYCHOSTOFFE"

/* SqlDefine of ARTICLEAGENTGROUP *********************************************/


#define ARTICLEAGENTGROUP_PLISTE \
        "ARTIKELPREIS.PREISEKAPO,"\
        "ARTIKELLOKAL.FILIALNR,"\
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELLOKAL.BESTAND,"\
        "ARTIKELZENTRAL.DARREICHFORM,"\
        "ARTIKELZENTRAL.EINHEIT,"\
        "ARTIKELZENTRAL.ARTIKEL_NAME,"\
        "ARTIKELZENTRAL.WIRKSTOFF_NR,"\
        "ARTIKELZENTRAL.ARTIKEL_LANGNAME"

/* SqlDefine of ARTICLELPPRREIMB **********************************************/


#define ARTICLELPPRREIMB_PLISTE \
        "ARTICLELPPRCOMB.ARTICLENO,"\
        "ARTICLELPPRCOMB.CODE_LPPR,"\
        "LPPRREIMB.DATEFROM,"\
        "LPPRREIMB.REIMBURSEMENT_VAL,"\
        "LPPRREIMB.LPPR_DESC,"\
        "ARTICLELPPRCOMB.REIMBCALCFLAG"

/* SqlDefine of ARTICLEQUOTADETAIL ********************************************/


#define ARTICLEQUOTADETAIL_PLISTE \
        "ARTICLEQUOTA.BRANCHNO,"\
        "ARTICLEQUOTA.CUSTOMERNO,"\
        "ARTICLEQUOTA.ARTICLENO,"\
        "ARTICLEQUOTA.QUOTA,"\
        "ARTICLEQUOTA.VALIDITY,"\
        "KUNDE.KZKDKLASSE,"\
        "ARTIKELZENTRAL.EINHEIT,"\
        "ARTIKELZENTRAL.ARTIKEL_NAME"

/* SqlDefine of ARTICLEQUOTAEKG ***********************************************/


#define ARTICLEQUOTAEKG_PLISTE \
        "ARTICLEQUOTA.BRANCHNO,"\
        "PHARMACYGROUPS.GROUP_NAME,"\
        "ARTICLEQUOTA.ARTICLENO,"\
        "ARTICLEQUOTA.QUOTA,"\
        "ARTICLEQUOTA.KUMQTY,"\
        "ARTICLEQUOTA.VALIDITY,"\
        "ARTICLEQUOTA.DATEUPDATE,"\
        "ARTICLEQUOTA.UID_ANLAGE,"\
        "ARTICLEQUOTA.DATEFROM,"\
        "ARTICLEQUOTA.DATETO,"\
        "ARTICLEQUOTA.PHARMACYGROUPID,"\
        "ARTICLEQUOTA.SNOBATCHCHANGE,"\
        "ARTIKELZENTRAL.EINHEIT,"\
        "ARTIKELZENTRAL.ARTIKEL_NAME"

/* SqlDefine of ARTICLETAX ****************************************************/


#define ARTICLETAX_PLISTE \
        "TAXRATES.SALESTAXRATE,"\
        "ARTIKELZENTRAL.ARTIKEL_NR"

/* SqlDefine of ARTIKELLPPR ***************************************************/


#define ARTIKELLPPR_PLISTE \
        "ARTICLELPPR.ARTICLENO,"\
        "ARTICLELPPR.REIMBURSEMENT_TYPE,"\
        "ARTICLELPPR.REIMBURSEMENTPRICE,"\
        "ARTICLELPPR.CODE_LPPR,"\
        "ARTICLELPPR.REIMBURSEMENT_PERC"

/* SqlDefine of ARTIKELQUOTA **************************************************/


#define ARTIKELQUOTA_PLISTE \
        "ARTICLEQUOTA.BRANCHNO,"\
        "ARTICLEQUOTA.CUSTOMERNO,"\
        "KUNDE.MATCHCODE,"\
        "ARTICLEQUOTA.ARTICLENO,"\
        "ARTICLEQUOTA.QUOTA,"\
        "ARTICLEQUOTA.KUMQTY,"\
        "ARTICLEQUOTA.VALIDITY,"\
        "ARTICLEQUOTA.DATEUPDATE,"\
        "ARTICLEQUOTA.UID_ANLAGE,"\
        "ARTICLEQUOTA.SDAFUEQUOTA,"\
        "ARTICLEQUOTA.DATEFROM,"\
        "ARTICLEQUOTA.DATETO,"\
        "ARTICLEQUOTA.PHARMACYGROUPID,"\
        "ARTICLEQUOTA.SNOBATCHCHANGE,"\
        "ARTIKELZENTRAL.EINHEIT,"\
        "ARTIKELZENTRAL.ARTIKEL_NAME"

/* SqlDefine of ARTIKELQUOTAPF ************************************************/


#define ARTIKELQUOTAPF_PLISTE \
        "ARTICLEQUOTA.BRANCHNO,"\
        "ARTICLEQUOTA.CUSTOMERNO,"\
        "ARTICLEQUOTA.ARTICLENO,"\
        "ARTICLEQUOTA.QUOTA,"\
        "ARTICLEQUOTA.KUMQTY,"\
        "ARTICLEQUOTA.VALIDITY,"\
        "ARTICLEQUOTA.DATEUPDATE,"\
        "ARTICLEQUOTA.UID_ANLAGE,"\
        "ARTICLEQUOTA.SDAFUEQUOTA,"\
        "ARTICLEQUOTA.DATEFROM,"\
        "ARTICLEQUOTA.DATETO,"\
        "ARTICLEQUOTA.SNOBATCHCHANGE"

/* SqlDefine of ARTIKELRESERVE ************************************************/


#define ARTIKELRESERVE_PLISTE \
        "ARTICLERESERVATION.BRANCHNO,"\
        "ARTICLERESERVATION.PHARMACYGROUPID,"\
        "ARTICLERESERVATION.ARTICLENO,"\
        "ARTICLERESERVATION.RESERVTYPE,"\
        "ARTICLERESERVATION.MAXQTY,"\
        "ARTICLERESERVATION.RESERVEDQTY,"\
        "ARTICLERESERVATION.RESERVEPCT"

/* SqlDefine of ARTIKELTEXT ***************************************************/


#define ARTIKELTEXT_PLISTE \
        "ARTICLETEXT.BRANCHNO,"\
        "ARTICLETEXT.TEXTKEY,"\
        "ARTICLETEXT.TEXT,"\
        "ARTICLETEXT.DISPLAYONSCREEN,"\
        "ARTICLETEXT.TEXTHOSPITAL"

/* SqlDefine of ARTIKELVERFALL ************************************************/


#define ARTIKELVERFALL_PLISTE \
        "ARTIKELLAGERORT.FILIALNR,"\
        "ARTIKELLAGERORT.ARTIKEL_NR,"\
        "ARTIKELLAGERORT.DATUMVERFALL"

/* SqlDefine of ATICLEAUX *****************************************************/


#define ATICLEAUX_PLISTE \
        "ARTICLEAUXBRANCH.BRANCHNO,"\
        "ARTICLEAUXBRANCH.ARTICLENO,"\
        "ARTICLEAUXBRANCH.RANKING,"\
        "ARTICLEAUXBRANCH.AUXBRANCHNO"

/* SqlDefine of CCODE *********************************************************/


#define CCODE_PLISTE \
        "COUNTRYCODES.BRANCHNO,"\
        "COUNTRYCODES.INFOCODE,"\
        "COUNTRYCODES.ARTICLEACTIV,"\
        "COUNTRYCODES.AUXDELIVERY,"\
        "COUNTRYCODES.SERACODE,"\
        "COUNTRYCODES.PRINTCODE,"\
        "COUNTRYCODES.XMLCODE,"\
        "COUNTRYCODES.XMLTEXT"

/* SqlDefine of CHECKIMEXBLOCKEXIST *******************************************/


#define CHECKIMEXBLOCKEXIST_PLISTE \
        "IMEXBLOCK.ARTICLENO"

/* SqlDefine of CHECKIMPORTARTICLE ********************************************/


#define CHECKIMPORTARTICLE_PLISTE \
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELZENTRAL.IMPORTARTICLE"

/* SqlDefine of CHECKLISTE5ZENTRAL ********************************************/


#define CHECKLISTE5ZENTRAL_PLISTE \
        "ARTIKELZENTRAL.ARTIKEL_NR"

/* SqlDefine of CODEBLOCAGEINFO ***********************************************/


#define CODEBLOCAGEINFO_PLISTE \
        "COUNTRYCODES.PRINTCODE,"\
        "ARTIKELLOKAL.FILIALNR,"\
        "ARTIKELLOKAL.ARTIKEL_NR"

/* SqlDefine of DISPOINFO *****************************************************/


#define DISPOINFO_PLISTE \
        "TELLIST.BEZEICHNUNG,"\
        "TELLIST.DISPO_HINWEIS,"\
        "TELLIST.BEMERKUNG,"\
        "TELLIST.PZN,"\
        "ARTIKELZENTRAL.ARTIKEL_NR,"\
        "ARTIKELZENTRAL.HERSTELLER_NR"

/* SqlDefine of HERSTELLER ****************************************************/


#define HERSTELLER_PLISTE \
        "HERSTEL.NAME,"\
        "ARTIKELZENTRAL.ARTIKEL_NR"

/* SqlDefine of LPPRCODE ******************************************************/


#define LPPRCODE_PLISTE \
        "LPPRCODE.CODE_LPPR,"\
        "LPPRCODE.REIMBURSEMENT_VAL"

/* SqlDefine of MAXARTICLEQUOTA ***********************************************/


#define MAXARTICLEQUOTA_PLISTE \
        "MAXARTICLEQUOTA.ARTICLENO,"\
        "MAXARTICLEQUOTA.MAXQUOTA"

/* SqlDefine of OCCASION ******************************************************/


#define OCCASION_PLISTE \
        "CUSTOMERPHARMACYGR.CUSTOMERNO,"\
        "DISCOUNT.ARTICLENO,"\
        "CUSTOMERPHARMACYGR.BRANCHNO,"\
        "DISCOUNT.DISCOUNTVALUEPCT"

/* SqlDefine of PHARMGRP ******************************************************/


#define PHARMGRP_PLISTE \
        "PHARMACYGROUPS.PHARMACYGROUPID,"\
        "PHARMACYGROUPS.GROUP_NAME,"\
        "PHARMACYGROUPS.GROUP_TYPE,"\
        "PHARMACYGROUPS.PERCENT,"\
        "PHARMACYGROUPS.CONTRIBUTION,"\
        "PHARMACYGROUPS.CUSTOMERNO,"\
        "PHARMACYGROUPS.OMG_OWN_CONT,"\
        "PHARMACYGROUPS.PRICE_BASIS_PURCH,"\
        "PHARMACYGROUPS.RECLAIM_OMG_DISC,"\
        "PHARMACYGROUPS.SPECIALGROUP,"\
        "PHARMACYGROUPS.SPECIALGROUPREFNO,"\
        "PHARMACYGROUPS.GROUPING_VIS,"\
        "PHARMACYGROUPS.BRANCHNO"

/* SqlDefine of PREISANZTYP ***************************************************/


#define PREISANZTYP_PLISTE \
        "ARTIKELPREIS.ARTIKEL_NR,"\
        "ARTIKELPREIS.PREISEKAPO,"\
        "ARTIKELPREIS.PREISEKGROSSO,"\
        "ARTIKELPREIS.PREISEKGROSSONA,"\
        "ARTIKELPREIS.PREIS_TYP"

/* SqlDefine of PRICEHIST *****************************************************/


#define PRICEHIST_PLISTE \
        "PRICEHISTORY.ARTIKEL_NR,"\
        "PRICEHISTORY.DATUMGUELTIGAB,"\
        "PRICEHISTORY.GROSSO,"\
        "PRICEHISTORY.AEP,"\
        "PRICEHISTORY.AVP"

/* SqlDefine of PROMOANZ ******************************************************/


#define PROMOANZ_PLISTE \
        "PROMOTIONS.PROMOTION_NO,"\
        "PROMOTIONS.NAME,"\
        "PROMOTIONS.DESCRIPTION,"\
        "PROMOTIONS.PROMOTION_TYPE"

/* SqlDefine of REIMPORT ******************************************************/


#define REIMPORT_PLISTE \
        "ARTIKEL.DARREICHFORM,"\
        "ARTIKELPREIS.PREISEKAPO,"\
        "ARTIKEL.EINHEIT,"\
        "ARTIKEL.ARTIKEL_NAME,"\
        "ARTIKEL.BESTAND,"\
        "ARTIKELNUMMERN.PZN"

/* SqlDefine of STELLER *******************************************************/


#define STELLER_PLISTE \
        "ARTCOMPACK.ARTICLE_NO_PACK,"\
        "ARTCOMPACK.ARTICLE_NO_ELEMENT,"\
        "ARTCOMPACK.QUANTITY,"\
        "ARTIKELLOKAL.FILIALNR,"\
        "ARTIKELLOKAL.BESTAND,"\
        "ARTIKELZENTRAL.DARREICHFORM,"\
        "ARTIKELZENTRAL.EINHEIT,"\
        "ARTIKELZENTRAL.ARTIKEL_NAME,"\
        "ARTIKELZENTRAL.ARTIKEL_LANGNAME"

/* SqlDefine of STELLERTYP ****************************************************/


#define STELLERTYP_PLISTE \
        "CPVALIDITYPERIOD.ARTICLE_NO_PACK,"\
        "CPVALIDITYPERIOD.DATEFROM,"\
        "CPVALIDITYPERIOD.DATETO,"\
        "CPVALIDITYPERIOD.COMPACK_TYPE"

/* SqlDefine of STOCKRESERVATION **********************************************/

#define STOCKRESERVATION_LISTE \
        CSTSTOCKRESERVED.BRANCHNO,\
        CSTSTOCKRESERVED.CUSTOMERNO,\
        ARTICLECODES.ARTICLE_CODE,\
        CSTSTOCKRESERVED.ARTICLENO,\
        CSTSTOCKRESERVED.RESERVEDQTY,\
        CSTSTOCKRESERVED.DATEFROM,\
        CSTSTOCKRESERVED.TIMEFROM,\
        CSTSTOCKRESERVED.DATETO,\
        CSTSTOCKRESERVED.TIMETO,\
        CSTSTOCKRESERVED.KDAUFTRAGNR,\
        CSTSTOCKRESERVED.RESERVTYPE
#define STOCKRESERVATION_LISTE_390 \
        BRANCHNO,\
        CUSTOMERNO,\
        ARTICLE_CODE,\
        ARTICLENO,\
        RESERVEDQTY,\
        DATEFROM,\
        TIMEFROM,\
        DATETO,\
        TIMETO,\
        KDAUFTRAGNR,\
        RESERVTYPE
#define STOCKRESERVATION_PLISTE \
        "CSTSTOCKRESERVED.BRANCHNO,"\
        "CSTSTOCKRESERVED.CUSTOMERNO,"\
        "ARTICLECODES.ARTICLE_CODE,"\
        "CSTSTOCKRESERVED.ARTICLENO,"\
        "CSTSTOCKRESERVED.RESERVEDQTY,"\
        "CSTSTOCKRESERVED.DATEFROM,"\
        "CSTSTOCKRESERVED.TIMEFROM,"\
        "CSTSTOCKRESERVED.DATETO,"\
        "CSTSTOCKRESERVED.TIMETO,"\
        "CSTSTOCKRESERVED.KDAUFTRAGNR,"\
        "CSTSTOCKRESERVED.RESERVTYPE"
#define STOCKRESERVATION_PELISTE \
        "BRANCHNO,"\
        "CUSTOMERNO,"\
        "ARTICLE_CODE,"\
        "ARTICLENO,"\
        "RESERVEDQTY,"\
        "DATEFROM,"\
        "TIMEFROM,"\
        "DATETO,"\
        "TIMETO,"\
        "KDAUFTRAGNR,"\
        "RESERVTYPE"
#define STOCKRESERVATION_UPDLISTE \
        "BRANCHNO=?,"\
        "CUSTOMERNO=?,"\
        "ARTICLE_CODE=?,"\
        "ARTICLENO=?,"\
        "RESERVEDQTY=?,"\
        "DATEFROM=?,"\
        "TIMEFROM=?,"\
        "DATETO=?,"\
        "TIMETO=?,"\
        "KDAUFTRAGNR=?,"\
        "RESERVTYPE=?"
/* SqlDefine of STOCKRESERVATIONARTICLERESERV *********************************/

#define STOCKRESERVATIONARTICLERESERV_LISTE \
        ARTICLERESERVATION.BRANCHNO,\
        ARTICLERESERVATION.PHARMACYGROUPID,\
        ARTICLERESERVATION.ARTICLENO,\
        ARTICLERESERVATION.RESERVTYPE,\
        ARTICLERESERVATION.MAXQTY,\
        ARTICLERESERVATION.RESERVEDQTY
#define STOCKRESERVATIONARTICLERESERV_LISTE_390 \
        BRANCHNO,\
        PHARMACYGROUPID,\
        ARTICLENO,\
        RESERVTYPE,\
        MAXQTY,\
        RESERVEDQTY
#define STOCKRESERVATIONARTICLERESERV_PLISTE \
        "ARTICLERESERVATION.BRANCHNO,"\
        "ARTICLERESERVATION.PHARMACYGROUPID,"\
        "ARTICLERESERVATION.ARTICLENO,"\
        "ARTICLERESERVATION.RESERVTYPE,"\
        "ARTICLERESERVATION.MAXQTY,"\
        "ARTICLERESERVATION.RESERVEDQTY"
#define STOCKRESERVATIONARTICLERESERV_PELISTE \
        "BRANCHNO,"\
        "PHARMACYGROUPID,"\
        "ARTICLENO,"\
        "RESERVTYPE,"\
        "MAXQTY,"\
        "RESERVEDQTY"
#define STOCKRESERVATIONARTICLERESERV_UPDLISTE \
        "BRANCHNO=?,"\
        "PHARMACYGROUPID=?,"\
        "ARTICLENO=?,"\
        "RESERVTYPE=?,"\
        "MAXQTY=?,"\
        "RESERVEDQTY=?"
/* SqlDefine of STOCKRESERVATIONARTIKELLOKAL **********************************/

#define STOCKRESERVATIONARTIKELLOKAL_LISTE \
        ARTIKELLOKAL.FILIALNR,\
        ARTIKELLOKAL.ARTIKEL_NR,\
        ARTIKELLOKAL.BESTAND,\
        ARTIKELLOKAL.LAGERBEREICHNR,\
        ARTIKELLOKAL.STATIONNR,\
        ARTIKELLOKAL.LAGERFACHNR
#define STOCKRESERVATIONARTIKELLOKAL_LISTE_390 \
        FILIALNR,\
        ARTIKEL_NR,\
        BESTAND,\
        LAGERBEREICHNR,\
        STATIONNR,\
        LAGERFACHNR
#define STOCKRESERVATIONARTIKELLOKAL_PLISTE \
        "ARTIKELLOKAL.FILIALNR,"\
        "ARTIKELLOKAL.ARTIKEL_NR,"\
        "ARTIKELLOKAL.BESTAND,"\
        "ARTIKELLOKAL.LAGERBEREICHNR,"\
        "ARTIKELLOKAL.STATIONNR,"\
        "ARTIKELLOKAL.LAGERFACHNR"
#define STOCKRESERVATIONARTIKELLOKAL_PELISTE \
        "FILIALNR,"\
        "ARTIKEL_NR,"\
        "BESTAND,"\
        "LAGERBEREICHNR,"\
        "STATIONNR,"\
        "LAGERFACHNR"
#define STOCKRESERVATIONARTIKELLOKAL_UPDLISTE \
        "FILIALNR=?,"\
        "ARTIKEL_NR=?,"\
        "BESTAND=?,"\
        "LAGERBEREICHNR=?,"\
        "STATIONNR=?,"\
        "LAGERFACHNR=?"

/* SqlDefine of STOCKRESERVATIONIBTREQUEST ************************************/

#define STOCKRESERVATIONIBTREQUEST_LISTE \
        IBTREQUEST.IBTREQUESTID,\
        IBTREQUEST.BRANCHNO,\
        IBTREQUEST.CSCORDERNO,\
        IBTREQUEST.CSCORDERPOSNO,\
        CSTSTOCKRESERVED.DATEFROM,\
        IBTREQUEST.IBTBRANCHNO,\
        IBTREQUEST.IBTCUSTOMERNO,\
        CSTSTOCKRESERVED.TIMEFROM,\
        IBTREQUEST.PROCESSINGSTATE,\
        IBTREQUEST.CUSTOMERNO,\
        IBTREQUEST.ARTICLENO,\
        IBTREQUEST.QUANTITY
#define STOCKRESERVATIONIBTREQUEST_LISTE_390 \
        IBTREQUESTID,\
        BRANCHNO,\
        CSCORDERNO,\
        CSCORDERPOSNO,\
        DATEFROM,\
        IBTBRANCHNO,\
        IBTCUSTOMERNO,\
        TIMEFROM,\
        PROCESSINGSTATE,\
        CUSTOMERNO,\
        ARTICLENO,\
        QUANTITY
#define STOCKRESERVATIONIBTREQUEST_PLISTE \
        "IBTREQUEST.IBTREQUESTID,"\
        "IBTREQUEST.BRANCHNO,"\
        "IBTREQUEST.CSCORDERNO,"\
        "IBTREQUEST.CSCORDERPOSNO,"\
        "CSTSTOCKRESERVED.DATEFROM,"\
        "IBTREQUEST.IBTBRANCHNO,"\
        "IBTREQUEST.IBTCUSTOMERNO,"\
        "CSTSTOCKRESERVED.TIMEFROM,"\
        "IBTREQUEST.PROCESSINGSTATE,"\
        "IBTREQUEST.CUSTOMERNO,"\
        "IBTREQUEST.ARTICLENO,"\
        "IBTREQUEST.QUANTITY"
#define STOCKRESERVATIONIBTREQUEST_PELISTE \
        "IBTREQUESTID,"\
        "BRANCHNO,"\
        "CSCORDERNO,"\
        "CSCORDERPOSNO,"\
        "DATEFROM,"\
        "IBTBRANCHNO,"\
        "IBTCUSTOMERNO,"\
        "TIMEFROM,"\
        "PROCESSINGSTATE,"\
        "CUSTOMERNO,"\
        "ARTICLENO,"\
        "QUANTITY"
#define STOCKRESERVATIONIBTREQUEST_UPDLISTE \
        "IBTREQUESTID=?,"\
        "BRANCHNO=?,"\
        "CSCORDERNO=?,"\
        "CSCORDERPOSNO=?,"\
        "DATEFROM=?,"\
        "IBTBRANCHNO=?,"\
        "IBTCUSTOMERNO=?,"\
        "TIMEFROM=?,"\
        "PROCESSINGSTATE=?,"\
        "CUSTOMERNO=?,"\
        "ARTICLENO=?,"\
        "QUANTITY=?"

/* SqlDefine of STOCKRESERVATIONNACHLIEFERPOS *********************************/

#define STOCKRESERVATIONNACHLIEFERPOS_LISTE \
        NACHLIEFERPOS.KDAUFTRAGNR,\
        NACHLIEFERPOS.POSNR,\
        NACHLIEFERPOS.DATUM,\
        NACHLIEFERPOS.POSTYP,\
        NACHLIEFERPOS.IDFNR,\
        NACHLIEFERPOS.ARTIKEL_NR,\
        NACHLIEFERPOS.MENGE,\
        NACHLIEFERPOS.STATUS
#define STOCKRESERVATIONNACHLIEFERPOS_LISTE_390 \
        KDAUFTRAGNR,\
        POSNR,\
        DATUM,\
        POSTYP,\
        IDFNR,\
        ARTIKEL_NR,\
        MENGE,\
        STATUS
#define STOCKRESERVATIONNACHLIEFERPOS_PLISTE \
        "NACHLIEFERPOS.KDAUFTRAGNR,"\
        "NACHLIEFERPOS.POSNR,"\
        "NACHLIEFERPOS.DATUM,"\
        "NACHLIEFERPOS.POSTYP,"\
        "NACHLIEFERPOS.IDFNR,"\
        "NACHLIEFERPOS.ARTIKEL_NR,"\
        "NACHLIEFERPOS.MENGE,"\
        "NACHLIEFERPOS.STATUS"
#define STOCKRESERVATIONNACHLIEFERPOS_PELISTE \
        "KDAUFTRAGNR,"\
        "POSNR,"\
        "DATUM,"\
        "POSTYP,"\
        "IDFNR,"\
        "ARTIKEL_NR,"\
        "MENGE,"\
        "STATUS"
#define STOCKRESERVATIONNACHLIEFERPOS_UPDLISTE \
        "KDAUFTRAGNR=?,"\
        "POSNR=?,"\
        "DATUM=?,"\
        "POSTYP=?,"\
        "IDFNR=?,"\
        "ARTIKEL_NR=?,"\
        "MENGE=?,"\
        "STATUS=?"

/* SqlDefine of STOCKRESERVATIONORDER *****************************************/

#define STOCKRESERVATIONORDER_LISTE \
        AKDAUFTRAG.DATUM,\
        KDAUFTRAG.KDAUFTRAGNR,\
        KDAUFTRAG.KDAUFTRAGSTAT,\
        KDAUFTRAG.IDFNR,\
        KDAUFTRAG.FILIALNR,\
        KDAUFTRAG.KDAUFTRAGART,\
        KDAUFTRAG.KUNDENNR,\
        KDAUFTRAG.ZUGRUND
#define STOCKRESERVATIONORDER_LISTE_390 \
        DATUM,\
        KDAUFTRAGNR,\
        KDAUFTRAGSTAT,\
        IDFNR,\
        FILIALNR,\
        KDAUFTRAGART,\
        KUNDENNR,\
        ZUGRUND
#define STOCKRESERVATIONORDER_PLISTE \
        "AKDAUFTRAG.DATUM,"\
        "KDAUFTRAG.KDAUFTRAGNR,"\
        "KDAUFTRAG.KDAUFTRAGSTAT,"\
        "KDAUFTRAG.IDFNR,"\
        "KDAUFTRAG.FILIALNR,"\
        "KDAUFTRAG.KDAUFTRAGART,"\
        "KDAUFTRAG.KUNDENNR,"\
        "KDAUFTRAG.ZUGRUND"
#define STOCKRESERVATIONORDER_PELISTE \
        "DATUM,"\
        "KDAUFTRAGNR,"\
        "KDAUFTRAGSTAT,"\
        "IDFNR,"\
        "FILIALNR,"\
        "KDAUFTRAGART,"\
        "KUNDENNR,"\
        "ZUGRUND"
#define STOCKRESERVATIONORDER_UPDLISTE \
        "DATUM=?,"\
        "KDAUFTRAGNR=?,"\
        "KDAUFTRAGSTAT=?,"\
        "IDFNR=?,"\
        "FILIALNR=?,"\
        "KDAUFTRAGART=?,"\
        "KUNDENNR=?,"\
        "ZUGRUND=?"

/* SqlDefine of SUPPLINFO *****************************************************/


#define SUPPLINFO_PLISTE \
        "SUPPLDELIVERYINFO.ARTICLENO,"\
        "SUPPLDELIVERYINFO.AVAILABILITYINFO"

/* SqlDefine of DELAYEDART ****************************************************/


#define DELAYEDART_PLISTE \
        "DELAYEDDELIVERYART.BRANCHNO,"\
        "DELAYEDDELIVERYART.NARCOTIC,"\
        "DELAYEDDELIVERYART.COLDCHAIN,"\
        "DELAYEDDELIVERYART.COOL08,"\
        "DELAYEDDELIVERYART.COOL20"

/* SqlDefine of DISCOUNTANZ ***************************************************/


#define DISCOUNTANZ_PLISTE \
        "DISCOUNT.BRANCHNO,"\
        "DISCOUNT.ARTICLENO,"\
        "DISCOUNT.DISCOUNTGRPNO,"\
        "DISCOUNT.PHARMACYGROUPID,"\
        "DISCOUNT.CUSTOMERNO,"\
        "DISCOUNT.GRPDISCOUNTTYP,"\
        "DISCOUNT.DATEFROM,"\
        "DISCOUNT.DATETO,"\
        "DISCOUNT.BASEQTY,"\
        "DISCOUNT.DISCOUNTSPEC,"\
        "DISCOUNT.DISCOUNTTYPE,"\
        "DISCOUNT.DISCOUNTQTY,"\
        "DISCOUNT.DISCOUNTVALUEPCT,"\
        "DISCOUNT.DISCOUNTQTYPCT,"\
        "DISCOUNT.SURCHARGEPCT,"\
        "DISCOUNT.PHARMGRPEXCLUDED,"\
        "DISCOUNT.FIXEDPRICE,"\
        "DISCOUNT.REFUNDPCT,"\
        "DISCOUNT.INTERNALDISCOUNT,"\
        "DISCOUNT.DISCOUNTARTICLE,"\
        "DISCOUNT.UPDATESIGN,"\
        "DISCOUNT.BASE_VALUE,"\
        "DISCOUNT.BASE_MULT_STD_QTY,"\
        "DISCOUNT.NO_MULTIPLE_QTY,"\
        "DISCOUNT.FIXEDDISCOUNTVALUE,"\
        "DISCOUNT.MANUFACTURERNO,"\
        "DISCOUNT.ARTCATEGORYNO,"\
        "DISCOUNT.PAYMENTTARGETNO,"\
        "DISCOUNT.GROSSPROFITPCT,"\
        "DISCOUNT.ADDONDISCOUNTOK,"\
        "DISCOUNT.PAYMENTTERMTYPE,"\
        "DISCOUNT.TARGETQTY,"\
        "DISCOUNT.EXCEEDANCEPCT,"\
        "DISCOUNT.ARTICLE_NO_PACK,"\
        "DISCOUNT.REFUNDVALUE,"\
        "DISCOUNT.PROMOTION_NO,"\
        "DISCOUNT.DISCOUNTAPPLYTO,"\
        "DISCOUNT.DISCOUNTCALCFROM"

/* SqlDefine of STOCKENTRY ****************************************************/


#define STOCKENTRY_PLISTE \
        "STOCKENTRY.DATE,"\
        "STOCKENTRY.BRANCHNO,"\
        "STOCKENTRY.ARTICLENO,"\
        "ARTIKELLOKAL.BESTAND,"\
        "ARTIKELZENTRAL.EINHEIT,"\
        "ARTIKELZENTRAL.ARTIKEL_NAME"

/* SqlDefine of ARTBUYINGOPTIONS **********************************************/


#define ARTBUYINGOPTIONS_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "ETARTKLASSE1=?,"\
        "KZPSYCHOSTOFFE=?"
/* SqlDefine of ARTCHARGE *****************************************************/


#define ARTCHARGE_UPDLISTE \
        "BRANCHNO=?,"\
        "ARTICLENO=?,"\
        "EXPIRYDATE=?,"\
        "CHARGENNR=?,"\
        "STOCK=?,"\
        "STATECHARGE=?"
/* SqlDefine of ARTINFBG ******************************************************/


#define ARTINFBG_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "HEALTHFUNDCODE=?,"\
        "ARTIKEL_LANGNAME=?"
/* SqlDefine of ARTINSERT *****************************************************/


#define ARTINSERT_UPDLISTE \
        "ARTICLENO=?,"\
        "ARTINFOTYPE=?,"\
        "SEQUENCENO=?,"\
        "INFOTEXT=?"
/* SqlDefine of ARTLANGNAME ***************************************************/


#define ARTLANGNAME_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "ARTIKEL_LANGNAME=?"
/* SqlDefine of ARTPRICE ******************************************************/


#define ARTPRICE_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "PREISEKAPO=?,"\
        "PREISEKGROSSO=?,"\
        "PREIS_TYP=?"
/* SqlDefine of ARTPSYCHO *****************************************************/


#define ARTPSYCHO_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "ETARTKLASSE1=?,"\
        "KZPSYCHOSTOFFE=?"
/* SqlDefine of ARTICLEAGENTGROUP *********************************************/


#define ARTICLEAGENTGROUP_UPDLISTE \
        "PREISEKAPO=?,"\
        "FILIALNR=?,"\
        "ARTIKEL_NR=?,"\
        "BESTAND=?,"\
        "DARREICHFORM=?,"\
        "EINHEIT=?,"\
        "ARTIKEL_NAME=?,"\
        "WIRKSTOFF_NR=?,"\
        "ARTIKEL_LANGNAME=?"
/* SqlDefine of ARTICLELPPRREIMB **********************************************/


#define ARTICLELPPRREIMB_UPDLISTE \
        "ARTICLENO=?,"\
        "CODE_LPPR=?,"\
        "DATEFROM=?,"\
        "REIMBURSEMENT_VAL=?,"\
        "LPPR_DESC=?,"\
        "REIMBCALCFLAG=?"
/* SqlDefine of ARTICLEQUOTADETAIL ********************************************/


#define ARTICLEQUOTADETAIL_UPDLISTE \
        "BRANCHNO=?,"\
        "CUSTOMERNO=?,"\
        "ARTICLENO=?,"\
        "QUOTA=?,"\
        "VALIDITY=?"
/* SqlDefine of ARTICLEQUOTAEKG ***********************************************/


#define ARTICLEQUOTAEKG_UPDLISTE \
        "BRANCHNO=?,"\
        "ARTICLENO=?,"\
        "QUOTA=?,"\
        "KUMQTY=?,"\
        "VALIDITY=?,"\
        "DATEUPDATE=?,"\
        "UID_ANLAGE=?,"\
        "DATEFROM=?,"\
        "DATETO=?,"\
        "PHARMACYGROUPID=?,"\
        "SNOBATCHCHANGE=?"
/* SqlDefine of ARTICLETAX ****************************************************/


#define ARTICLETAX_UPDLISTE \
        "SALESTAXRATE=?,"\
        "ARTIKEL_NR=?"
/* SqlDefine of ARTIKELLPPR ***************************************************/


#define ARTIKELLPPR_UPDLISTE \
        "ARTICLENO=?,"\
        "REIMBURSEMENT_TYPE=?,"\
        "REIMBURSEMENTPRICE=?,"\
        "CODE_LPPR=?,"\
        "REIMBURSEMENT_PERC=?"
/* SqlDefine of ARTIKELQUOTA **************************************************/


#define ARTIKELQUOTA_UPDLISTE \
        "BRANCHNO=?,"\
        "CUSTOMERNO=?,"\
        "ARTICLENO=?,"\
        "QUOTA=?,"\
        "VALIDITY=?,"\
        "DATEUPDATE=?,"\
        "UID_ANLAGE=?,"\
        "SDAFUEQUOTA=?,"\
        "DATEFROM=?,"\
        "DATETO=?,"\
        "PHARMACYGROUPID=?,"\
        "SNOBATCHCHANGE=?"
/* SqlDefine of ARTIKELQUOTAPF ************************************************/


#define ARTIKELQUOTAPF_UPDLISTE \
        "BRANCHNO=?,"\
        "CUSTOMERNO=?,"\
        "ARTICLENO=?,"\
        "QUOTA=?,"\
        "KUMQTY=?,"\
        "VALIDITY=?,"\
        "DATEUPDATE=?,"\
        "UID_ANLAGE=?,"\
        "SDAFUEQUOTA=?,"\
        "DATEFROM=?,"\
        "DATETO=?,"\
        "SNOBATCHCHANGE=?"
/* SqlDefine of ARTIKELRESERVE ************************************************/


#define ARTIKELRESERVE_UPDLISTE \
        "BRANCHNO=?,"\
        "PHARMACYGROUPID=?,"\
        "ARTICLENO=?,"\
        "RESERVTYPE=?,"\
        "MAXQTY=?,"\
        "RESERVEDQTY=?,"\
        "RESERVEPCT=?"
/* SqlDefine of ARTIKELTEXT ***************************************************/


#define ARTIKELTEXT_UPDLISTE \
        "BRANCHNO=?,"\
        "TEXTKEY=?,"\
        "TEXT=?,"\
        "DISPLAYONSCREEN=?,"\
        "TEXTHOSPITAL=?"
/* SqlDefine of ARTIKELVERFALL ************************************************/


#define ARTIKELVERFALL_UPDLISTE \
        "FILIALNR=?,"\
        "ARTIKEL_NR=?,"\
        "DATUMVERFALL=?"
/* SqlDefine of ATICLEAUX *****************************************************/


#define ATICLEAUX_UPDLISTE \
        "BRANCHNO=?,"\
        "ARTICLENO=?,"\
        "RANKING=?,"\
        "AUXBRANCHNO=?"
/* SqlDefine of CCODE *********************************************************/


#define CCODE_UPDLISTE \
        "BRANCHNO=?,"\
        "INFOCODE=?,"\
        "ARTICLEACTIV=?,"\
        "AUXDELIVERY=?,"\
        "SERACODE=?,"\
        "PRINTCODE=?,"\
        "XMLCODE=?,"\
        "XMLTEXT=?"
/* SqlDefine of CHECKIMEXBLOCKEXIST *******************************************/


#define CHECKIMEXBLOCKEXIST_UPDLISTE \
        "ARTICLENO=?"
/* SqlDefine of CHECKIMPORTARTICLE ********************************************/


#define CHECKIMPORTARTICLE_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "IMPORTARTICLE=?"
/* SqlDefine of CHECKLISTE5ZENTRAL ********************************************/


#define CHECKLISTE5ZENTRAL_UPDLISTE \
        "ARTIKEL_NR=?"
/* SqlDefine of CODEBLOCAGEINFO ***********************************************/


#define CODEBLOCAGEINFO_UPDLISTE \
        "PRINTCODE=?,"\
        "FILIALNR=?,"\
        "ARTIKEL_NR=?"
/* SqlDefine of DISPOINFO *****************************************************/


#define DISPOINFO_UPDLISTE \
        "BEZEICHNUNG=?,"\
        "DISPO_HINWEIS=?,"\
        "BEMERKUNG=?,"\
        "PZN=?,"\
        "ARTIKEL_NR=?,"\
        "HERSTELLER_NR=?"
/* SqlDefine of HERSTELLER ****************************************************/


#define HERSTELLER_UPDLISTE \
        "NAME=?,"\
        "ARTIKEL_NR=?"
/* SqlDefine of LPPRCODE ******************************************************/


#define LPPRCODE_UPDLISTE \
        "CODE_LPPR=?,"\
        "REIMBURSEMENT_VAL=?"
/* SqlDefine of MAXARTICLEQUOTA ***********************************************/


#define MAXARTICLEQUOTA_UPDLISTE \
        "ARTICLENO=?,"\
        "MAXQUOTA=?"
/* SqlDefine of OCCASION ******************************************************/


#define OCCASION_UPDLISTE \
        "CUSTOMERNO=?,"\
        "ARTICLENO=?,"\
        "BRANCHNO=?,"\
        "DISCOUNTVALUEPCT=?"
/* SqlDefine of PHARMGRP ******************************************************/


#define PHARMGRP_UPDLISTE \
        "PHARMACYGROUPID=?,"\
        "GROUP_NAME=?,"\
        "GROUP_TYPE=?,"\
        "PERCENT=?,"\
        "CONTRIBUTION=?,"\
        "CUSTOMERNO=?,"\
        "OMG_OWN_CONT=?,"\
        "PRICE_BASIS_PURCH=?,"\
        "RECLAIM_OMG_DISC=?,"\
        "SPECIALGROUP=?,"\
        "SPECIALGROUPREFNO=?,"\
        "GROUPING_VIS=?,"\
        "BRANCHNO=?"
/* SqlDefine of PREISANZTYP ***************************************************/


#define PREISANZTYP_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "PREISEKAPO=?,"\
        "PREISEKGROSSO=?,"\
        "PREISEKGROSSONA=?,"\
        "PREIS_TYP=?"
/* SqlDefine of PRICEHIST *****************************************************/


#define PRICEHIST_UPDLISTE \
        "ARTIKEL_NR=?,"\
        "DATUMGUELTIGAB=?,"\
        "GROSSO=?,"\
        "AEP=?,"\
        "AVP=?"
/* SqlDefine of PROMOANZ ******************************************************/


#define PROMOANZ_UPDLISTE \
        "PROMOTION_NO=?,"\
        "NAME=?,"\
        "DESCRIPTION=?,"\
        "PROMOTION_TYPE=?"
/* SqlDefine of REIMPORT ******************************************************/


#define REIMPORT_UPDLISTE \
        "DARREICHFORM=?,"\
        "PREISEKAPO=?,"\
        "EINHEIT=?,"\
        "ARTIKEL_NAME=?,"\
        "BESTAND=?,"\
        "PZN=?"
/* SqlDefine of STELLER *******************************************************/


#define STELLER_UPDLISTE \
        "ARTICLE_NO_PACK=?,"\
        "ARTICLE_NO_ELEMENT=?,"\
        "QUANTITY=?,"\
        "FILIALNR=?,"\
        "BESTAND=?,"\
        "DARREICHFORM=?,"\
        "EINHEIT=?,"\
        "ARTIKEL_NAME=?,"\
        "ARTIKEL_LANGNAME=?"
/* SqlDefine of STELLERTYP ****************************************************/


#define STELLERTYP_UPDLISTE \
        "ARTICLE_NO_PACK=?,"\
        "DATEFROM=?,"\
        "DATETO=?,"\
        "COMPACK_TYPE=?"

/* SqlDefine of SUPPLINFO *****************************************************/


#define SUPPLINFO_UPDLISTE \
        "ARTICLENO=?,"\
        "AVAILABILITYINFO=?"
/* SqlDefine of DELAYEDART ****************************************************/


#define DELAYEDART_UPDLISTE \
        "BRANCHNO=?,"\
        "NARCOTIC=?,"\
        "COLDCHAIN=?,"\
        "COOL08=?,"\
        "COOL20=?"
/* SqlDefine of DISCOUNTANZ ***************************************************/


#define DISCOUNTANZ_UPDLISTE \
        "BRANCHNO=?,"\
        "ARTICLENO=?,"\
        "DISCOUNTGRPNO=?,"\
        "PHARMACYGROUPID=?,"\
        "CUSTOMERNO=?,"\
        "GRPDISCOUNTTYP=?,"\
        "DATEFROM=?,"\
        "DATETO=?,"\
        "BASEQTY=?,"\
        "DISCOUNTSPEC=?,"\
        "DISCOUNTTYPE=?,"\
        "DISCOUNTQTY=?,"\
        "DISCOUNTVALUEPCT=?,"\
        "DISCOUNTQTYPCT=?,"\
        "SURCHARGEPCT=?,"\
        "PHARMGRPEXCLUDED=?,"\
        "FIXEDPRICE=?,"\
        "REFUNDPCT=?,"\
        "INTERNALDISCOUNT=?,"\
        "DISCOUNTARTICLE=?,"\
        "UPDATESIGN=?,"\
        "BASE_VALUE=?,"\
        "BASE_MULT_STD_QTY=?,"\
        "NO_MULTIPLE_QTY=?,"\
        "FIXEDDISCOUNTVALUE=?,"\
        "MANUFACTURERNO=?,"\
        "ARTCATEGORYNO=?,"\
        "PAYMENTTARGETNO=?,"\
        "GROSSPROFITPCT=?,"\
        "ADDONDISCOUNTOK=?,"\
        "PAYMENTTERMTYPE=?,"\
        "TARGETQTY=?,"\
        "EXCEEDANCEPCT=?,"\
        "ARTICLE_NO_PACK=?,"\
        "REFUNDVALUE=?,"\
        "PROMOTION_NO=?,"\
        "DISCOUNTAPPLYTO=?,"\
        "DISCOUNTCALCFROM=?"
/* SqlDefine of STOCKENTRY ****************************************************/


#define STOCKENTRY_UPDLISTE \
        "DATE=?,"\
        "BRANCHNO=?,"\
        "ARTICLENO=?,"\
        "BESTAND=?,"\
        "EINHEIT=?,"\
        "ARTIKEL_NAME=?"
/* SqlMacros-Define of ARTBUYINGOPTIONS ***************************************/

#define ARTBUYINGOPTIONS_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->ETARTKLASSE1,\
        :x->KZPSYCHOSTOFFE
#define ARTBUYINGOPTIONS_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->ETARTKLASSE1,\
        :x->KZPSYCHOSTOFFE

/* SqlMacros-Define of ARTCHARGE **********************************************/

#define ARTCHARGE_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->EXPIRYDATE,\
        :x->CHARGENNR,\
        :x->STOCK,\
        :x->STATECHARGE
#define ARTCHARGE_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->EXPIRYDATE,\
        :x->CHARGENNR,\
        :x->STOCK,\
        :x->STATECHARGE

/* SqlMacros-Define of ARTINFBG ***********************************************/

#define ARTINFBG_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->HEALTHFUNDCODE,\
        :x->ARTIKEL_LANGNAME
#define ARTINFBG_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->HEALTHFUNDCODE,\
        :x->ARTIKEL_LANGNAME

/* SqlMacros-Define of ARTINSERT **********************************************/

#define ARTINSERT_ZEIGER(x) \
        :x->ARTICLENO,\
        :x->ARTINFOTYPE,\
        :x->SEQUENCENO,\
        :x->INFOTEXT
#define ARTINSERT_ZEIGERSEL(x) \
        :x->ARTICLENO,\
        :x->ARTINFOTYPE,\
        :x->SEQUENCENO,\
        :x->INFOTEXT

/* SqlMacros-Define of ARTLANGNAME ********************************************/

#define ARTLANGNAME_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->ARTIKEL_LANGNAME
#define ARTLANGNAME_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->ARTIKEL_LANGNAME

/* SqlMacros-Define of ARTPRICE ***********************************************/

#define ARTPRICE_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->PREISEKAPO,\
        :x->PREISEKGROSSO,\
        :x->PREIS_TYP
#define ARTPRICE_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->PREISEKAPO,\
        :x->PREISEKGROSSO,\
        :x->PREIS_TYP

/* SqlMacros-Define of ARTPSYCHO **********************************************/

#define ARTPSYCHO_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->ETARTKLASSE1,\
        :x->KZPSYCHOSTOFFE
#define ARTPSYCHO_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->ETARTKLASSE1,\
        :x->KZPSYCHOSTOFFE

/* SqlMacros-Define of ARTICLEAGENTGROUP **************************************/

#define ARTICLEAGENTGROUP_ZEIGER(x) \
        :x->PREISEKAPO,\
        :x->FILIALNR,\
        :x->ARTIKEL_NR,\
        :x->BESTAND,\
        :x->DARREICHFORM,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME,\
        :x->WIRKSTOFF_NR,\
        :x->ARTIKEL_LANGNAME
#define ARTICLEAGENTGROUP_ZEIGERSEL(x) \
        :x->PREISEKAPO,\
        :x->FILIALNR,\
        :x->ARTIKEL_NR,\
        :x->BESTAND,\
        :x->DARREICHFORM,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME,\
        :x->WIRKSTOFF_NR,\
        :x->ARTIKEL_LANGNAME

/* SqlMacros-Define of ARTICLELPPRREIMB ***************************************/

#define ARTICLELPPRREIMB_ZEIGER(x) \
        :x->ARTICLENO,\
        :x->CODE_LPPR,\
        :x->DATEFROM,\
        :x->REIMBURSEMENT_VAL,\
        :x->LPPR_DESC,\
        :x->REIMBCALCFLAG
#define ARTICLELPPRREIMB_ZEIGERSEL(x) \
        :x->ARTICLENO,\
        :x->CODE_LPPR,\
        :x->DATEFROM,\
        :x->REIMBURSEMENT_VAL,\
        :x->LPPR_DESC,\
        :x->REIMBCALCFLAG

/* SqlMacros-Define of ARTICLEQUOTADETAIL *************************************/

#define ARTICLEQUOTADETAIL_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->VALIDITY
#define ARTICLEQUOTADETAIL_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->VALIDITY,\
        :x->KZKDKLASSE,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME

/* SqlMacros-Define of ARTICLEQUOTAEKG ****************************************/

#define ARTICLEQUOTAEKG_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->KUMQTY,\
        :x->VALIDITY,\
        :x->DATEUPDATE,\
        :x->UID_ANLAGE,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->PHARMACYGROUPID,\
        :x->SNOBATCHCHANGE
#define ARTICLEQUOTAEKG_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->GROUP_NAME,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->KUMQTY,\
        :x->VALIDITY,\
        :x->DATEUPDATE,\
        :x->UID_ANLAGE,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->PHARMACYGROUPID,\
        :x->SNOBATCHCHANGE,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME

/* SqlMacros-Define of ARTICLETAX *********************************************/

#define ARTICLETAX_ZEIGER(x) \
        :x->SALESTAXRATE,\
        :x->ARTIKEL_NR
#define ARTICLETAX_ZEIGERSEL(x) \
        :x->SALESTAXRATE,\
        :x->ARTIKEL_NR

/* SqlMacros-Define of ARTIKELLPPR ********************************************/

#define ARTIKELLPPR_ZEIGER(x) \
        :x->ARTICLENO,\
        :x->REIMBURSEMENT_TYPE,\
        :x->REIMBURSEMENTPRICE,\
        :x->CODE_LPPR,\
        :x->REIMBURSEMENT_PERC
#define ARTIKELLPPR_ZEIGERSEL(x) \
        :x->ARTICLENO,\
        :x->REIMBURSEMENT_TYPE,\
        :x->REIMBURSEMENTPRICE,\
        :x->CODE_LPPR,\
        :x->REIMBURSEMENT_PERC

/* SqlMacros-Define of ARTIKELQUOTA *******************************************/

#define ARTIKELQUOTA_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->VALIDITY,\
        :x->DATEUPDATE,\
        :x->UID_ANLAGE,\
        :x->SDAFUEQUOTA,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->PHARMACYGROUPID,\
        :x->SNOBATCHCHANGE
#define ARTIKELQUOTA_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->MATCHCODE,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->KUMQTY,\
        :x->VALIDITY,\
        :x->DATEUPDATE,\
        :x->UID_ANLAGE,\
        :x->SDAFUEQUOTA,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->PHARMACYGROUPID,\
        :x->SNOBATCHCHANGE,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME

/* SqlMacros-Define of ARTIKELQUOTAPF *****************************************/

#define ARTIKELQUOTAPF_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->KUMQTY,\
        :x->VALIDITY,\
        :x->DATEUPDATE,\
        :x->UID_ANLAGE,\
        :x->SDAFUEQUOTA,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->SNOBATCHCHANGE
#define ARTIKELQUOTAPF_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUOTA,\
        :x->KUMQTY,\
        :x->VALIDITY,\
        :x->DATEUPDATE,\
        :x->UID_ANLAGE,\
        :x->SDAFUEQUOTA,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->SNOBATCHCHANGE

/* SqlMacros-Define of ARTIKELRESERVE *****************************************/

#define ARTIKELRESERVE_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->PHARMACYGROUPID,\
        :x->ARTICLENO,\
        :x->RESERVTYPE,\
        :x->MAXQTY,\
        :x->RESERVEDQTY,\
        :x->RESERVEPCT
#define ARTIKELRESERVE_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->PHARMACYGROUPID,\
        :x->ARTICLENO,\
        :x->RESERVTYPE,\
        :x->MAXQTY,\
        :x->RESERVEDQTY,\
        :x->RESERVEPCT

/* SqlMacros-Define of ARTIKELTEXT ********************************************/

#define ARTIKELTEXT_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->TEXTKEY,\
        :x->TEXT,\
        :x->DISPLAYONSCREEN,\
        :x->TEXTHOSPITAL
#define ARTIKELTEXT_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->TEXTKEY,\
        :x->TEXT,\
        :x->DISPLAYONSCREEN,\
        :x->TEXTHOSPITAL

/* SqlMacros-Define of ARTIKELVERFALL *****************************************/

#define ARTIKELVERFALL_ZEIGER(x) \
        :x->FILIALNR,\
        :x->ARTIKEL_NR,\
        :x->DATUMVERFALL
#define ARTIKELVERFALL_ZEIGERSEL(x) \
        :x->FILIALNR,\
        :x->ARTIKEL_NR,\
        :x->DATUMVERFALL

/* SqlMacros-Define of ATICLEAUX **********************************************/

#define ATICLEAUX_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->RANKING,\
        :x->AUXBRANCHNO
#define ATICLEAUX_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->RANKING,\
        :x->AUXBRANCHNO

/* SqlMacros-Define of CCODE **************************************************/

#define CCODE_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->INFOCODE,\
        :x->ARTICLEACTIV,\
        :x->AUXDELIVERY,\
        :x->SERACODE,\
        :x->PRINTCODE,\
        :x->XMLCODE,\
        :x->XMLTEXT
#define CCODE_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->INFOCODE,\
        :x->ARTICLEACTIV,\
        :x->AUXDELIVERY,\
        :x->SERACODE,\
        :x->PRINTCODE,\
        :x->XMLCODE,\
        :x->XMLTEXT

/* SqlMacros-Define of CHECKIMEXBLOCKEXIST ************************************/

#define CHECKIMEXBLOCKEXIST_ZEIGER(x) \
        :x->ARTICLENO
#define CHECKIMEXBLOCKEXIST_ZEIGERSEL(x) \
        :x->ARTICLENO

/* SqlMacros-Define of CHECKIMPORTARTICLE *************************************/

#define CHECKIMPORTARTICLE_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->IMPORTARTICLE
#define CHECKIMPORTARTICLE_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->IMPORTARTICLE

/* SqlMacros-Define of CHECKLISTE5ZENTRAL *************************************/

#define CHECKLISTE5ZENTRAL_ZEIGER(x) \
        :x->ARTIKEL_NR
#define CHECKLISTE5ZENTRAL_ZEIGERSEL(x) \
        :x->ARTIKEL_NR

/* SqlMacros-Define of CODEBLOCAGEINFO ****************************************/

#define CODEBLOCAGEINFO_ZEIGER(x) \
        :x->PRINTCODE,\
        :x->FILIALNR,\
        :x->ARTIKEL_NR
#define CODEBLOCAGEINFO_ZEIGERSEL(x) \
        :x->PRINTCODE,\
        :x->FILIALNR,\
        :x->ARTIKEL_NR

/* SqlMacros-Define of DISPOINFO **********************************************/

#define DISPOINFO_ZEIGER(x) \
        :x->BEZEICHNUNG,\
        :x->DISPO_HINWEIS,\
        :x->BEMERKUNG,\
        :x->PZN,\
        :x->ARTIKEL_NR,\
        :x->HERSTELLER_NR
#define DISPOINFO_ZEIGERSEL(x) \
        :x->BEZEICHNUNG,\
        :x->DISPO_HINWEIS,\
        :x->BEMERKUNG,\
        :x->PZN,\
        :x->ARTIKEL_NR,\
        :x->HERSTELLER_NR

/* SqlMacros-Define of HERSTELLER *********************************************/

#define HERSTELLER_ZEIGER(x) \
        :x->NAME,\
        :x->ARTIKEL_NR
#define HERSTELLER_ZEIGERSEL(x) \
        :x->NAME,\
        :x->ARTIKEL_NR

/* SqlMacros-Define of LPPRCODE ***********************************************/

#define LPPRCODE_ZEIGER(x) \
        :x->CODE_LPPR,\
        :x->REIMBURSEMENT_VAL
#define LPPRCODE_ZEIGERSEL(x) \
        :x->CODE_LPPR,\
        :x->REIMBURSEMENT_VAL

/* SqlMacros-Define of MAXARTICLEQUOTA ****************************************/

#define MAXARTICLEQUOTA_ZEIGER(x) \
        :x->ARTICLENO,\
        :x->MAXQUOTA
#define MAXARTICLEQUOTA_ZEIGERSEL(x) \
        :x->ARTICLENO,\
        :x->MAXQUOTA

/* SqlMacros-Define of OCCASION ***********************************************/

#define OCCASION_ZEIGER(x) \
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->BRANCHNO,\
        :x->DISCOUNTVALUEPCT
#define OCCASION_ZEIGERSEL(x) \
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->BRANCHNO,\
        :x->DISCOUNTVALUEPCT

/* SqlMacros-Define of PHARMGRP ***********************************************/

#define PHARMGRP_ZEIGER(x) \
        :x->PHARMACYGROUPID,\
        :x->GROUP_NAME,\
        :x->GROUP_TYPE,\
        :x->PERCENT,\
        :x->CONTRIBUTION,\
        :x->CUSTOMERNO,\
        :x->OMG_OWN_CONT,\
        :x->PRICE_BASIS_PURCH,\
        :x->RECLAIM_OMG_DISC,\
        :x->SPECIALGROUP,\
        :x->SPECIALGROUPREFNO,\
        :x->GROUPING_VIS,\
        :x->BRANCHNO
#define PHARMGRP_ZEIGERSEL(x) \
        :x->PHARMACYGROUPID,\
        :x->GROUP_NAME,\
        :x->GROUP_TYPE,\
        :x->PERCENT,\
        :x->CONTRIBUTION,\
        :x->CUSTOMERNO,\
        :x->OMG_OWN_CONT,\
        :x->PRICE_BASIS_PURCH,\
        :x->RECLAIM_OMG_DISC,\
        :x->SPECIALGROUP,\
        :x->SPECIALGROUPREFNO,\
        :x->GROUPING_VIS,\
        :x->BRANCHNO

/* SqlMacros-Define of PREISANZTYP ********************************************/

#define PREISANZTYP_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->PREISEKAPO,\
        :x->PREISEKGROSSO,\
        :x->PREISEKGROSSONA,\
        :x->PREIS_TYP
#define PREISANZTYP_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->PREISEKAPO,\
        :x->PREISEKGROSSO,\
        :x->PREISEKGROSSONA,\
        :x->PREIS_TYP

/* SqlMacros-Define of PRICEHIST **********************************************/

#define PRICEHIST_ZEIGER(x) \
        :x->ARTIKEL_NR,\
        :x->DATUMGUELTIGAB,\
        :x->GROSSO,\
        :x->AEP,\
        :x->AVP
#define PRICEHIST_ZEIGERSEL(x) \
        :x->ARTIKEL_NR,\
        :x->DATUMGUELTIGAB,\
        :x->GROSSO,\
        :x->AEP,\
        :x->AVP

/* SqlMacros-Define of PROMOANZ ***********************************************/

#define PROMOANZ_ZEIGER(x) \
        :x->PROMOTION_NO,\
        :x->NAME,\
        :x->DESCRIPTION,\
        :x->PROMOTION_TYPE
#define PROMOANZ_ZEIGERSEL(x) \
        :x->PROMOTION_NO,\
        :x->NAME,\
        :x->DESCRIPTION,\
        :x->PROMOTION_TYPE

/* SqlMacros-Define of REIMPORT ***********************************************/

#define REIMPORT_ZEIGER(x) \
        :x->DARREICHFORM,\
        :x->PREISEKAPO,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME,\
        :x->BESTAND,\
        :x->PZN
#define REIMPORT_ZEIGERSEL(x) \
        :x->DARREICHFORM,\
        :x->PREISEKAPO,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME,\
        :x->BESTAND,\
        :x->PZN

/* SqlMacros-Define of STELLER ************************************************/

#define STELLER_ZEIGER(x) \
        :x->ARTICLE_NO_PACK,\
        :x->ARTICLE_NO_ELEMENT,\
        :x->QUANTITY,\
        :x->FILIALNR,\
        :x->BESTAND,\
        :x->DARREICHFORM,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME,\
        :x->ARTIKEL_LANGNAME
#define STELLER_ZEIGERSEL(x) \
        :x->ARTICLE_NO_PACK,\
        :x->ARTICLE_NO_ELEMENT,\
        :x->QUANTITY,\
        :x->FILIALNR,\
        :x->BESTAND,\
        :x->DARREICHFORM,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME,\
        :x->ARTIKEL_LANGNAME

/* SqlMacros-Define of STELLERTYP *********************************************/

#define STELLERTYP_ZEIGER(x) \
        :x->ARTICLE_NO_PACK,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->COMPACK_TYPE
#define STELLERTYP_ZEIGERSEL(x) \
        :x->ARTICLE_NO_PACK,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->COMPACK_TYPE

/* SqlMacros-Define of STOCKRESERVATION ***************************************/

#define STOCKRESERVATION_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLE_CODE,\
        :x->ARTICLENO,\
        :x->RESERVEDQTY,\
        :x->DATEFROM,\
        :x->TIMEFROM,\
        :x->DATETO,\
        :x->TIMETO,\
        :x->KDAUFTRAGNR,\
        :x->RESERVTYPE
#define STOCKRESERVATION_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->CUSTOMERNO,\
        :x->ARTICLE_CODE,\
        :x->ARTICLENO,\
        :x->RESERVEDQTY,\
        :x->DATEFROM,\
        :x->TIMEFROM,\
        :x->DATETO,\
        :x->TIMETO,\
        :x->KDAUFTRAGNR,\
        :x->RESERVTYPE
#define STOCKRESERVATION_UPDATE(x) \
        CSTSTOCKRESERVED.BRANCHNO=:x->BRANCHNO,\
        CSTSTOCKRESERVED.CUSTOMERNO=:x->CUSTOMERNO,\
        ARTICLECODES.ARTICLE_CODE=:x->ARTICLE_CODE,\
        CSTSTOCKRESERVED.ARTICLENO=:x->ARTICLENO,\
        CSTSTOCKRESERVED.RESERVEDQTY=:x->RESERVEDQTY,\
        CSTSTOCKRESERVED.DATEFROM=:x->DATEFROM,\
        CSTSTOCKRESERVED.TIMEFROM=:x->TIMEFROM,\
        CSTSTOCKRESERVED.DATETO=:x->DATETO,\
        CSTSTOCKRESERVED.TIMETO=:x->TIMETO,\
        CSTSTOCKRESERVED.KDAUFTRAGNR=:x->KDAUFTRAGNR,\
        CSTSTOCKRESERVED.RESERVTYPE=:x->RESERVTYPE
/* SqlMacros-Define of STOCKRESERVATIONARTICLERESERV **************************/

#define STOCKRESERVATIONARTICLERESERV_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->PHARMACYGROUPID,\
        :x->ARTICLENO,\
        :x->RESERVTYPE,\
        :x->MAXQTY,\
        :x->RESERVEDQTY
#define STOCKRESERVATIONARTICLERESERV_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->PHARMACYGROUPID,\
        :x->ARTICLENO,\
        :x->RESERVTYPE,\
        :x->MAXQTY,\
        :x->RESERVEDQTY
#define STOCKRESERVATIONARTICLERESERV_UPDATE(x) \
        ARTICLERESERVATION.BRANCHNO=:x->BRANCHNO,\
        ARTICLERESERVATION.PHARMACYGROUPID=:x->PHARMACYGROUPID,\
        ARTICLERESERVATION.ARTICLENO=:x->ARTICLENO,\
        ARTICLERESERVATION.RESERVTYPE=:x->RESERVTYPE,\
        ARTICLERESERVATION.MAXQTY=:x->MAXQTY,\
        ARTICLERESERVATION.RESERVEDQTY=:x->RESERVEDQTY
/* SqlMacros-Define of STOCKRESERVATIONARTIKELLOKAL ***************************/

#define STOCKRESERVATIONARTIKELLOKAL_ZEIGER(x) \
        :x->FILIALNR,\
        :x->ARTIKEL_NR,\
        :x->BESTAND,\
        :x->LAGERBEREICHNR,\
        :x->STATIONNR,\
        :x->LAGERFACHNR
#define STOCKRESERVATIONARTIKELLOKAL_ZEIGERSEL(x) \
        :x->FILIALNR,\
        :x->ARTIKEL_NR,\
        :x->BESTAND,\
        :x->LAGERBEREICHNR,\
        :x->STATIONNR,\
        :x->LAGERFACHNR
#define STOCKRESERVATIONARTIKELLOKAL_UPDATE(x) \
        ARTIKELLOKAL.FILIALNR=:x->FILIALNR,\
        ARTIKELLOKAL.ARTIKEL_NR=:x->ARTIKEL_NR,\
        ARTIKELLOKAL.BESTAND=:x->BESTAND,\
        ARTIKELLOKAL.LAGERBEREICHNR=:x->LAGERBEREICHNR,\
        ARTIKELLOKAL.STATIONNR=:x->STATIONNR,\
        ARTIKELLOKAL.LAGERFACHNR=:x->LAGERFACHNR

/* SqlMacros-Define of STOCKRESERVATIONIBTREQUEST *****************************/

#define STOCKRESERVATIONIBTREQUEST_ZEIGER(x) \
        :x->IBTREQUESTID,\
        :x->BRANCHNO,\
        :x->CSCORDERNO,\
        :x->CSCORDERPOSNO,\
        :x->DATEFROM,\
        :x->IBTBRANCHNO,\
        :x->IBTCUSTOMERNO,\
        :x->TIMEFROM,\
        :x->PROCESSINGSTATE,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUANTITY
#define STOCKRESERVATIONIBTREQUEST_ZEIGERSEL(x) \
        :x->IBTREQUESTID,\
        :x->BRANCHNO,\
        :x->CSCORDERNO,\
        :x->CSCORDERPOSNO,\
        :x->DATEFROM,\
        :x->IBTBRANCHNO,\
        :x->IBTCUSTOMERNO,\
        :x->TIMEFROM,\
        :x->PROCESSINGSTATE,\
        :x->CUSTOMERNO,\
        :x->ARTICLENO,\
        :x->QUANTITY
#define STOCKRESERVATIONIBTREQUEST_UPDATE(x) \
        IBTREQUEST.IBTREQUESTID=:x->IBTREQUESTID,\
        IBTREQUEST.BRANCHNO=:x->BRANCHNO,\
        IBTREQUEST.CSCORDERNO=:x->CSCORDERNO,\
        IBTREQUEST.CSCORDERPOSNO=:x->CSCORDERPOSNO,\
        CSTSTOCKRESERVED.DATEFROM=:x->DATEFROM,\
        IBTREQUEST.IBTBRANCHNO=:x->IBTBRANCHNO,\
        IBTREQUEST.IBTCUSTOMERNO=:x->IBTCUSTOMERNO,\
        CSTSTOCKRESERVED.TIMEFROM=:x->TIMEFROM,\
        IBTREQUEST.PROCESSINGSTATE=:x->PROCESSINGSTATE,\
        IBTREQUEST.CUSTOMERNO=:x->CUSTOMERNO,\
        IBTREQUEST.ARTICLENO=:x->ARTICLENO,\
        IBTREQUEST.QUANTITY=:x->QUANTITY

/* SqlMacros-Define of STOCKRESERVATIONNACHLIEFERPOS **************************/

#define STOCKRESERVATIONNACHLIEFERPOS_ZEIGER(x) \
        :x->KDAUFTRAGNR,\
        :x->POSNR,\
        :x->DATUM,\
        :x->POSTYP,\
        :x->IDFNR,\
        :x->ARTIKEL_NR,\
        :x->MENGE,\
        :x->STATUS
#define STOCKRESERVATIONNACHLIEFERPOS_ZEIGERSEL(x) \
        :x->KDAUFTRAGNR,\
        :x->POSNR,\
        :x->DATUM,\
        :x->POSTYP,\
        :x->IDFNR,\
        :x->ARTIKEL_NR,\
        :x->MENGE,\
        :x->STATUS
#define STOCKRESERVATIONNACHLIEFERPOS_UPDATE(x) \
        NACHLIEFERPOS.KDAUFTRAGNR=:x->KDAUFTRAGNR,\
        NACHLIEFERPOS.POSNR=:x->POSNR,\
        NACHLIEFERPOS.DATUM=:x->DATUM,\
        NACHLIEFERPOS.POSTYP=:x->POSTYP,\
        NACHLIEFERPOS.IDFNR=:x->IDFNR,\
        NACHLIEFERPOS.ARTIKEL_NR=:x->ARTIKEL_NR,\
        NACHLIEFERPOS.MENGE=:x->MENGE,\
        NACHLIEFERPOS.STATUS=:x->STATUS

/* SqlMacros-Define of STOCKRESERVATIONORDER **********************************/

#define STOCKRESERVATIONORDER_ZEIGER(x) \
        :x->DATUM,\
        :x->KDAUFTRAGNR,\
        :x->KDAUFTRAGSTAT,\
        :x->IDFNR,\
        :x->FILIALNR,\
        :x->KDAUFTRAGART,\
        :x->KUNDENNR,\
        :x->ZUGRUND
#define STOCKRESERVATIONORDER_ZEIGERSEL(x) \
        :x->DATUM,\
        :x->KDAUFTRAGNR,\
        :x->KDAUFTRAGSTAT,\
        :x->IDFNR,\
        :x->FILIALNR,\
        :x->KDAUFTRAGART,\
        :x->KUNDENNR,\
        :x->ZUGRUND
#define STOCKRESERVATIONORDER_UPDATE(x) \
        AKDAUFTRAG.DATUM=:x->DATUM,\
        KDAUFTRAG.KDAUFTRAGNR=:x->KDAUFTRAGNR,\
        KDAUFTRAG.KDAUFTRAGSTAT=:x->KDAUFTRAGSTAT,\
        KDAUFTRAG.IDFNR=:x->IDFNR,\
        KDAUFTRAG.FILIALNR=:x->FILIALNR,\
        KDAUFTRAG.KDAUFTRAGART=:x->KDAUFTRAGART,\
        KDAUFTRAG.KUNDENNR=:x->KUNDENNR,\
        KDAUFTRAG.ZUGRUND=:x->ZUGRUND


/* SqlMacros-Define of SUPPLINFO **********************************************/

#define SUPPLINFO_ZEIGER(x) \
        :x->ARTICLENO,\
        :x->AVAILABILITYINFO
#define SUPPLINFO_ZEIGERSEL(x) \
        :x->ARTICLENO,\
        :x->AVAILABILITYINFO

/* SqlMacros-Define of DELAYEDART *********************************************/

#define DELAYEDART_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->NARCOTIC,\
        :x->COLDCHAIN,\
        :x->COOL08,\
        :x->COOL20
#define DELAYEDART_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->NARCOTIC,\
        :x->COLDCHAIN,\
        :x->COOL08,\
        :x->COOL20

/* SqlMacros-Define of DISCOUNTANZ ********************************************/

#define DISCOUNTANZ_ZEIGER(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->DISCOUNTGRPNO,\
        :x->PHARMACYGROUPID,\
        :x->CUSTOMERNO,\
        :x->GRPDISCOUNTTYP,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->BASEQTY,\
        :x->DISCOUNTSPEC,\
        :x->DISCOUNTTYPE,\
        :x->DISCOUNTQTY,\
        :x->DISCOUNTVALUEPCT,\
        :x->DISCOUNTQTYPCT,\
        :x->SURCHARGEPCT,\
        :x->PHARMGRPEXCLUDED,\
        :x->FIXEDPRICE,\
        :x->REFUNDPCT,\
        :x->INTERNALDISCOUNT,\
        :x->DISCOUNTARTICLE,\
        :x->UPDATESIGN,\
        :x->BASE_VALUE,\
        :x->BASE_MULT_STD_QTY,\
        :x->NO_MULTIPLE_QTY,\
        :x->FIXEDDISCOUNTVALUE,\
        :x->MANUFACTURERNO,\
        :x->ARTCATEGORYNO,\
        :x->PAYMENTTARGETNO,\
        :x->GROSSPROFITPCT,\
        :x->ADDONDISCOUNTOK,\
        :x->PAYMENTTERMTYPE,\
        :x->TARGETQTY,\
        :x->EXCEEDANCEPCT,\
        :x->ARTICLE_NO_PACK,\
        :x->REFUNDVALUE,\
        :x->PROMOTION_NO,\
        :x->DISCOUNTAPPLYTO,\
        :x->DISCOUNTCALCFROM
#define DISCOUNTANZ_ZEIGERSEL(x) \
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->DISCOUNTGRPNO,\
        :x->PHARMACYGROUPID,\
        :x->CUSTOMERNO,\
        :x->GRPDISCOUNTTYP,\
        :x->DATEFROM,\
        :x->DATETO,\
        :x->BASEQTY,\
        :x->DISCOUNTSPEC,\
        :x->DISCOUNTTYPE,\
        :x->DISCOUNTQTY,\
        :x->DISCOUNTVALUEPCT,\
        :x->DISCOUNTQTYPCT,\
        :x->SURCHARGEPCT,\
        :x->PHARMGRPEXCLUDED,\
        :x->FIXEDPRICE,\
        :x->REFUNDPCT,\
        :x->INTERNALDISCOUNT,\
        :x->DISCOUNTARTICLE,\
        :x->UPDATESIGN,\
        :x->BASE_VALUE,\
        :x->BASE_MULT_STD_QTY,\
        :x->NO_MULTIPLE_QTY,\
        :x->FIXEDDISCOUNTVALUE,\
        :x->MANUFACTURERNO,\
        :x->ARTCATEGORYNO,\
        :x->PAYMENTTARGETNO,\
        :x->GROSSPROFITPCT,\
        :x->ADDONDISCOUNTOK,\
        :x->PAYMENTTERMTYPE,\
        :x->TARGETQTY,\
        :x->EXCEEDANCEPCT,\
        :x->ARTICLE_NO_PACK,\
        :x->REFUNDVALUE,\
        :x->PROMOTION_NO,\
        :x->DISCOUNTAPPLYTO,\
        :x->DISCOUNTCALCFROM

/* SqlMacros-Define of STOCKENTRY *********************************************/

#define STOCKENTRY_ZEIGER(x) \
        :x->DATE,\
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->BESTAND,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME
#define STOCKENTRY_ZEIGERSEL(x) \
        :x->DATE,\
        :x->BRANCHNO,\
        :x->ARTICLENO,\
        :x->BESTAND,\
        :x->EINHEIT,\
        :x->ARTIKEL_NAME

/* define of Buf_Desc *********************************************************/

#if defined (BUF_DESC) || defined (C_BUF_DESC)
#define ARTBUYINGOPTIONS_H
#define ARTBUYINGOPTIONS_ANZ ( sizeof(ARTBUYINGOPTIONS_BES) / sizeof(struct buf_desc) )
#define ARTCHARGE_H
#define ARTCHARGE_ANZ ( sizeof(ARTCHARGE_BES) / sizeof(struct buf_desc) )
#define ARTINFBG_H
#define ARTINFBG_ANZ ( sizeof(ARTINFBG_BES) / sizeof(struct buf_desc) )
#define ARTINSERT_H
#define ARTINSERT_ANZ ( sizeof(ARTINSERT_BES) / sizeof(struct buf_desc) )
#define ARTLANGNAME_H
#define ARTLANGNAME_ANZ ( sizeof(ARTLANGNAME_BES) / sizeof(struct buf_desc) )
#define ARTPRICE_H
#define ARTPRICE_ANZ ( sizeof(ARTPRICE_BES) / sizeof(struct buf_desc) )
#define ARTPSYCHO_H
#define ARTPSYCHO_ANZ ( sizeof(ARTPSYCHO_BES) / sizeof(struct buf_desc) )
#define ARTICLEAGENTGROUP_H
#define ARTICLEAGENTGROUP_ANZ ( sizeof(ARTICLEAGENTGROUP_BES) / sizeof(struct buf_desc) )
#define ARTICLELPPRREIMB_H
#define ARTICLELPPRREIMB_ANZ ( sizeof(ARTICLELPPRREIMB_BES) / sizeof(struct buf_desc) )
#define ARTICLEQUOTADETAIL_H
#define ARTICLEQUOTADETAIL_ANZ ( sizeof(ARTICLEQUOTADETAIL_BES) / sizeof(struct buf_desc) )
#define ARTICLEQUOTAEKG_H
#define ARTICLEQUOTAEKG_ANZ ( sizeof(ARTICLEQUOTAEKG_BES) / sizeof(struct buf_desc) )
#define ARTICLETAX_H
#define ARTICLETAX_ANZ ( sizeof(ARTICLETAX_BES) / sizeof(struct buf_desc) )
#define ARTIKELLPPR_H
#define ARTIKELLPPR_ANZ ( sizeof(ARTIKELLPPR_BES) / sizeof(struct buf_desc) )
#define ARTIKELQUOTA_H
#define ARTIKELQUOTA_ANZ ( sizeof(ARTIKELQUOTA_BES) / sizeof(struct buf_desc) )
#define ARTIKELQUOTAPF_H
#define ARTIKELQUOTAPF_ANZ ( sizeof(ARTIKELQUOTAPF_BES) / sizeof(struct buf_desc) )
#define ARTIKELRESERVE_H
#define ARTIKELRESERVE_ANZ ( sizeof(ARTIKELRESERVE_BES) / sizeof(struct buf_desc) )
#define ARTIKELTEXT_H
#define ARTIKELTEXT_ANZ ( sizeof(ARTIKELTEXT_BES) / sizeof(struct buf_desc) )
#define ARTIKELVERFALL_H
#define ARTIKELVERFALL_ANZ ( sizeof(ARTIKELVERFALL_BES) / sizeof(struct buf_desc) )
#define ATICLEAUX_H
#define ATICLEAUX_ANZ ( sizeof(ATICLEAUX_BES) / sizeof(struct buf_desc) )
#define CCODE_H
#define CCODE_ANZ ( sizeof(CCODE_BES) / sizeof(struct buf_desc) )
#define CHECKIMEXBLOCKEXIST_H
#define CHECKIMEXBLOCKEXIST_ANZ ( sizeof(CHECKIMEXBLOCKEXIST_BES) / sizeof(struct buf_desc) )
#define CHECKIMPORTARTICLE_H
#define CHECKIMPORTARTICLE_ANZ ( sizeof(CHECKIMPORTARTICLE_BES) / sizeof(struct buf_desc) )
#define CHECKLISTE5ZENTRAL_H
#define CHECKLISTE5ZENTRAL_ANZ ( sizeof(CHECKLISTE5ZENTRAL_BES) / sizeof(struct buf_desc) )
#define CODEBLOCAGEINFO_H
#define CODEBLOCAGEINFO_ANZ ( sizeof(CODEBLOCAGEINFO_BES) / sizeof(struct buf_desc) )
#define DISPOINFO_H
#define DISPOINFO_ANZ ( sizeof(DISPOINFO_BES) / sizeof(struct buf_desc) )
#define HERSTELLER_H
#define HERSTELLER_ANZ ( sizeof(HERSTELLER_BES) / sizeof(struct buf_desc) )
#define LPPRCODE_H
#define LPPRCODE_ANZ ( sizeof(LPPRCODE_BES) / sizeof(struct buf_desc) )
#define MAXARTICLEQUOTA_H
#define MAXARTICLEQUOTA_ANZ ( sizeof(MAXARTICLEQUOTA_BES) / sizeof(struct buf_desc) )
#define OCCASION_H
#define OCCASION_ANZ ( sizeof(OCCASION_BES) / sizeof(struct buf_desc) )
#define PHARMGRP_H
#define PHARMGRP_ANZ ( sizeof(PHARMGRP_BES) / sizeof(struct buf_desc) )
#define PREISANZTYP_H
#define PREISANZTYP_ANZ ( sizeof(PREISANZTYP_BES) / sizeof(struct buf_desc) )
#define PRICEHIST_H
#define PRICEHIST_ANZ ( sizeof(PRICEHIST_BES) / sizeof(struct buf_desc) )
#define PROMOANZ_H
#define PROMOANZ_ANZ ( sizeof(PROMOANZ_BES) / sizeof(struct buf_desc) )
#define REIMPORT_H
#define REIMPORT_ANZ ( sizeof(REIMPORT_BES) / sizeof(struct buf_desc) )
#define STELLER_H
#define STELLER_ANZ ( sizeof(STELLER_BES) / sizeof(struct buf_desc) )
#define STELLERTYP_H
#define STELLERTYP_ANZ ( sizeof(STELLERTYP_BES) / sizeof(struct buf_desc) )
#define STOCKRESERVATION_H
#define STOCKRESERVATION_ANZ ( sizeof(STOCKRESERVATION_BES) / sizeof(struct buf_desc) )
#define SUPPLINFO_H
#define SUPPLINFO_ANZ ( sizeof(SUPPLINFO_BES) / sizeof(struct buf_desc) )
#define DELAYEDART_H
#define DELAYEDART_ANZ ( sizeof(DELAYEDART_BES) / sizeof(struct buf_desc) )
#define DISCOUNTANZ_H
#define DISCOUNTANZ_ANZ ( sizeof(DISCOUNTANZ_BES) / sizeof(struct buf_desc) )
#define STOCKENTRY_H
#define STOCKENTRY_ANZ ( sizeof(STOCKENTRY_BES) / sizeof(struct buf_desc) )
#endif

/* SqlMacros390-Define of STOCKRESERVATION ************************************/

#define STOCKRESERVATION_ZEIGER_390 \
        :BRANCHNO,\
        :CUSTOMERNO,\
        :ARTICLE_CODE,\
        :ARTICLENO,\
        :RESERVEDQTY,\
        :DATEFROM,\
        :TIMEFROM,\
        :DATETO,\
        :TIMETO,\
        :KDAUFTRAGNR,\
        :RESERVTYPE
#define STOCKRESERVATION_UPDATE_390 \
        BRANCHNO=:BRANCHNO,\
        CUSTOMERNO=:CUSTOMERNO,\
        ARTICLE_CODE=:ARTICLE_CODE,\
        ARTICLENO=:ARTICLENO,\
        RESERVEDQTY=:RESERVEDQTY,\
        DATEFROM=:DATEFROM,\
        TIMEFROM=:TIMEFROM,\
        DATETO=:DATETO,\
        TIMETO=:TIMETO,\
        KDAUFTRAGNR=:KDAUFTRAGNR,\
        RESERVTYPE=:RESERVTYPE
/* SqlMacros390-Define of STOCKRESERVATIONARTICLERESERV ***********************/

#define STOCKRESERVATIONARTICLERESERV_ZEIGER_390 \
        :BRANCHNO,\
        :PHARMACYGROUPID,\
        :ARTICLENO,\
        :RESERVTYPE,\
        :MAXQTY,\
        :RESERVEDQTY
#define STOCKRESERVATIONARTICLERESERV_UPDATE_390 \
        BRANCHNO=:BRANCHNO,\
        PHARMACYGROUPID=:PHARMACYGROUPID,\
        ARTICLENO=:ARTICLENO,\
        RESERVTYPE=:RESERVTYPE,\
        MAXQTY=:MAXQTY,\
        RESERVEDQTY=:RESERVEDQTY
/* SqlMacros390-Define of STOCKRESERVATIONARTIKELLOKAL ************************/

#define STOCKRESERVATIONARTIKELLOKAL_ZEIGER_390 \
        :FILIALNR,\
        :ARTIKEL_NR,\
        :BESTAND,\
        :LAGERBEREICHNR,\
        :STATIONNR,\
        :LAGERFACHNR
#define STOCKRESERVATIONARTIKELLOKAL_UPDATE_390 \
        FILIALNR=:FILIALNR,\
        ARTIKEL_NR=:ARTIKEL_NR,\
        BESTAND=:BESTAND,\
        LAGERBEREICHNR=:LAGERBEREICHNR,\
        STATIONNR=:STATIONNR,\
        LAGERFACHNR=:LAGERFACHNR

/* SqlMacros390-Define of STOCKRESERVATIONIBTREQUEST **************************/

#define STOCKRESERVATIONIBTREQUEST_ZEIGER_390 \
        :IBTREQUESTID,\
        :BRANCHNO,\
        :CSCORDERNO,\
        :CSCORDERPOSNO,\
        :DATEFROM,\
        :IBTBRANCHNO,\
        :IBTCUSTOMERNO,\
        :TIMEFROM,\
        :PROCESSINGSTATE,\
        :CUSTOMERNO,\
        :ARTICLENO,\
        :QUANTITY
#define STOCKRESERVATIONIBTREQUEST_UPDATE_390 \
        IBTREQUESTID=:IBTREQUESTID,\
        BRANCHNO=:BRANCHNO,\
        CSCORDERNO=:CSCORDERNO,\
        CSCORDERPOSNO=:CSCORDERPOSNO,\
        DATEFROM=:DATEFROM,\
        IBTBRANCHNO=:IBTBRANCHNO,\
        IBTCUSTOMERNO=:IBTCUSTOMERNO,\
        TIMEFROM=:TIMEFROM,\
        PROCESSINGSTATE=:PROCESSINGSTATE,\
        CUSTOMERNO=:CUSTOMERNO,\
        ARTICLENO=:ARTICLENO,\
        QUANTITY=:QUANTITY

/* SqlMacros390-Define of STOCKRESERVATIONNACHLIEFERPOS ***********************/

#define STOCKRESERVATIONNACHLIEFERPOS_ZEIGER_390 \
        :KDAUFTRAGNR,\
        :POSNR,\
        :DATUM,\
        :POSTYP,\
        :IDFNR,\
        :ARTIKEL_NR,\
        :MENGE,\
        :STATUS
#define STOCKRESERVATIONNACHLIEFERPOS_UPDATE_390 \
        KDAUFTRAGNR=:KDAUFTRAGNR,\
        POSNR=:POSNR,\
        DATUM=:DATUM,\
        POSTYP=:POSTYP,\
        IDFNR=:IDFNR,\
        ARTIKEL_NR=:ARTIKEL_NR,\
        MENGE=:MENGE,\
        STATUS=:STATUS

/* SqlMacros390-Define of STOCKRESERVATIONORDER *******************************/

#define STOCKRESERVATIONORDER_ZEIGER_390 \
        :DATUM,\
        :KDAUFTRAGNR,\
        :KDAUFTRAGSTAT,\
        :IDFNR,\
        :FILIALNR,\
        :KDAUFTRAGART,\
        :KUNDENNR,\
        :ZUGRUND
#define STOCKRESERVATIONORDER_UPDATE_390 \
        DATUM=:DATUM,\
        KDAUFTRAGNR=:KDAUFTRAGNR,\
        KDAUFTRAGSTAT=:KDAUFTRAGSTAT,\
        IDFNR=:IDFNR,\
        FILIALNR=:FILIALNR,\
        KDAUFTRAGART=:KDAUFTRAGART,\
        KUNDENNR=:KUNDENNR,\
        ZUGRUND=:ZUGRUND

#ifdef TRANSCLASS
#include <string.h>
#endif

#ifdef ESQL_C
EXEC SQL BEGIN DECLARE SECTION;
#endif

/* original struct of ARTBUYINGOPTIONS ****************************************/

#ifndef TRANSCLASS
typedef struct N_ARTBUYINGOPTIONS {
    long ARTIKEL_NR;
    long ETARTKLASSE1;
    char KZPSYCHOSTOFFE[2];
} artbuyingoptionsS;
#else /* TRANSCLASS */
typedef struct N_ARTBUYINGOPTIONS {
    long ARTIKEL_NR;
    long ETARTKLASSE1;
    char KZPSYCHOSTOFFE[2];

    bool operator == (const N_ARTBUYINGOPTIONS& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            ETARTKLASSE1 == right.ETARTKLASSE1 &&
            !strcmp(KZPSYCHOSTOFFE, right.KZPSYCHOSTOFFE)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        ETARTKLASSE1 = 0;
        strcpy(KZPSYCHOSTOFFE, " " );
#endif
    }
} artbuyingoptionsS;
#endif /* TRANSCLASS */

/* original struct of ARTCHARGE ***********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTCHARGE {
    short BRANCHNO;
    long ARTICLENO;
    long EXPIRYDATE;
    char CHARGENNR[26];
    long STOCK;
    char STATECHARGE[2];
    long FETCH_REL;
} artchargeS;
#else /* TRANSCLASS */
typedef struct N_ARTCHARGE {
    short BRANCHNO;
    long ARTICLENO;
    long EXPIRYDATE;
    char CHARGENNR[26];
    long STOCK;
    char STATECHARGE[2];
    long FETCH_REL;
    bool operator == (const N_ARTCHARGE& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            ARTICLENO == right.ARTICLENO &&
            EXPIRYDATE == right.EXPIRYDATE &&
            !strcmp(CHARGENNR, right.CHARGENNR) &&
            STOCK == right.STOCK &&
            !strcmp(STATECHARGE, right.STATECHARGE)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        ARTICLENO = 0;
        EXPIRYDATE = 0;
        strcpy(CHARGENNR, " " );
        STOCK = 0;
        strcpy(STATECHARGE, " " );
#endif
    }
} artchargeS;
#endif /* TRANSCLASS */

/* original struct of ARTINFBG ************************************************/

#ifndef TRANSCLASS
typedef struct N_ARTINFBG {
    long ARTIKEL_NR;
    char HEALTHFUNDCODE[6];
    char ARTIKEL_LANGNAME[51];
} artinfbgS;
#else /* TRANSCLASS */
typedef struct N_ARTINFBG {
    long ARTIKEL_NR;
    char HEALTHFUNDCODE[6];
    char ARTIKEL_LANGNAME[51];

    bool operator == (const N_ARTINFBG& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            !strcmp(HEALTHFUNDCODE, right.HEALTHFUNDCODE) &&
            !strcmp(ARTIKEL_LANGNAME, right.ARTIKEL_LANGNAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        strcpy(HEALTHFUNDCODE, " " );
        strcpy(ARTIKEL_LANGNAME, " " );
#endif
    }
} artinfbgS;
#endif /* TRANSCLASS */

/* original struct of ARTINSERT ***********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTINSERT {
    long ARTICLENO;
    short ARTINFOTYPE;
    short SEQUENCENO;
    char INFOTEXT[257];
    long FETCH_REL;
} artinsertS;
#else /* TRANSCLASS */
typedef struct N_ARTINSERT {
    long ARTICLENO;
    short ARTINFOTYPE;
    short SEQUENCENO;
    char INFOTEXT[257];
    long FETCH_REL;
    bool operator == (const N_ARTINSERT& right) const {
        return (
            ARTICLENO == right.ARTICLENO &&
            ARTINFOTYPE == right.ARTINFOTYPE &&
            SEQUENCENO == right.SEQUENCENO &&
            !strcmp(INFOTEXT, right.INFOTEXT)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLENO = 0;
        ARTINFOTYPE = 0;
        SEQUENCENO = 0;
        strcpy(INFOTEXT, " " );
#endif
    }
} artinsertS;
#endif /* TRANSCLASS */

/* original struct of ARTLANGNAME *********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTLANGNAME {
    long ARTIKEL_NR;
    char ARTIKEL_LANGNAME[51];
} artlangnameS;
#else /* TRANSCLASS */
typedef struct N_ARTLANGNAME {
    long ARTIKEL_NR;
    char ARTIKEL_LANGNAME[51];

    bool operator == (const N_ARTLANGNAME& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            !strcmp(ARTIKEL_LANGNAME, right.ARTIKEL_LANGNAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        strcpy(ARTIKEL_LANGNAME, " " );
#endif
    }
} artlangnameS;
#endif /* TRANSCLASS */

/* original struct of ARTPRICE ************************************************/

#ifndef TRANSCLASS
typedef struct N_ARTPRICE {
    long ARTIKEL_NR;
    double PREISEKAPO;
    double PREISEKGROSSO;
    short PREIS_TYP;
} artpriceS;
#else /* TRANSCLASS */
typedef struct N_ARTPRICE {
    long ARTIKEL_NR;
    double PREISEKAPO;
    double PREISEKGROSSO;
    short PREIS_TYP;

    bool operator == (const N_ARTPRICE& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            PREISEKAPO == right.PREISEKAPO &&
            PREISEKGROSSO == right.PREISEKGROSSO &&
            PREIS_TYP == right.PREIS_TYP
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        PREISEKAPO = 0;
        PREISEKGROSSO = 0;
        PREIS_TYP = 0;
#endif
    }
} artpriceS;
#endif /* TRANSCLASS */

/* original struct of ARTPSYCHO ***********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTPSYCHO {
    long ARTIKEL_NR;
    long ETARTKLASSE1;
    char KZPSYCHOSTOFFE[2];
} artpsychoS;
#else /* TRANSCLASS */
typedef struct N_ARTPSYCHO {
    long ARTIKEL_NR;
    long ETARTKLASSE1;
    char KZPSYCHOSTOFFE[2];

    bool operator == (const N_ARTPSYCHO& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            ETARTKLASSE1 == right.ETARTKLASSE1 &&
            !strcmp(KZPSYCHOSTOFFE, right.KZPSYCHOSTOFFE)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        ETARTKLASSE1 = 0;
        strcpy(KZPSYCHOSTOFFE, " " );
#endif
    }
} artpsychoS;
#endif /* TRANSCLASS */

/* original struct of ARTICLEAGENTGROUP ***************************************/

#ifndef TRANSCLASS
typedef struct N_ARTICLEAGENTGROUP {
    double PREISEKAPO;
    short FILIALNR;
    long ARTIKEL_NR;
    long BESTAND;
    char DARREICHFORM[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    char WIRKSTOFF_NR[4];
    char ARTIKEL_LANGNAME[51];
    long FETCH_REL;
} articleagentgroupS;
#else /* TRANSCLASS */
typedef struct N_ARTICLEAGENTGROUP {
    double PREISEKAPO;
    short FILIALNR;
    long ARTIKEL_NR;
    long BESTAND;
    char DARREICHFORM[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    char WIRKSTOFF_NR[4];
    char ARTIKEL_LANGNAME[51];
    long FETCH_REL;
    bool operator == (const N_ARTICLEAGENTGROUP& right) const {
        return (
            PREISEKAPO == right.PREISEKAPO &&
            FILIALNR == right.FILIALNR &&
            ARTIKEL_NR == right.ARTIKEL_NR &&
            BESTAND == right.BESTAND &&
            !strcmp(DARREICHFORM, right.DARREICHFORM) &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME) &&
            !strcmp(WIRKSTOFF_NR, right.WIRKSTOFF_NR) &&
            !strcmp(ARTIKEL_LANGNAME, right.ARTIKEL_LANGNAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        PREISEKAPO = 0;
        FILIALNR = 0;
        ARTIKEL_NR = 0;
        BESTAND = 0;
        strcpy(DARREICHFORM, " " );
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
        strcpy(WIRKSTOFF_NR, " " );
        strcpy(ARTIKEL_LANGNAME, " " );
#endif
    }
} articleagentgroupS;
#endif /* TRANSCLASS */

/* original struct of ARTICLELPPRREIMB ****************************************/

#ifndef TRANSCLASS
typedef struct N_ARTICLELPPRREIMB {
    long ARTICLENO;
    char CODE_LPPR[16];
    long DATEFROM;
    double REIMBURSEMENT_VAL;
    char LPPR_DESC[401];
    short REIMBCALCFLAG;
    long FETCH_REL;
} articlelpprreimbS;
#else /* TRANSCLASS */
typedef struct N_ARTICLELPPRREIMB {
    long ARTICLENO;
    char CODE_LPPR[16];
    long DATEFROM;
    double REIMBURSEMENT_VAL;
    char LPPR_DESC[401];
    short REIMBCALCFLAG;
    long FETCH_REL;
    bool operator == (const N_ARTICLELPPRREIMB& right) const {
        return (
            ARTICLENO == right.ARTICLENO &&
            !strcmp(CODE_LPPR, right.CODE_LPPR) &&
            DATEFROM == right.DATEFROM &&
            REIMBURSEMENT_VAL == right.REIMBURSEMENT_VAL &&
            !strcmp(LPPR_DESC, right.LPPR_DESC) &&
            REIMBCALCFLAG == right.REIMBCALCFLAG
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLENO = 0;
        strcpy(CODE_LPPR, " " );
        DATEFROM = 0;
        REIMBURSEMENT_VAL = 0;
        strcpy(LPPR_DESC, " " );
        REIMBCALCFLAG = 0;
#endif
    }
} articlelpprreimbS;
#endif /* TRANSCLASS */

/* original struct of ARTICLEQUOTADETAIL **************************************/

#ifndef TRANSCLASS
typedef struct N_ARTICLEQUOTADETAIL {
    short BRANCHNO;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUOTA;
    char VALIDITY[2];
    char KZKDKLASSE[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
} articlequotadetailS;
#else /* TRANSCLASS */
typedef struct N_ARTICLEQUOTADETAIL {
    short BRANCHNO;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUOTA;
    char VALIDITY[2];
    char KZKDKLASSE[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
    bool operator == (const N_ARTICLEQUOTADETAIL& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            CUSTOMERNO == right.CUSTOMERNO &&
            ARTICLENO == right.ARTICLENO &&
            QUOTA == right.QUOTA &&
            !strcmp(VALIDITY, right.VALIDITY) &&
            !strcmp(KZKDKLASSE, right.KZKDKLASSE) &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        CUSTOMERNO = 0;
        ARTICLENO = 0;
        QUOTA = 0;
        strcpy(VALIDITY, " " );
        strcpy(KZKDKLASSE, " " );
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
#endif
    }
} articlequotadetailS;
#endif /* TRANSCLASS */

/* original struct of ARTICLEQUOTAEKG *****************************************/

#ifndef TRANSCLASS
typedef struct N_ARTICLEQUOTAEKG {
    short BRANCHNO;
    char GROUP_NAME[31];
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY[2];
    long DATEUPDATE;
    long UID_ANLAGE;
    long DATEFROM;
    long DATETO;
    char PHARMACYGROUPID[4];
    char SNOBATCHCHANGE[2];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
} articlequotaekgS;
#else /* TRANSCLASS */
typedef struct N_ARTICLEQUOTAEKG {
    short BRANCHNO;
    char GROUP_NAME[31];
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY[2];
    long DATEUPDATE;
    long UID_ANLAGE;
    long DATEFROM;
    long DATETO;
    char PHARMACYGROUPID[4];
    char SNOBATCHCHANGE[2];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
    bool operator == (const N_ARTICLEQUOTAEKG& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            !strcmp(GROUP_NAME, right.GROUP_NAME) &&
            ARTICLENO == right.ARTICLENO &&
            QUOTA == right.QUOTA &&
            KUMQTY == right.KUMQTY &&
            !strcmp(VALIDITY, right.VALIDITY) &&
            DATEUPDATE == right.DATEUPDATE &&
            UID_ANLAGE == right.UID_ANLAGE &&
            DATEFROM == right.DATEFROM &&
            DATETO == right.DATETO &&
            !strcmp(PHARMACYGROUPID, right.PHARMACYGROUPID) &&
            !strcmp(SNOBATCHCHANGE, right.SNOBATCHCHANGE) &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        strcpy(GROUP_NAME, " " );
        ARTICLENO = 0;
        QUOTA = 0;
        KUMQTY = 0;
        strcpy(VALIDITY, " " );
        DATEUPDATE = 0;
        UID_ANLAGE = 0;
        DATEFROM = 0;
        DATETO = 0;
        strcpy(PHARMACYGROUPID, " " );
        strcpy(SNOBATCHCHANGE, " " );
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
#endif
    }
} articlequotaekgS;
#endif /* TRANSCLASS */

/* original struct of ARTICLETAX **********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTICLETAX {
    double SALESTAXRATE;
    long ARTIKEL_NR;
} articletaxS;
#else /* TRANSCLASS */
typedef struct N_ARTICLETAX {
    double SALESTAXRATE;
    long ARTIKEL_NR;

    bool operator == (const N_ARTICLETAX& right) const {
        return (
            SALESTAXRATE == right.SALESTAXRATE &&
            ARTIKEL_NR == right.ARTIKEL_NR
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        SALESTAXRATE = 0;
        ARTIKEL_NR = 0;
#endif
    }
} articletaxS;
#endif /* TRANSCLASS */

/* original struct of ARTIKELLPPR *********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTIKELLPPR {
    long ARTICLENO;
    char REIMBURSEMENT_TYPE[2];
    double REIMBURSEMENTPRICE;
    char CODE_LPPR[16];
    double REIMBURSEMENT_PERC;
    long FETCH_REL;
} artikellpprS;
#else /* TRANSCLASS */
typedef struct N_ARTIKELLPPR {
    long ARTICLENO;
    char REIMBURSEMENT_TYPE[2];
    double REIMBURSEMENTPRICE;
    char CODE_LPPR[16];
    double REIMBURSEMENT_PERC;
    long FETCH_REL;
    bool operator == (const N_ARTIKELLPPR& right) const {
        return (
            ARTICLENO == right.ARTICLENO &&
            !strcmp(REIMBURSEMENT_TYPE, right.REIMBURSEMENT_TYPE) &&
            REIMBURSEMENTPRICE == right.REIMBURSEMENTPRICE &&
            !strcmp(CODE_LPPR, right.CODE_LPPR) &&
            REIMBURSEMENT_PERC == right.REIMBURSEMENT_PERC
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLENO = 0;
        strcpy(REIMBURSEMENT_TYPE, " " );
        REIMBURSEMENTPRICE = 0;
        strcpy(CODE_LPPR, " " );
        REIMBURSEMENT_PERC = 0;
#endif
    }
} artikellpprS;
#endif /* TRANSCLASS */

/* original struct of ARTIKELQUOTA ********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTIKELQUOTA {
    short BRANCHNO;
    long CUSTOMERNO;
    char MATCHCODE[13];
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY[2];
    long DATEUPDATE;
    long UID_ANLAGE;
    char SDAFUEQUOTA[2];
    long DATEFROM;
    long DATETO;
    char PHARMACYGROUPID[4];
    char SNOBATCHCHANGE[2];
    short QUOTAINHERITANCE;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
} artikelquotaS;
#else /* TRANSCLASS */
typedef struct N_ARTIKELQUOTA {
    short BRANCHNO;
    long CUSTOMERNO;
    char MATCHCODE[13];
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY[2];
    long DATEUPDATE;
    long UID_ANLAGE;
    char SDAFUEQUOTA[2];
    long DATEFROM;
    long DATETO;
    char PHARMACYGROUPID[4];
    char SNOBATCHCHANGE[2];
    short QUOTAINHERITANCE;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
    bool operator == (const N_ARTIKELQUOTA& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            CUSTOMERNO == right.CUSTOMERNO &&
            !strcmp(MATCHCODE, right.MATCHCODE) &&
            ARTICLENO == right.ARTICLENO &&
            QUOTA == right.QUOTA &&
            KUMQTY == right.KUMQTY &&
            !strcmp(VALIDITY, right.VALIDITY) &&
            DATEUPDATE == right.DATEUPDATE &&
            UID_ANLAGE == right.UID_ANLAGE &&
            !strcmp(SDAFUEQUOTA, right.SDAFUEQUOTA) &&
            DATEFROM == right.DATEFROM &&
            DATETO == right.DATETO &&
            !strcmp(PHARMACYGROUPID, right.PHARMACYGROUPID) &&
            !strcmp(SNOBATCHCHANGE, right.SNOBATCHCHANGE) &&
            QUOTAINHERITANCE == right.QUOTAINHERITANCE &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        CUSTOMERNO = 0;
        strcpy(MATCHCODE, " " );
        ARTICLENO = 0;
        QUOTA = 0;
        KUMQTY = 0;
        strcpy(VALIDITY, " " );
        DATEUPDATE = 0;
        UID_ANLAGE = 0;
        strcpy(SDAFUEQUOTA, " " );
        DATEFROM = 0;
        DATETO = 0;
        strcpy(PHARMACYGROUPID, " " );
        strcpy(SNOBATCHCHANGE, " " );
        QUOTAINHERITANCE = 0;
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
#endif
    }
} artikelquotaS;
#endif /* TRANSCLASS */

/* original struct of ARTIKELQUOTAPF ******************************************/

#ifndef TRANSCLASS
typedef struct N_ARTIKELQUOTAPF {
    short BRANCHNO;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY[2];
    long DATEUPDATE;
    long UID_ANLAGE;
    char SDAFUEQUOTA[2];
    long DATEFROM;
    long DATETO;
    char SNOBATCHCHANGE[2];
    char KZKDKLASSE[4];
    long WERT;
} artikelquotapfS;
#else /* TRANSCLASS */
typedef struct N_ARTIKELQUOTAPF {
    short BRANCHNO;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY[2];
    long DATEUPDATE;
    long UID_ANLAGE;
    char SDAFUEQUOTA[2];
    long DATEFROM;
    long DATETO;
    char SNOBATCHCHANGE[2];
    char KZKDKLASSE[4];
    long WERT;

    bool operator == (const N_ARTIKELQUOTAPF& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            CUSTOMERNO == right.CUSTOMERNO &&
            ARTICLENO == right.ARTICLENO &&
            QUOTA == right.QUOTA &&
            KUMQTY == right.KUMQTY &&
            !strcmp(VALIDITY, right.VALIDITY) &&
            DATEUPDATE == right.DATEUPDATE &&
            UID_ANLAGE == right.UID_ANLAGE &&
            !strcmp(SDAFUEQUOTA, right.SDAFUEQUOTA) &&
            DATEFROM == right.DATEFROM &&
            DATETO == right.DATETO &&
            !strcmp(SNOBATCHCHANGE, right.SNOBATCHCHANGE) &&
            !strcmp(KZKDKLASSE, right.KZKDKLASSE) &&
            WERT == right.WERT
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        CUSTOMERNO = 0;
        ARTICLENO = 0;
        QUOTA = 0;
        KUMQTY = 0;
        strcpy(VALIDITY, " " );
        DATEUPDATE = 0;
        UID_ANLAGE = 0;
        strcpy(SDAFUEQUOTA, " " );
        DATEFROM = 0;
        DATETO = 0;
        strcpy(SNOBATCHCHANGE, " " );
        strcpy(KZKDKLASSE, " " );
        WERT = 0;
#endif
    }
} artikelquotapfS;
#endif /* TRANSCLASS */

/* original struct of ARTIKELRESERVE ******************************************/

#ifndef TRANSCLASS
typedef struct N_ARTIKELRESERVE {
    short BRANCHNO;
    long CUSTOMERNO;
    char PHARMACYGROUPID[4];
    long ARTICLENO;
    short RESERVTYPE;
    long MAXQTY;
    long RESERVEDQTY;
    short RESERVEPCT;
    long FETCH_REL;
} artikelreserveS;
#else /* TRANSCLASS */
typedef struct N_ARTIKELRESERVE {
    short BRANCHNO;
    long CUSTOMERNO;
    char PHARMACYGROUPID[4];
    long ARTICLENO;
    short RESERVTYPE;
    long MAXQTY;
    long RESERVEDQTY;
    short RESERVEPCT;
    long FETCH_REL;
    bool operator == (const N_ARTIKELRESERVE& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            CUSTOMERNO == right.CUSTOMERNO &&
            !strcmp(PHARMACYGROUPID, right.PHARMACYGROUPID) &&
            ARTICLENO == right.ARTICLENO &&
            RESERVTYPE == right.RESERVTYPE &&
            MAXQTY == right.MAXQTY &&
            RESERVEDQTY == right.RESERVEDQTY &&
            RESERVEPCT == right.RESERVEPCT
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        CUSTOMERNO = 0;
        strcpy(PHARMACYGROUPID, " " );
        ARTICLENO = 0;
        RESERVTYPE = 0;
        MAXQTY = 0;
        RESERVEDQTY = 0;
        RESERVEPCT = 0;
#endif
    }
} artikelreserveS;
#endif /* TRANSCLASS */

/* original struct of ARTIKELTEXT *********************************************/

#ifndef TRANSCLASS
typedef struct N_ARTIKELTEXT {
    short BRANCHNO;
    short TEXTKEY;
    char TEXT[241];
    char DISPLAYONSCREEN[2];
    char TEXTHOSPITAL[481];
} artikeltextS;
#else /* TRANSCLASS */
typedef struct N_ARTIKELTEXT {
    short BRANCHNO;
    short TEXTKEY;
    char TEXT[241];
    char DISPLAYONSCREEN[2];
    char TEXTHOSPITAL[481];

    bool operator == (const N_ARTIKELTEXT& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            TEXTKEY == right.TEXTKEY &&
            !strcmp(TEXT, right.TEXT) &&
            !strcmp(DISPLAYONSCREEN, right.DISPLAYONSCREEN) &&
            !strcmp(TEXTHOSPITAL, right.TEXTHOSPITAL)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        TEXTKEY = 0;
        strcpy(TEXT, " " );
        strcpy(DISPLAYONSCREEN, " " );
        strcpy(TEXTHOSPITAL, " " );
#endif
    }
} artikeltextS;
#endif /* TRANSCLASS */

/* original struct of ARTIKELVERFALL ******************************************/

#ifndef TRANSCLASS
typedef struct N_ARTIKELVERFALL {
    short FILIALNR;
    long ARTIKEL_NR;
    long DATUMVERFALL;
} artikelverfallS;
#else /* TRANSCLASS */
typedef struct N_ARTIKELVERFALL {
    short FILIALNR;
    long ARTIKEL_NR;
    long DATUMVERFALL;

    bool operator == (const N_ARTIKELVERFALL& right) const {
        return (
            FILIALNR == right.FILIALNR &&
            ARTIKEL_NR == right.ARTIKEL_NR &&
            DATUMVERFALL == right.DATUMVERFALL
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        FILIALNR = 0;
        ARTIKEL_NR = 0;
        DATUMVERFALL = 0;
#endif
    }
} artikelverfallS;
#endif /* TRANSCLASS */

/* original struct of ATICLEAUX ***********************************************/

#ifndef TRANSCLASS
typedef struct N_ATICLEAUX {
    short BRANCHNO;
    long ARTICLENO;
    short RANKING;
    short AUXBRANCHNO;
    long FETCH_REL;
} aticleauxS;
#else /* TRANSCLASS */
typedef struct N_ATICLEAUX {
    short BRANCHNO;
    long ARTICLENO;
    short RANKING;
    short AUXBRANCHNO;
    long FETCH_REL;
    bool operator == (const N_ATICLEAUX& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            ARTICLENO == right.ARTICLENO &&
            RANKING == right.RANKING &&
            AUXBRANCHNO == right.AUXBRANCHNO
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        ARTICLENO = 0;
        RANKING = 0;
        AUXBRANCHNO = 0;
#endif
    }
} aticleauxS;
#endif /* TRANSCLASS */

/* original struct of CCODE ***************************************************/

#ifndef TRANSCLASS
typedef struct N_CCODE {
    short BRANCHNO;
    char INFOCODE[3];
    char ARTICLEACTIV[2];
    char AUXDELIVERY[2];
    char SERACODE[21];
    char PRINTCODE[31];
    char XMLCODE[6];
    char XMLTEXT[101];
    long FETCH_REL;
} ccodeS;
#else /* TRANSCLASS */
typedef struct N_CCODE {
    short BRANCHNO;
    char INFOCODE[3];
    char ARTICLEACTIV[2];
    char AUXDELIVERY[2];
    char SERACODE[21];
    char PRINTCODE[31];
    char XMLCODE[6];
    char XMLTEXT[101];
    long FETCH_REL;
    bool operator == (const N_CCODE& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            !strcmp(INFOCODE, right.INFOCODE) &&
            !strcmp(ARTICLEACTIV, right.ARTICLEACTIV) &&
            !strcmp(AUXDELIVERY, right.AUXDELIVERY) &&
            !strcmp(SERACODE, right.SERACODE) &&
            !strcmp(PRINTCODE, right.PRINTCODE) &&
            !strcmp(XMLCODE, right.XMLCODE) &&
            !strcmp(XMLTEXT, right.XMLTEXT)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        strcpy(INFOCODE, " " );
        strcpy(ARTICLEACTIV, " " );
        strcpy(AUXDELIVERY, " " );
        strcpy(SERACODE, " " );
        strcpy(PRINTCODE, " " );
        strcpy(XMLCODE, " " );
        strcpy(XMLTEXT, " " );
#endif
    }
} ccodeS;
#endif /* TRANSCLASS */

/* original struct of CHECKIMEXBLOCKEXIST *************************************/

#ifndef TRANSCLASS
typedef struct N_CHECKIMEXBLOCKEXIST {
    long ARTICLENO;
} checkimexblockexistS;
#else /* TRANSCLASS */
typedef struct N_CHECKIMEXBLOCKEXIST {
    long ARTICLENO;

    bool operator == (const N_CHECKIMEXBLOCKEXIST& right) const {
        return (
            ARTICLENO == right.ARTICLENO
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLENO = 0;
#endif
    }
} checkimexblockexistS;
#endif /* TRANSCLASS */

/* original struct of CHECKIMPORTARTICLE **************************************/

#ifndef TRANSCLASS
typedef struct N_CHECKIMPORTARTICLE {
    long ARTIKEL_NR;
    short IMPORTARTICLE;
} checkimportarticleS;
#else /* TRANSCLASS */
typedef struct N_CHECKIMPORTARTICLE {
    long ARTIKEL_NR;
    short IMPORTARTICLE;

    bool operator == (const N_CHECKIMPORTARTICLE& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            IMPORTARTICLE == right.IMPORTARTICLE
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        IMPORTARTICLE = 0;
#endif
    }
} checkimportarticleS;
#endif /* TRANSCLASS */

/* original struct of CHECKLISTE5ZENTRAL **************************************/

#ifndef TRANSCLASS
typedef struct N_CHECKLISTE5ZENTRAL {
    long ARTIKEL_NR;
} checkliste5zentralS;
#else /* TRANSCLASS */
typedef struct N_CHECKLISTE5ZENTRAL {
    long ARTIKEL_NR;

    bool operator == (const N_CHECKLISTE5ZENTRAL& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
#endif
    }
} checkliste5zentralS;
#endif /* TRANSCLASS */

/* original struct of CODEBLOCAGEINFO *****************************************/

#ifndef TRANSCLASS
typedef struct N_CODEBLOCAGEINFO {
    char PRINTCODE[31];
    short FILIALNR;
    long ARTIKEL_NR;
} codeblocageinfoS;
#else /* TRANSCLASS */
typedef struct N_CODEBLOCAGEINFO {
    char PRINTCODE[31];
    short FILIALNR;
    long ARTIKEL_NR;

    bool operator == (const N_CODEBLOCAGEINFO& right) const {
        return (
            !strcmp(PRINTCODE, right.PRINTCODE) &&
            FILIALNR == right.FILIALNR &&
            ARTIKEL_NR == right.ARTIKEL_NR
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        strcpy(PRINTCODE, " " );
        FILIALNR = 0;
        ARTIKEL_NR = 0;
#endif
    }
} codeblocageinfoS;
#endif /* TRANSCLASS */

/* original struct of DISPOINFO ***********************************************/

#ifndef TRANSCLASS
typedef struct N_DISPOINFO {
    char BEZEICHNUNG[31];
    char DISPO_HINWEIS[241];
    char BEMERKUNG[241];
    long PZN;
    long ARTIKEL_NR;
    long HERSTELLER_NR;
    long FETCH_REL;
} dispoinfoS;
#else /* TRANSCLASS */
typedef struct N_DISPOINFO {
    char BEZEICHNUNG[31];
    char DISPO_HINWEIS[241];
    char BEMERKUNG[241];
    long PZN;
    long ARTIKEL_NR;
    long HERSTELLER_NR;
    long FETCH_REL;
    bool operator == (const N_DISPOINFO& right) const {
        return (
            !strcmp(BEZEICHNUNG, right.BEZEICHNUNG) &&
            !strcmp(DISPO_HINWEIS, right.DISPO_HINWEIS) &&
            !strcmp(BEMERKUNG, right.BEMERKUNG) &&
            PZN == right.PZN &&
            ARTIKEL_NR == right.ARTIKEL_NR &&
            HERSTELLER_NR == right.HERSTELLER_NR
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        strcpy(BEZEICHNUNG, " " );
        strcpy(DISPO_HINWEIS, " " );
        strcpy(BEMERKUNG, " " );
        PZN = 0;
        ARTIKEL_NR = 0;
        HERSTELLER_NR = 0;
#endif
    }
} dispoinfoS;
#endif /* TRANSCLASS */

/* original struct of HERSTELLER **********************************************/

#ifndef TRANSCLASS
typedef struct N_HERSTELLER {
    char NAME[31];
    long ARTIKEL_NR;
} herstellerS;
#else /* TRANSCLASS */
typedef struct N_HERSTELLER {
    char NAME[31];
    long ARTIKEL_NR;

    bool operator == (const N_HERSTELLER& right) const {
        return (
            !strcmp(NAME, right.NAME) &&
            ARTIKEL_NR == right.ARTIKEL_NR
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        strcpy(NAME, " " );
        ARTIKEL_NR = 0;
#endif
    }
} herstellerS;
#endif /* TRANSCLASS */

/* original struct of LPPRCODE ************************************************/

#ifndef TRANSCLASS
typedef struct N_LPPRCODE {
    char CODE_LPPR[16];
    double REIMBURSEMENT_VAL;
} lpprcodeS;
#else /* TRANSCLASS */
typedef struct N_LPPRCODE {
    char CODE_LPPR[16];
    double REIMBURSEMENT_VAL;

    bool operator == (const N_LPPRCODE& right) const {
        return (
            !strcmp(CODE_LPPR, right.CODE_LPPR) &&
            REIMBURSEMENT_VAL == right.REIMBURSEMENT_VAL
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        strcpy(CODE_LPPR, " " );
        REIMBURSEMENT_VAL = 0;
#endif
    }
} lpprcodeS;
#endif /* TRANSCLASS */

/* original struct of MAXARTICLEQUOTA *****************************************/

#ifndef TRANSCLASS
typedef struct N_MAXARTICLEQUOTA {
    long ARTICLENO;
    long MAXQUOTA;
} maxarticlequotaS;
#else /* TRANSCLASS */
typedef struct N_MAXARTICLEQUOTA {
    long ARTICLENO;
    long MAXQUOTA;

    bool operator == (const N_MAXARTICLEQUOTA& right) const {
        return (
            ARTICLENO == right.ARTICLENO &&
            MAXQUOTA == right.MAXQUOTA
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLENO = 0;
        MAXQUOTA = 0;
#endif
    }
} maxarticlequotaS;
#endif /* TRANSCLASS */

/* original struct of OCCASION ************************************************/

#ifndef TRANSCLASS
typedef struct N_OCCASION {
    long CUSTOMERNO;
    long ARTICLENO;
    short BRANCHNO;
    double DISCOUNTVALUEPCT;
    long FETCH_REL;
} occasionS;
#else /* TRANSCLASS */
typedef struct N_OCCASION {
    long CUSTOMERNO;
    long ARTICLENO;
    short BRANCHNO;
    double DISCOUNTVALUEPCT;
    long FETCH_REL;
    bool operator == (const N_OCCASION& right) const {
        return (
            CUSTOMERNO == right.CUSTOMERNO &&
            ARTICLENO == right.ARTICLENO &&
            BRANCHNO == right.BRANCHNO &&
            DISCOUNTVALUEPCT == right.DISCOUNTVALUEPCT
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        CUSTOMERNO = 0;
        ARTICLENO = 0;
        BRANCHNO = 0;
        DISCOUNTVALUEPCT = 0;
#endif
    }
} occasionS;
#endif /* TRANSCLASS */

/* original struct of PHARMGRP ************************************************/

#ifndef TRANSCLASS
typedef struct N_PHARMGRP {
    char PHARMACYGROUPID[4];
    char GROUP_NAME[31];
    char GROUP_TYPE[2];
    double PERCENT;
    double CONTRIBUTION;
    long CUSTOMERNO;
    char OMG_OWN_CONT[2];
    char PRICE_BASIS_PURCH[2];
    char RECLAIM_OMG_DISC[2];
    short SPECIALGROUP;
    long SPECIALGROUPREFNO;
    short GROUPING_VIS;
    short BRANCHNO;
} pharmgrpS;
#else /* TRANSCLASS */
typedef struct N_PHARMGRP {
    char PHARMACYGROUPID[4];
    char GROUP_NAME[31];
    char GROUP_TYPE[2];
    double PERCENT;
    double CONTRIBUTION;
    long CUSTOMERNO;
    char OMG_OWN_CONT[2];
    char PRICE_BASIS_PURCH[2];
    char RECLAIM_OMG_DISC[2];
    short SPECIALGROUP;
    long SPECIALGROUPREFNO;
    short GROUPING_VIS;
    short BRANCHNO;

    bool operator == (const N_PHARMGRP& right) const {
        return (
            !strcmp(PHARMACYGROUPID, right.PHARMACYGROUPID) &&
            !strcmp(GROUP_NAME, right.GROUP_NAME) &&
            !strcmp(GROUP_TYPE, right.GROUP_TYPE) &&
            PERCENT == right.PERCENT &&
            CONTRIBUTION == right.CONTRIBUTION &&
            CUSTOMERNO == right.CUSTOMERNO &&
            !strcmp(OMG_OWN_CONT, right.OMG_OWN_CONT) &&
            !strcmp(PRICE_BASIS_PURCH, right.PRICE_BASIS_PURCH) &&
            !strcmp(RECLAIM_OMG_DISC, right.RECLAIM_OMG_DISC) &&
            SPECIALGROUP == right.SPECIALGROUP &&
            SPECIALGROUPREFNO == right.SPECIALGROUPREFNO &&
            GROUPING_VIS == right.GROUPING_VIS &&
            BRANCHNO == right.BRANCHNO
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        strcpy(PHARMACYGROUPID, " " );
        strcpy(GROUP_NAME, " " );
        strcpy(GROUP_TYPE, " " );
        PERCENT = 0;
        CONTRIBUTION = 0;
        CUSTOMERNO = 0;
        strcpy(OMG_OWN_CONT, " " );
        strcpy(PRICE_BASIS_PURCH, " " );
        strcpy(RECLAIM_OMG_DISC, " " );
        SPECIALGROUP = 0;
        SPECIALGROUPREFNO = 0;
        GROUPING_VIS = 0;
        BRANCHNO = 0;
#endif
    }
} pharmgrpS;
#endif /* TRANSCLASS */

/* original struct of PREISANZTYP *********************************************/

#ifndef TRANSCLASS
typedef struct N_PREISANZTYP {
    long ARTIKEL_NR;
    double PREISEKAPO;
    double PREISEKGROSSO;
    double PREISEKGROSSONA;
    short PREIS_TYP;
} preisanztypS;
#else /* TRANSCLASS */
typedef struct N_PREISANZTYP {
    long ARTIKEL_NR;
    double PREISEKAPO;
    double PREISEKGROSSO;
    double PREISEKGROSSONA;
    short PREIS_TYP;

    bool operator == (const N_PREISANZTYP& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            PREISEKAPO == right.PREISEKAPO &&
            PREISEKGROSSO == right.PREISEKGROSSO &&
            PREISEKGROSSONA == right.PREISEKGROSSONA &&
            PREIS_TYP == right.PREIS_TYP
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        PREISEKAPO = 0;
        PREISEKGROSSO = 0;
        PREISEKGROSSONA = 0;
        PREIS_TYP = 0;
#endif
    }
} preisanztypS;
#endif /* TRANSCLASS */

/* original struct of PRICEHIST ***********************************************/

#ifndef TRANSCLASS
typedef struct N_PRICEHIST {
    long ARTIKEL_NR;
    long DATUMGUELTIGAB;
    double GROSSO;
    double AEP;
    double AVP;
    long FETCH_REL;
} pricehistS;
#else /* TRANSCLASS */
typedef struct N_PRICEHIST {
    long ARTIKEL_NR;
    long DATUMGUELTIGAB;
    double GROSSO;
    double AEP;
    double AVP;
    long FETCH_REL;
    bool operator == (const N_PRICEHIST& right) const {
        return (
            ARTIKEL_NR == right.ARTIKEL_NR &&
            DATUMGUELTIGAB == right.DATUMGUELTIGAB &&
            GROSSO == right.GROSSO &&
            AEP == right.AEP &&
            AVP == right.AVP
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTIKEL_NR = 0;
        DATUMGUELTIGAB = 0;
        GROSSO = 0;
        AEP = 0;
        AVP = 0;
#endif
    }
} pricehistS;
#endif /* TRANSCLASS */

/* original struct of PROMOANZ ************************************************/

#ifndef TRANSCLASS
typedef struct N_PROMOANZ {
    short PROMOTION_NO;
    char NAME[31];
    char DESCRIPTION[41];
    short PROMOTION_TYPE;
} promoanzS;
#else /* TRANSCLASS */
typedef struct N_PROMOANZ {
    short PROMOTION_NO;
    char NAME[31];
    char DESCRIPTION[41];
    short PROMOTION_TYPE;

    bool operator == (const N_PROMOANZ& right) const {
        return (
            PROMOTION_NO == right.PROMOTION_NO &&
            !strcmp(NAME, right.NAME) &&
            !strcmp(DESCRIPTION, right.DESCRIPTION) &&
            PROMOTION_TYPE == right.PROMOTION_TYPE
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        PROMOTION_NO = 0;
        strcpy(NAME, " " );
        strcpy(DESCRIPTION, " " );
        PROMOTION_TYPE = 0;
#endif
    }
} promoanzS;
#endif /* TRANSCLASS */

/* original struct of REIMPORT ************************************************/

#ifndef TRANSCLASS
typedef struct N_REIMPORT {
    char DARREICHFORM[4];
    double PREISEKAPO;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long BESTAND;
    long PZN;
    long FETCH_REL;
} reimportS;
#else /* TRANSCLASS */
typedef struct N_REIMPORT {
    char DARREICHFORM[4];
    double PREISEKAPO;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long BESTAND;
    long PZN;
    long FETCH_REL;
    bool operator == (const N_REIMPORT& right) const {
        return (
            !strcmp(DARREICHFORM, right.DARREICHFORM) &&
            PREISEKAPO == right.PREISEKAPO &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME) &&
            BESTAND == right.BESTAND &&
            PZN == right.PZN
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        strcpy(DARREICHFORM, " " );
        PREISEKAPO = 0;
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
        BESTAND = 0;
        PZN = 0;
#endif
    }
} reimportS;
#endif /* TRANSCLASS */

/* original struct of STELLER *************************************************/

#ifndef TRANSCLASS
typedef struct N_STELLER {
    long ARTICLE_NO_PACK;
    long ARTICLE_NO_ELEMENT;
    long QUANTITY;
    short FILIALNR;
    long BESTAND;
    char DARREICHFORM[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    char ARTIKEL_LANGNAME[51];
    long FETCH_REL;
} stellerS;
#else /* TRANSCLASS */
typedef struct N_STELLER {
    long ARTICLE_NO_PACK;
    long ARTICLE_NO_ELEMENT;
    long QUANTITY;
    short FILIALNR;
    long BESTAND;
    char DARREICHFORM[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    char ARTIKEL_LANGNAME[51];
    long FETCH_REL;
    bool operator == (const N_STELLER& right) const {
        return (
            ARTICLE_NO_PACK == right.ARTICLE_NO_PACK &&
            ARTICLE_NO_ELEMENT == right.ARTICLE_NO_ELEMENT &&
            QUANTITY == right.QUANTITY &&
            FILIALNR == right.FILIALNR &&
            BESTAND == right.BESTAND &&
            !strcmp(DARREICHFORM, right.DARREICHFORM) &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME) &&
            !strcmp(ARTIKEL_LANGNAME, right.ARTIKEL_LANGNAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLE_NO_PACK = 0;
        ARTICLE_NO_ELEMENT = 0;
        QUANTITY = 0;
        FILIALNR = 0;
        BESTAND = 0;
        strcpy(DARREICHFORM, " " );
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
        strcpy(ARTIKEL_LANGNAME, " " );
#endif
    }
} stellerS;
#endif /* TRANSCLASS */

/* original struct of STELLERTYP **********************************************/

#ifndef TRANSCLASS
typedef struct N_STELLERTYP {
    long ARTICLE_NO_PACK;
    long DATEFROM;
    long DATETO;
    short COMPACK_TYPE;
} stellertypS;
#else /* TRANSCLASS */
typedef struct N_STELLERTYP {
    long ARTICLE_NO_PACK;
    long DATEFROM;
    long DATETO;
    short COMPACK_TYPE;

    bool operator == (const N_STELLERTYP& right) const {
        return (
            ARTICLE_NO_PACK == right.ARTICLE_NO_PACK &&
            DATEFROM == right.DATEFROM &&
            DATETO == right.DATETO &&
            COMPACK_TYPE == right.COMPACK_TYPE
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLE_NO_PACK = 0;
        DATEFROM = 0;
        DATETO = 0;
        COMPACK_TYPE = 0;
#endif
    }
} stellertypS;
#endif /* TRANSCLASS */

/* original struct of STOCKRESERVATION ****************************************/

#ifndef TRANSCLASS
typedef struct N_STOCKRESERVATION {
    short BRANCHNO;
    long CUSTOMERNO;
    char ARTICLE_CODE[26];
    long ARTICLENO;
    long RESERVEDQTY;
    long DATEFROM;
    long TIMEFROM;
    long DATETO;
    long TIMETO;
    long KDAUFTRAGNR;
    short RESERVTYPE;
    long FETCH_REL;
} stockreservationS;
#else /* TRANSCLASS */
typedef struct N_STOCKRESERVATION {
    short BRANCHNO;
    long CUSTOMERNO;
    char ARTICLE_CODE[26];
    long ARTICLENO;
    long RESERVEDQTY;
    long DATEFROM;
    long TIMEFROM;
    long DATETO;
    long TIMETO;
    long KDAUFTRAGNR;
    short RESERVTYPE;
    long FETCH_REL;
    bool operator == (const N_STOCKRESERVATION& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            CUSTOMERNO == right.CUSTOMERNO &&
            !strcmp(ARTICLE_CODE, right.ARTICLE_CODE) &&
            ARTICLENO == right.ARTICLENO &&
            RESERVEDQTY == right.RESERVEDQTY &&
            DATEFROM == right.DATEFROM &&
            TIMEFROM == right.TIMEFROM &&
            DATETO == right.DATETO &&
            TIMETO == right.TIMETO &&
            KDAUFTRAGNR == right.KDAUFTRAGNR &&
            RESERVTYPE == right.RESERVTYPE
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        CUSTOMERNO = 0;
        strcpy(ARTICLE_CODE, " " );
        ARTICLENO = 0;
        RESERVEDQTY = 0;
        DATEFROM = 0;
        TIMEFROM = 0;
        DATETO = 0;
        TIMETO = 0;
        KDAUFTRAGNR = 0;
        RESERVTYPE = 0;
#endif
    }
} stockreservationS;
#endif /* TRANSCLASS */

/* original struct of STOCKRESERVATIONARTICLERESERV ***************************/

#ifndef TRANSCLASS
typedef struct N_STOCKRESERVATIONARTICLERESERV {
    short BRANCHNO;
    char PHARMACYGROUPID[4];
    long ARTICLENO;
    short RESERVTYPE;
    long MAXQTY;
    long RESERVEDQTY;
    long FETCH_REL;
} stockreservationarticlereservS;
#else /* TRANSCLASS */
typedef struct N_STOCKRESERVATIONARTICLERESERV {
    short BRANCHNO;
    char PHARMACYGROUPID[4];
    long ARTICLENO;
    short RESERVTYPE;
    long MAXQTY;
    long RESERVEDQTY;
    long FETCH_REL;
    bool operator == (const N_STOCKRESERVATIONARTICLERESERV& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            !strcmp(PHARMACYGROUPID, right.PHARMACYGROUPID) &&
            ARTICLENO == right.ARTICLENO &&
            RESERVTYPE == right.RESERVTYPE &&
            MAXQTY == right.MAXQTY &&
            RESERVEDQTY == right.RESERVEDQTY
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        strcpy(PHARMACYGROUPID, " " );
        ARTICLENO = 0;
        RESERVTYPE = 0;
        MAXQTY = 0;
        RESERVEDQTY = 0;
#endif
    }
} stockreservationarticlereservS;
#endif /* TRANSCLASS */

/* original struct of STOCKRESERVATIONARTIKELLOKAL ****************************/

#ifndef TRANSCLASS
typedef struct N_STOCKRESERVATIONARTIKELLOKAL {
    short FILIALNR;
    long ARTIKEL_NR;
    long BESTAND;
    short LAGERBEREICHNR;
    char STATIONNR[3];
    char LAGERFACHNR[11];
    long FETCH_REL;
} stockreservationartikellokalS;
#else /* TRANSCLASS */
typedef struct N_STOCKRESERVATIONARTIKELLOKAL {
    short FILIALNR;
    long ARTIKEL_NR;
    long BESTAND;
    short LAGERBEREICHNR;
    char STATIONNR[3];
    char LAGERFACHNR[11];
    long FETCH_REL;
    bool operator == (const N_STOCKRESERVATIONARTIKELLOKAL& right) const {
        return (
            FILIALNR == right.FILIALNR &&
            ARTIKEL_NR == right.ARTIKEL_NR &&
            BESTAND == right.BESTAND &&
            LAGERBEREICHNR == right.LAGERBEREICHNR &&
            !strcmp(STATIONNR, right.STATIONNR) &&
            !strcmp(LAGERFACHNR, right.LAGERFACHNR)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        FILIALNR = 0;
        ARTIKEL_NR = 0;
        BESTAND = 0;
        LAGERBEREICHNR = 0;
        strcpy(STATIONNR, " " );
        strcpy(LAGERFACHNR, " " );
#endif
    }
} stockreservationartikellokalS;
#endif /* TRANSCLASS */

/* original struct of STOCKRESERVATIONIBTREQUEST ******************************/

#ifndef TRANSCLASS
typedef struct N_STOCKRESERVATIONIBTREQUEST {
    long IBTREQUESTID;
    short BRANCHNO;
    long CSCORDERNO;
    long CSCORDERPOSNO;
    long DATEFROM;
    short IBTBRANCHNO;
    long IBTCUSTOMERNO;
    long TIMEFROM;
    short PROCESSINGSTATE;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUANTITY;
    long FETCH_REL;
} stockreservationibtrequestS;
#else /* TRANSCLASS */
typedef struct N_STOCKRESERVATIONIBTREQUEST {
    long IBTREQUESTID;
    short BRANCHNO;
    long CSCORDERNO;
    long CSCORDERPOSNO;
    long DATEFROM;
    short IBTBRANCHNO;
    long IBTCUSTOMERNO;
    long TIMEFROM;
    short PROCESSINGSTATE;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUANTITY;
    long FETCH_REL;
    bool operator == (const N_STOCKRESERVATIONIBTREQUEST& right) const {
        return (
            IBTREQUESTID == right.IBTREQUESTID &&
            BRANCHNO == right.BRANCHNO &&
            CSCORDERNO == right.CSCORDERNO &&
            CSCORDERPOSNO == right.CSCORDERPOSNO &&
            DATEFROM == right.DATEFROM &&
            IBTBRANCHNO == right.IBTBRANCHNO &&
            IBTCUSTOMERNO == right.IBTCUSTOMERNO &&
            TIMEFROM == right.TIMEFROM &&
            PROCESSINGSTATE == right.PROCESSINGSTATE &&
            CUSTOMERNO == right.CUSTOMERNO &&
            ARTICLENO == right.ARTICLENO &&
            QUANTITY == right.QUANTITY
            );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        IBTREQUESTID = 0;
        BRANCHNO = 0;
        CSCORDERNO = 0;
        CSCORDERPOSNO = 0;
        DATEFROM = 0;
        IBTBRANCHNO = 0;
        IBTCUSTOMERNO = 0;
        TIMEFROM = 0;
        PROCESSINGSTATE = 0;
        CUSTOMERNO = 0;
        ARTICLENO = 0;
        QUANTITY = 0;
#endif
    }
} stockreservationibtrequestS;
#endif /* TRANSCLASS */

/* original struct of STOCKRESERVATIONNACHLIEFERPOS ***************************/

#ifndef TRANSCLASS
typedef struct N_STOCKRESERVATIONNACHLIEFERPOS {
    long KDAUFTRAGNR;
    long POSNR;
    long DATUM;
    short POSTYP;
    long IDFNR;
    long ARTIKEL_NR;
    long MENGE;
    long STATUS;
    long FETCH_REL;
} stockreservationnachlieferposS;
#else /* TRANSCLASS */
typedef struct N_STOCKRESERVATIONNACHLIEFERPOS {
    long KDAUFTRAGNR;
    long POSNR;
    long DATUM;
    short POSTYP;
    long IDFNR;
    long ARTIKEL_NR;
    long MENGE;
    long STATUS;
    long FETCH_REL;
    bool operator == (const N_STOCKRESERVATIONNACHLIEFERPOS& right) const {
        return (
            KDAUFTRAGNR == right.KDAUFTRAGNR &&
            POSNR == right.POSNR &&
            DATUM == right.DATUM &&
            POSTYP == right.POSTYP &&
            IDFNR == right.IDFNR &&
            ARTIKEL_NR == right.ARTIKEL_NR &&
            MENGE == right.MENGE &&
            STATUS == right.STATUS
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        KDAUFTRAGNR = 0;
        POSNR = 0;
        DATUM = 0;
        POSTYP = 0;
        IDFNR = 0;
        ARTIKEL_NR = 0;
        MENGE = 0;
        STATUS = 0;
#endif
    }
} stockreservationnachlieferposS;
#endif /* TRANSCLASS */

/* original struct of STOCKRESERVATIONORDER ***********************************/

#ifndef TRANSCLASS
typedef struct N_STOCKRESERVATIONORDER {
    long DATUM;
    long KDAUFTRAGNR;
    char KDAUFTRAGSTAT[17];
    long IDFNR;
    short FILIALNR;
    char KDAUFTRAGART[3];
    long KUNDENNR;
    char ZUGRUND[17];
    long FETCH_REL;
} stockreservationorderS;
#else /* TRANSCLASS */
typedef struct N_STOCKRESERVATIONORDER {
    long DATUM;
    long KDAUFTRAGNR;
    char KDAUFTRAGSTAT[17];
    long IDFNR;
    short FILIALNR;
    char KDAUFTRAGART[3];
    long KUNDENNR;
    char ZUGRUND[17];
    long FETCH_REL;
    bool operator == (const N_STOCKRESERVATIONORDER& right) const {
        return (
            DATUM == right.DATUM &&
            KDAUFTRAGNR == right.KDAUFTRAGNR &&
            !strcmp(KDAUFTRAGSTAT, right.KDAUFTRAGSTAT) &&
            IDFNR == right.IDFNR &&
            FILIALNR == right.FILIALNR &&
            !strcmp(KDAUFTRAGART, right.KDAUFTRAGART) &&
            KUNDENNR == right.KUNDENNR &&
            !strcmp(ZUGRUND, right.ZUGRUND)
            );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        DATUM = 0;
        KDAUFTRAGNR = 0;
        strcpy(KDAUFTRAGSTAT, " ");
        IDFNR = 0;
        FILIALNR = 0;
        strcpy(KDAUFTRAGART, " ");
        KUNDENNR = 0;
        strcpy(ZUGRUND, " ");
#endif
    }
} stockreservationorderS;
#endif /* TRANSCLASS */

/* original struct of SUPPLINFO ***********************************************/

#ifndef TRANSCLASS
typedef struct N_SUPPLINFO {
    long ARTICLENO;
    char AVAILABILITYINFO[255];
    long PROGLIEFERDATUM;
    long LIEFERDATUM;
    long FETCH_REL;
} supplinfoS;
#else /* TRANSCLASS */
typedef struct N_SUPPLINFO {
    long ARTICLENO;
    char AVAILABILITYINFO[255];
    long PROGLIEFERDATUM;
    long LIEFERDATUM;
    long FETCH_REL;
    bool operator == (const N_SUPPLINFO& right) const {
        return (
            ARTICLENO == right.ARTICLENO &&
            !strcmp(AVAILABILITYINFO, right.AVAILABILITYINFO) &&
            PROGLIEFERDATUM == right.PROGLIEFERDATUM &&
            LIEFERDATUM == right.LIEFERDATUM
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        ARTICLENO = 0;
        strcpy(AVAILABILITYINFO, " " );
        PROGLIEFERDATUM = 0;
        LIEFERDATUM = 0;
#endif
    }
} supplinfoS;
#endif /* TRANSCLASS */

/* original struct of DELAYEDART **********************************************/

#ifndef TRANSCLASS
typedef struct N_DELAYEDART {
    short BRANCHNO;
    char NARCOTIC[2];
    char COLDCHAIN[2];
    char COOL08[2];
    char COOL20[2];
    long FETCH_REL;
} delayedartS;
#else /* TRANSCLASS */
typedef struct N_DELAYEDART {
    short BRANCHNO;
    char NARCOTIC[2];
    char COLDCHAIN[2];
    char COOL08[2];
    char COOL20[2];
    long FETCH_REL;
    bool operator == (const N_DELAYEDART& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            !strcmp(NARCOTIC, right.NARCOTIC) &&
            !strcmp(COLDCHAIN, right.COLDCHAIN) &&
            !strcmp(COOL08, right.COOL08) &&
            !strcmp(COOL20, right.COOL20)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        strcpy(NARCOTIC, " " );
        strcpy(COLDCHAIN, " " );
        strcpy(COOL08, " " );
        strcpy(COOL20, " " );
#endif
    }
} delayedartS;
#endif /* TRANSCLASS */

/* original struct of DISCOUNTANZ *********************************************/

#ifndef TRANSCLASS
typedef struct N_DISCOUNTANZ {
    short BRANCHNO;
    long ARTICLENO;
    long DISCOUNTGRPNO;
    char PHARMACYGROUPID[4];
    long CUSTOMERNO;
    short GRPDISCOUNTTYP;
    long DATEFROM;
    long DATETO;
    long BASEQTY;
    short DISCOUNTSPEC;
    short DISCOUNTTYPE;
    short DISCOUNTQTY;
    double DISCOUNTVALUEPCT;
    short PREIS_TYP;
    double DISCOUNTQTYPCT;
    double SURCHARGEPCT;
    char PHARMGRPEXCLUDED[4];
    double FIXEDPRICE;
    double REFUNDPCT;
    char INTERNALDISCOUNT[2];
    long DISCOUNTARTICLE;
    char UPDATESIGN[2];
    double BASE_VALUE;
    long BASE_MULT_STD_QTY;
    char NO_MULTIPLE_QTY[2];
    double FIXEDDISCOUNTVALUE;
    long MANUFACTURERNO;
    long ARTCATEGORYNO;
    short PAYMENTTARGETNO;
    double GROSSPROFITPCT;
    char ADDONDISCOUNTOK[2];
    char PAYMENTTERMTYPE[2];
    long TARGETQTY;
    double EXCEEDANCEPCT;
    long ARTICLE_NO_PACK;
    double REFUNDVALUE;
    short PROMOTION_NO;
    short DISCOUNTAPPLYTO;
    short DISCOUNTCALCFROM;
    long FETCH_REL;
} discountanzS;
#else /* TRANSCLASS */
typedef struct N_DISCOUNTANZ {
    short BRANCHNO;
    long ARTICLENO;
    long DISCOUNTGRPNO;
    char PHARMACYGROUPID[4];
    long CUSTOMERNO;
    short GRPDISCOUNTTYP;
    long DATEFROM;
    long DATETO;
    long BASEQTY;
    short DISCOUNTSPEC;
    short DISCOUNTTYPE;
    short DISCOUNTQTY;
    double DISCOUNTVALUEPCT;
    short PREIS_TYP;
    double DISCOUNTQTYPCT;
    double SURCHARGEPCT;
    char PHARMGRPEXCLUDED[4];
    double FIXEDPRICE;
    double REFUNDPCT;
    char INTERNALDISCOUNT[2];
    long DISCOUNTARTICLE;
    char UPDATESIGN[2];
    double BASE_VALUE;
    long BASE_MULT_STD_QTY;
    char NO_MULTIPLE_QTY[2];
    double FIXEDDISCOUNTVALUE;
    long MANUFACTURERNO;
    long ARTCATEGORYNO;
    short PAYMENTTARGETNO;
    double GROSSPROFITPCT;
    char ADDONDISCOUNTOK[2];
    char PAYMENTTERMTYPE[2];
    long TARGETQTY;
    double EXCEEDANCEPCT;
    long ARTICLE_NO_PACK;
    double REFUNDVALUE;
    short PROMOTION_NO;
    short DISCOUNTAPPLYTO;
    short DISCOUNTCALCFROM;
    long FETCH_REL;
    bool operator == (const N_DISCOUNTANZ& right) const {
        return (
            BRANCHNO == right.BRANCHNO &&
            ARTICLENO == right.ARTICLENO &&
            DISCOUNTGRPNO == right.DISCOUNTGRPNO &&
            !strcmp(PHARMACYGROUPID, right.PHARMACYGROUPID) &&
            CUSTOMERNO == right.CUSTOMERNO &&
            GRPDISCOUNTTYP == right.GRPDISCOUNTTYP &&
            DATEFROM == right.DATEFROM &&
            DATETO == right.DATETO &&
            BASEQTY == right.BASEQTY &&
            DISCOUNTSPEC == right.DISCOUNTSPEC &&
            DISCOUNTTYPE == right.DISCOUNTTYPE &&
            DISCOUNTQTY == right.DISCOUNTQTY &&
            DISCOUNTVALUEPCT == right.DISCOUNTVALUEPCT &&
            PREIS_TYP == right.PREIS_TYP &&
            DISCOUNTQTYPCT == right.DISCOUNTQTYPCT &&
            SURCHARGEPCT == right.SURCHARGEPCT &&
            !strcmp(PHARMGRPEXCLUDED, right.PHARMGRPEXCLUDED) &&
            FIXEDPRICE == right.FIXEDPRICE &&
            REFUNDPCT == right.REFUNDPCT &&
            !strcmp(INTERNALDISCOUNT, right.INTERNALDISCOUNT) &&
            DISCOUNTARTICLE == right.DISCOUNTARTICLE &&
            !strcmp(UPDATESIGN, right.UPDATESIGN) &&
            BASE_VALUE == right.BASE_VALUE &&
            BASE_MULT_STD_QTY == right.BASE_MULT_STD_QTY &&
            !strcmp(NO_MULTIPLE_QTY, right.NO_MULTIPLE_QTY) &&
            FIXEDDISCOUNTVALUE == right.FIXEDDISCOUNTVALUE &&
            MANUFACTURERNO == right.MANUFACTURERNO &&
            ARTCATEGORYNO == right.ARTCATEGORYNO &&
            PAYMENTTARGETNO == right.PAYMENTTARGETNO &&
            GROSSPROFITPCT == right.GROSSPROFITPCT &&
            !strcmp(ADDONDISCOUNTOK, right.ADDONDISCOUNTOK) &&
            !strcmp(PAYMENTTERMTYPE, right.PAYMENTTERMTYPE) &&
            TARGETQTY == right.TARGETQTY &&
            EXCEEDANCEPCT == right.EXCEEDANCEPCT &&
            ARTICLE_NO_PACK == right.ARTICLE_NO_PACK &&
            REFUNDVALUE == right.REFUNDVALUE &&
            PROMOTION_NO == right.PROMOTION_NO &&
            DISCOUNTAPPLYTO == right.DISCOUNTAPPLYTO &&
            DISCOUNTCALCFROM == right.DISCOUNTCALCFROM
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        BRANCHNO = 0;
        ARTICLENO = 0;
        DISCOUNTGRPNO = 0;
        strcpy(PHARMACYGROUPID, " " );
        CUSTOMERNO = 0;
        GRPDISCOUNTTYP = 0;
        DATEFROM = 0;
        DATETO = 0;
        BASEQTY = 0;
        DISCOUNTSPEC = 0;
        DISCOUNTTYPE = 0;
        DISCOUNTQTY = 0;
        DISCOUNTVALUEPCT = 0;
        PREIS_TYP = 0;
        DISCOUNTQTYPCT = 0;
        SURCHARGEPCT = 0;
        strcpy(PHARMGRPEXCLUDED, " " );
        FIXEDPRICE = 0;
        REFUNDPCT = 0;
        strcpy(INTERNALDISCOUNT, " " );
        DISCOUNTARTICLE = 0;
        strcpy(UPDATESIGN, " " );
        BASE_VALUE = 0;
        BASE_MULT_STD_QTY = 0;
        strcpy(NO_MULTIPLE_QTY, " " );
        FIXEDDISCOUNTVALUE = 0;
        MANUFACTURERNO = 0;
        ARTCATEGORYNO = 0;
        PAYMENTTARGETNO = 0;
        GROSSPROFITPCT = 0;
        strcpy(ADDONDISCOUNTOK, " " );
        strcpy(PAYMENTTERMTYPE, " " );
        TARGETQTY = 0;
        EXCEEDANCEPCT = 0;
        ARTICLE_NO_PACK = 0;
        REFUNDVALUE = 0;
        PROMOTION_NO = 0;
        DISCOUNTAPPLYTO = 0;
        DISCOUNTCALCFROM = 0;
#endif
    }
} discountanzS;
#endif /* TRANSCLASS */

/* original struct of STOCKENTRY **********************************************/

#ifndef TRANSCLASS
typedef struct N_STOCKENTRY {
    long DATE;
    short BRANCHNO;
    long ARTICLENO;
    long BESTAND;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
} stockentryS;
#else /* TRANSCLASS */
typedef struct N_STOCKENTRY {
    long DATE;
    short BRANCHNO;
    long ARTICLENO;
    long BESTAND;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
    bool operator == (const N_STOCKENTRY& right) const {
        return (
            DATE == right.DATE &&
            BRANCHNO == right.BRANCHNO &&
            ARTICLENO == right.ARTICLENO &&
            BESTAND == right.BESTAND &&
            !strcmp(EINHEIT, right.EINHEIT) &&
            !strcmp(ARTIKEL_NAME, right.ARTIKEL_NAME)
        );
    }
    void clear() {
#ifdef WIN32
        memset((char*)this, 0, sizeof(*this));
#else
        DATE = 0;
        BRANCHNO = 0;
        ARTICLENO = 0;
        BESTAND = 0;
        strcpy(EINHEIT, " " );
        strcpy(ARTIKEL_NAME, " " );
#endif
    }
} stockentryS;
#endif /* TRANSCLASS */

#ifdef ESQL_C
EXEC SQL END DECLARE SECTION;
#endif

#ifdef ESQL_C
EXEC SQL BEGIN DECLARE SECTION;
#endif

/* Stringbuffer Structur of STOCKRESERVATION **********************************/

struct S_STOCKRESERVATION {
    char BRANCHNO[7];
    char CUSTOMERNO[11];
    char ARTICLE_CODE[25 + 1];
    char ARTICLENO[11];
    char RESERVEDQTY[11];
    char DATEFROM[11];
    char TIMEFROM[11];
    char DATETO[11];
    char TIMETO[11];
    char KDAUFTRAGNR[11];
    char RESERVTYPE[7];
    char FETCH_REL[11];
};
/* Stringbuffer Structur of STOCKRESERVATIONARTICLERESERV *********************/

struct S_STOCKRESERVATIONARTICLERESERV {
    char BRANCHNO[7];
    char PHARMACYGROUPID[3 + 1];
    char ARTICLENO[11];
    char RESERVTYPE[7];
    char MAXQTY[11];
    char RESERVEDQTY[11];
    char FETCH_REL[11];
};
/* Stringbuffer Structur of STOCKRESERVATIONARTIKELLOKAL **********************/

struct S_STOCKRESERVATIONARTIKELLOKAL {
    char FILIALNR[7];
    char ARTIKEL_NR[11];
    char BESTAND[11];
    char LAGERBEREICHNR[7];
    char STATIONNR[2 + 1];
    char LAGERFACHNR[10 + 1];
    char FETCH_REL[11];
};
/* Stringbuffer Structur of STOCKRESERVATIONIBTREQUEST ************************/

struct S_STOCKRESERVATIONIBTREQUEST {
    char IBTREQUESTID[11];
    char BRANCHNO[7];
    char CSCORDERNO[11];
    char CSCORDERPOSNO[11];
    char DATEFROM[11];
    char IBTBRANCHNO[7];
    char IBTCUSTOMERNO[11];
    char TIMEFROM[11];
    char PROCESSINGSTATE[7];
    char CUSTOMERNO[11];
    char ARTICLENO[11];
    char QUANTITY[11];
    char FETCH_REL[11];
};
/* Stringbuffer Structur of STOCKRESERVATIONNACHLIEFERPOS *********************/

struct S_STOCKRESERVATIONNACHLIEFERPOS {
    char KDAUFTRAGNR[11];
    char POSNR[11];
    char DATUM[11];
    char POSTYP[7];
    char IDFNR[11];
    char ARTIKEL_NR[11];
    char MENGE[11];
    char STATUS[11];
    char FETCH_REL[11];
};

/* Stringbuffer Structur of STOCKRESERVATIONORDER *****************************/

struct S_STOCKRESERVATIONORDER {
    char DATUM[11];
    char KDAUFTRAGNR[11];
    char KDAUFTRAGSTAT[16 + 1];
    char IDFNR[11];
    char FILIALNR[7];
    char KDAUFTRAGART[2 + 1];
    char KUNDENNR[11];
    char ZUGRUND[16 + 1];
    char FETCH_REL[11];
};

/* Stringbuffer (without strend) Structur of STOCKRESERVATION *****************/

struct O_STOCKRESERVATION {
    char BRANCHNO[7];
    char CUSTOMERNO[11];
    char ARTICLE_CODE[25];
    char ARTICLENO[11];
    char RESERVEDQTY[11];
    char DATEFROM[11];
    char TIMEFROM[11];
    char DATETO[11];
    char TIMETO[11];
    char KDAUFTRAGNR[11];
    char RESERVTYPE[7];
    char FETCH_REL[11];
};
/* Stringbuffer (without strend) Structur of STOCKRESERVATIONARTICLERESERV ****/

struct O_STOCKRESERVATIONARTICLERESERV {
    char BRANCHNO[7];
    char PHARMACYGROUPID[3];
    char ARTICLENO[11];
    char RESERVTYPE[7];
    char MAXQTY[11];
    char RESERVEDQTY[11];
    char FETCH_REL[11];
};
/* Stringbuffer (without strend) Structur of STOCKRESERVATIONARTIKELLOKAL *****/

struct O_STOCKRESERVATIONARTIKELLOKAL {
    char FILIALNR[7];
    char ARTIKEL_NR[11];
    char BESTAND[11];
    char LAGERBEREICHNR[7];
    char STATIONNR[2];
    char LAGERFACHNR[10];
    char FETCH_REL[11];
};
/* Stringbuffer (without strend) Structur of STOCKRESERVATIONIBTREQUEST *******/

struct O_STOCKRESERVATIONIBTREQUEST {
    char IBTREQUESTID[11];
    char BRANCHNO[7];
    char CSCORDERNO[11];
    char CSCORDERPOSNO[11];
    char DATEFROM[11];
    char IBTBRANCHNO[7];
    char IBTCUSTOMERNO[11];
    char TIMEFROM[11];
    char PROCESSINGSTATE[7];
    char CUSTOMERNO[11];
    char ARTICLENO[11];
    char QUANTITY[11];
    char FETCH_REL[11];
};

/* Stringbuffer (without strend) Structur of STOCKRESERVATIONNACHLIEFERPOS ****/

struct O_STOCKRESERVATIONNACHLIEFERPOS {
    char KDAUFTRAGNR[11];
    char POSNR[11];
    char DATUM[11];
    char POSTYP[7];
    char IDFNR[11];
    char ARTIKEL_NR[11];
    char MENGE[11];
    char STATUS[11];
    char FETCH_REL[11];
};

/* Stringbuffer (without strend) Structur of STOCKRESERVATIONORDER ************/

struct O_STOCKRESERVATIONORDER {
    char DATUM[11];
    char KDAUFTRAGNR[11];
    char KDAUFTRAGSTAT[16];
    char IDFNR[11];
    char FILIALNR[7];
    char KDAUFTRAGART[2];
    char KUNDENNR[11];
    char ZUGRUND[16];
    char FETCH_REL[11];
};

/* Structur with real chartype of ARTBUYINGOPTIONS ****************************/

struct C_ARTBUYINGOPTIONS {
    long ARTIKEL_NR;
    long ETARTKLASSE1;
    char KZPSYCHOSTOFFE;
};
/* Structur with real chartype of ARTCHARGE ***********************************/

struct C_ARTCHARGE {
    short BRANCHNO;
    long ARTICLENO;
    long EXPIRYDATE;
    char CHARGENNR[26];
    long STOCK;
    char STATECHARGE;
    long FETCH_REL;
};
/* Structur with real chartype of ARTINFBG ************************************/

struct C_ARTINFBG {
    long ARTIKEL_NR;
    char HEALTHFUNDCODE[6];
    char ARTIKEL_LANGNAME[51];
};
/* Structur with real chartype of ARTINSERT ***********************************/

struct C_ARTINSERT {
    long ARTICLENO;
    short ARTINFOTYPE;
    short SEQUENCENO;
    char INFOTEXT[257];
    long FETCH_REL;
};
/* Structur with real chartype of ARTLANGNAME *********************************/

struct C_ARTLANGNAME {
    long ARTIKEL_NR;
    char ARTIKEL_LANGNAME[51];
};
/* Structur with real chartype of ARTPRICE ************************************/

struct C_ARTPRICE {
    long ARTIKEL_NR;
    double PREISEKAPO;
    double PREISEKGROSSO;
    short PREIS_TYP;
};
/* Structur with real chartype of ARTPSYCHO ***********************************/

struct C_ARTPSYCHO {
    long ARTIKEL_NR;
    long ETARTKLASSE1;
    char KZPSYCHOSTOFFE;
};
/* Structur with real chartype of ARTICLEAGENTGROUP ***************************/

struct C_ARTICLEAGENTGROUP {
    double PREISEKAPO;
    short FILIALNR;
    long ARTIKEL_NR;
    long BESTAND;
    char DARREICHFORM[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    char WIRKSTOFF_NR[4];
    char ARTIKEL_LANGNAME[51];
    long FETCH_REL;
};
/* Structur with real chartype of ARTICLELPPRREIMB ****************************/

struct C_ARTICLELPPRREIMB {
    long ARTICLENO;
    char CODE_LPPR[16];
    long DATEFROM;
    double REIMBURSEMENT_VAL;
    char LPPR_DESC[401];
    short REIMBCALCFLAG;
    long FETCH_REL;
};
/* Structur with real chartype of ARTICLEQUOTADETAIL **************************/

struct C_ARTICLEQUOTADETAIL {
    short BRANCHNO;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUOTA;
    char VALIDITY;
    char KZKDKLASSE[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
};
/* Structur with real chartype of ARTICLEQUOTAEKG *****************************/

struct C_ARTICLEQUOTAEKG {
    short BRANCHNO;
    char GROUP_NAME[31];
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY;
    long DATEUPDATE;
    long UID_ANLAGE;
    long DATEFROM;
    long DATETO;
    char PHARMACYGROUPID[4];
    char SNOBATCHCHANGE;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
};
/* Structur with real chartype of ARTICLETAX **********************************/

struct C_ARTICLETAX {
    double SALESTAXRATE;
    long ARTIKEL_NR;
};
/* Structur with real chartype of ARTIKELLPPR *********************************/

struct C_ARTIKELLPPR {
    long ARTICLENO;
    char REIMBURSEMENT_TYPE;
    double REIMBURSEMENTPRICE;
    char CODE_LPPR[16];
    double REIMBURSEMENT_PERC;
    long FETCH_REL;
};
/* Structur with real chartype of ARTIKELQUOTA ********************************/

struct C_ARTIKELQUOTA {
    short BRANCHNO;
    long CUSTOMERNO;
    char MATCHCODE[13];
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY;
    long DATEUPDATE;
    long UID_ANLAGE;
    char SDAFUEQUOTA;
    long DATEFROM;
    long DATETO;
    char PHARMACYGROUPID[4];
    char SNOBATCHCHANGE;
    short QUOTAINHERITANCE;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
};
/* Structur with real chartype of ARTIKELQUOTAPF ******************************/

struct C_ARTIKELQUOTAPF {
    short BRANCHNO;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUOTA;
    long KUMQTY;
    char VALIDITY;
    long DATEUPDATE;
    long UID_ANLAGE;
    char SDAFUEQUOTA;
    long DATEFROM;
    long DATETO;
    char SNOBATCHCHANGE;
    char KZKDKLASSE[4];
    long WERT;
};
/* Structur with real chartype of ARTIKELRESERVE ******************************/

struct C_ARTIKELRESERVE {
    short BRANCHNO;
    long CUSTOMERNO;
    char PHARMACYGROUPID[4];
    long ARTICLENO;
    short RESERVTYPE;
    long MAXQTY;
    long RESERVEDQTY;
    short RESERVEPCT;
    long FETCH_REL;
};
/* Structur with real chartype of ARTIKELTEXT *********************************/

struct C_ARTIKELTEXT {
    short BRANCHNO;
    short TEXTKEY;
    char TEXT[241];
    char DISPLAYONSCREEN;
    char TEXTHOSPITAL[481];
};
/* Structur with real chartype of ARTIKELVERFALL ******************************/

struct C_ARTIKELVERFALL {
    short FILIALNR;
    long ARTIKEL_NR;
    long DATUMVERFALL;
};
/* Structur with real chartype of ATICLEAUX ***********************************/

struct C_ATICLEAUX {
    short BRANCHNO;
    long ARTICLENO;
    short RANKING;
    short AUXBRANCHNO;
    long FETCH_REL;
};
/* Structur with real chartype of CCODE ***************************************/

struct C_CCODE {
    short BRANCHNO;
    char INFOCODE[3];
    char ARTICLEACTIV;
    char AUXDELIVERY;
    char SERACODE[21];
    char PRINTCODE[31];
    char XMLCODE[6];
    char XMLTEXT[101];
    long FETCH_REL;
};
/* Structur with real chartype of CHECKIMEXBLOCKEXIST *************************/

struct C_CHECKIMEXBLOCKEXIST {
    long ARTICLENO;
};
/* Structur with real chartype of CHECKIMPORTARTICLE **************************/

struct C_CHECKIMPORTARTICLE {
    long ARTIKEL_NR;
    short IMPORTARTICLE;
};
/* Structur with real chartype of CHECKLISTE5ZENTRAL **************************/

struct C_CHECKLISTE5ZENTRAL {
    long ARTIKEL_NR;
};
/* Structur with real chartype of CODEBLOCAGEINFO *****************************/

struct C_CODEBLOCAGEINFO {
    char PRINTCODE[31];
    short FILIALNR;
    long ARTIKEL_NR;
};
/* Structur with real chartype of DISPOINFO ***********************************/

struct C_DISPOINFO {
    char BEZEICHNUNG[31];
    char DISPO_HINWEIS[241];
    char BEMERKUNG[241];
    long PZN;
    long ARTIKEL_NR;
    long HERSTELLER_NR;
    long FETCH_REL;
};
/* Structur with real chartype of HERSTELLER **********************************/

struct C_HERSTELLER {
    char NAME[31];
    long ARTIKEL_NR;
};
/* Structur with real chartype of LPPRCODE ************************************/

struct C_LPPRCODE {
    char CODE_LPPR[16];
    double REIMBURSEMENT_VAL;
};
/* Structur with real chartype of MAXARTICLEQUOTA *****************************/

struct C_MAXARTICLEQUOTA {
    long ARTICLENO;
    long MAXQUOTA;
};
/* Structur with real chartype of OCCASION ************************************/

struct C_OCCASION {
    long CUSTOMERNO;
    long ARTICLENO;
    short BRANCHNO;
    double DISCOUNTVALUEPCT;
    long FETCH_REL;
};
/* Structur with real chartype of PHARMGRP ************************************/

struct C_PHARMGRP {
    char PHARMACYGROUPID[4];
    char GROUP_NAME[31];
    char GROUP_TYPE;
    double PERCENT;
    double CONTRIBUTION;
    long CUSTOMERNO;
    char OMG_OWN_CONT;
    char PRICE_BASIS_PURCH;
    char RECLAIM_OMG_DISC;
    short SPECIALGROUP;
    long SPECIALGROUPREFNO;
    short GROUPING_VIS;
    short BRANCHNO;
};
/* Structur with real chartype of PREISANZTYP *********************************/

struct C_PREISANZTYP {
    long ARTIKEL_NR;
    double PREISEKAPO;
    double PREISEKGROSSO;
    double PREISEKGROSSONA;
    short PREIS_TYP;
};
/* Structur with real chartype of PRICEHIST ***********************************/

struct C_PRICEHIST {
    long ARTIKEL_NR;
    long DATUMGUELTIGAB;
    double GROSSO;
    double AEP;
    double AVP;
    long FETCH_REL;
};
/* Structur with real chartype of PROMOANZ ************************************/

struct C_PROMOANZ {
    short PROMOTION_NO;
    char NAME[31];
    char DESCRIPTION[41];
    short PROMOTION_TYPE;
};
/* Structur with real chartype of REIMPORT ************************************/

struct C_REIMPORT {
    char DARREICHFORM[4];
    double PREISEKAPO;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long BESTAND;
    long PZN;
    long FETCH_REL;
};
/* Structur with real chartype of STELLER *************************************/

struct C_STELLER {
    long ARTICLE_NO_PACK;
    long ARTICLE_NO_ELEMENT;
    long QUANTITY;
    short FILIALNR;
    long BESTAND;
    char DARREICHFORM[4];
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    char ARTIKEL_LANGNAME[51];
    long FETCH_REL;
};
/* Structur with real chartype of STELLERTYP **********************************/

struct C_STELLERTYP {
    long ARTICLE_NO_PACK;
    long DATEFROM;
    long DATETO;
    short COMPACK_TYPE;
};
/* Structur with real chartype of STOCKRESERVATION ****************************/

struct C_STOCKRESERVATION {
    short BRANCHNO;
    long CUSTOMERNO;
    char ARTICLE_CODE[26];
    long ARTICLENO;
    long RESERVEDQTY;
    long DATEFROM;
    long TIMEFROM;
    long DATETO;
    long TIMETO;
    long KDAUFTRAGNR;
    short RESERVTYPE;
    long FETCH_REL;
};
/* Structur with real chartype of STOCKRESERVATIONARTICLERESERV ***************/

struct C_STOCKRESERVATIONARTICLERESERV {
    short BRANCHNO;
    char PHARMACYGROUPID[4];
    long ARTICLENO;
    short RESERVTYPE;
    long MAXQTY;
    long RESERVEDQTY;
    long FETCH_REL;
};
/* Structur with real chartype of STOCKRESERVATIONARTIKELLOKAL ****************/

struct C_STOCKRESERVATIONARTIKELLOKAL {
    short FILIALNR;
    long ARTIKEL_NR;
    long BESTAND;
    short LAGERBEREICHNR;
    char STATIONNR[3];
    char LAGERFACHNR[11];
    long FETCH_REL;
};
/* Structur with real chartype of STOCKRESERVATIONIBTREQUEST ******************/

struct C_STOCKRESERVATIONIBTREQUEST {
    long IBTREQUESTID;
    short BRANCHNO;
    long CSCORDERNO;
    long CSCORDERPOSNO;
    long DATEFROM;
    short IBTBRANCHNO;
    long IBTCUSTOMERNO;
    long TIMEFROM;
    short PROCESSINGSTATE;
    long CUSTOMERNO;
    long ARTICLENO;
    long QUANTITY;
    long FETCH_REL;
};
/* Structur with real chartype of STOCKRESERVATIONNACHLIEFERPOS ***************/

struct C_STOCKRESERVATIONNACHLIEFERPOS {
    long KDAUFTRAGNR;
    long POSNR;
    long DATUM;
    short POSTYP;
    long IDFNR;
    long ARTIKEL_NR;
    long MENGE;
    long STATUS;
    long FETCH_REL;
};

/* Structur with real chartype of STOCKRESERVATIONORDER ***********************/

struct C_STOCKRESERVATIONORDER {
    long DATUM;
    long KDAUFTRAGNR;
    char KDAUFTRAGSTAT[17];
    long IDFNR;
    short FILIALNR;
    char KDAUFTRAGART[3];
    long KUNDENNR;
    char ZUGRUND[17];
    long FETCH_REL;
};

/* Structur with real chartype of SUPPLINFO ***********************************/

struct C_SUPPLINFO {
    long ARTICLENO;
    char AVAILABILITYINFO[255];
    long PROGLIEFERDATUM;
    long LIEFERDATUM;
    long FETCH_REL;
};
/* Structur with real chartype of DELAYEDART **********************************/

struct C_DELAYEDART {
    short BRANCHNO;
    char NARCOTIC;
    char COLDCHAIN;
    char COOL08;
    char COOL20;
    long FETCH_REL;
};
/* Structur with real chartype of DISCOUNTANZ *********************************/

struct C_DISCOUNTANZ {
    short BRANCHNO;
    long ARTICLENO;
    long DISCOUNTGRPNO;
    char PHARMACYGROUPID[4];
    long CUSTOMERNO;
    short GRPDISCOUNTTYP;
    long DATEFROM;
    long DATETO;
    long BASEQTY;
    short DISCOUNTSPEC;
    short DISCOUNTTYPE;
    short DISCOUNTQTY;
    double DISCOUNTVALUEPCT;
    short PREIS_TYP;
    double DISCOUNTQTYPCT;
    double SURCHARGEPCT;
    char PHARMGRPEXCLUDED[4];
    double FIXEDPRICE;
    double REFUNDPCT;
    char INTERNALDISCOUNT;
    long DISCOUNTARTICLE;
    char UPDATESIGN;
    double BASE_VALUE;
    long BASE_MULT_STD_QTY;
    char NO_MULTIPLE_QTY;
    double FIXEDDISCOUNTVALUE;
    long MANUFACTURERNO;
    long ARTCATEGORYNO;
    short PAYMENTTARGETNO;
    double GROSSPROFITPCT;
    char ADDONDISCOUNTOK;
    char PAYMENTTERMTYPE;
    long TARGETQTY;
    double EXCEEDANCEPCT;
    long ARTICLE_NO_PACK;
    double REFUNDVALUE;
    short PROMOTION_NO;
    short DISCOUNTAPPLYTO;
    short DISCOUNTCALCFROM;
    long FETCH_REL;
};
/* Structur with real chartype of STOCKENTRY **********************************/

struct C_STOCKENTRY {
    long DATE;
    short BRANCHNO;
    long ARTICLENO;
    long BESTAND;
    char EINHEIT[10];
    char ARTIKEL_NAME[31];
    long FETCH_REL;
};
#ifdef ESQL_C
EXEC SQL END DECLARE SECTION;
#endif

#ifdef ESQL_C
EXEC SQL BEGIN DECLARE SECTION;
#endif

/* Sizetype  Structur (buf_desc) of ARTBUYINGOPTIONS **************************/

struct I_ARTBUYINGOPTIONS {
    short ARTIKEL_NR;
    short ETARTKLASSE1;
    short KZPSYCHOSTOFFE;
};
/* Sizetype  Structur (buf_desc) of ARTCHARGE *********************************/

struct I_ARTCHARGE {
    short BRANCHNO;
    short ARTICLENO;
    short EXPIRYDATE;
    short CHARGENNR;
    short STOCK;
    short STATECHARGE;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTINFBG **********************************/

struct I_ARTINFBG {
    short ARTIKEL_NR;
    short HEALTHFUNDCODE;
    short ARTIKEL_LANGNAME;
};
/* Sizetype  Structur (buf_desc) of ARTINSERT *********************************/

struct I_ARTINSERT {
    short ARTICLENO;
    short ARTINFOTYPE;
    short SEQUENCENO;
    short INFOTEXT;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTLANGNAME *******************************/

struct I_ARTLANGNAME {
    short ARTIKEL_NR;
    short ARTIKEL_LANGNAME;
};
/* Sizetype  Structur (buf_desc) of ARTPRICE **********************************/

struct I_ARTPRICE {
    short ARTIKEL_NR;
    short PREISEKAPO;
    short PREISEKGROSSO;
    short PREIS_TYP;
};
/* Sizetype  Structur (buf_desc) of ARTPSYCHO *********************************/

struct I_ARTPSYCHO {
    short ARTIKEL_NR;
    short ETARTKLASSE1;
    short KZPSYCHOSTOFFE;
};
/* Sizetype  Structur (buf_desc) of ARTICLEAGENTGROUP *************************/

struct I_ARTICLEAGENTGROUP {
    short PREISEKAPO;
    short FILIALNR;
    short ARTIKEL_NR;
    short BESTAND;
    short DARREICHFORM;
    short EINHEIT;
    short ARTIKEL_NAME;
    short WIRKSTOFF_NR;
    short ARTIKEL_LANGNAME;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTICLELPPRREIMB **************************/

struct I_ARTICLELPPRREIMB {
    short ARTICLENO;
    short CODE_LPPR;
    short DATEFROM;
    short REIMBURSEMENT_VAL;
    short LPPR_DESC;
    short REIMBCALCFLAG;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTICLEQUOTADETAIL ************************/

struct I_ARTICLEQUOTADETAIL {
    short BRANCHNO;
    short CUSTOMERNO;
    short ARTICLENO;
    short QUOTA;
    short VALIDITY;
    short KZKDKLASSE;
    short EINHEIT;
    short ARTIKEL_NAME;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTICLEQUOTAEKG ***************************/

struct I_ARTICLEQUOTAEKG {
    short BRANCHNO;
    short GROUP_NAME;
    short ARTICLENO;
    short QUOTA;
    short KUMQTY;
    short VALIDITY;
    short DATEUPDATE;
    short UID_ANLAGE;
    short DATEFROM;
    short DATETO;
    short PHARMACYGROUPID;
    short SNOBATCHCHANGE;
    short EINHEIT;
    short ARTIKEL_NAME;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTICLETAX ********************************/

struct I_ARTICLETAX {
    short SALESTAXRATE;
    short ARTIKEL_NR;
};
/* Sizetype  Structur (buf_desc) of ARTIKELLPPR *******************************/

struct I_ARTIKELLPPR {
    short ARTICLENO;
    short REIMBURSEMENT_TYPE;
    short REIMBURSEMENTPRICE;
    short CODE_LPPR;
    short REIMBURSEMENT_PERC;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTIKELQUOTA ******************************/

struct I_ARTIKELQUOTA {
    short BRANCHNO;
    short CUSTOMERNO;
    short MATCHCODE;
    short ARTICLENO;
    short QUOTA;
    short KUMQTY;
    short VALIDITY;
    short DATEUPDATE;
    short UID_ANLAGE;
    short SDAFUEQUOTA;
    short DATEFROM;
    short DATETO;
    short PHARMACYGROUPID;
    short SNOBATCHCHANGE;
    short QUOTAINHERITANCE;
    short EINHEIT;
    short ARTIKEL_NAME;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTIKELQUOTAPF ****************************/

struct I_ARTIKELQUOTAPF {
    short BRANCHNO;
    short CUSTOMERNO;
    short ARTICLENO;
    short QUOTA;
    short KUMQTY;
    short VALIDITY;
    short DATEUPDATE;
    short UID_ANLAGE;
    short SDAFUEQUOTA;
    short DATEFROM;
    short DATETO;
    short SNOBATCHCHANGE;
    short KZKDKLASSE;
    short WERT;
};
/* Sizetype  Structur (buf_desc) of ARTIKELRESERVE ****************************/

struct I_ARTIKELRESERVE {
    short BRANCHNO;
    short CUSTOMERNO;
    short PHARMACYGROUPID;
    short ARTICLENO;
    short RESERVTYPE;
    short MAXQTY;
    short RESERVEDQTY;
    short RESERVEPCT;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of ARTIKELTEXT *******************************/

struct I_ARTIKELTEXT {
    short BRANCHNO;
    short TEXTKEY;
    short TEXT;
    short DISPLAYONSCREEN;
    short TEXTHOSPITAL;
};
/* Sizetype  Structur (buf_desc) of ARTIKELVERFALL ****************************/

struct I_ARTIKELVERFALL {
    short FILIALNR;
    short ARTIKEL_NR;
    short DATUMVERFALL;
};
/* Sizetype  Structur (buf_desc) of ATICLEAUX *********************************/

struct I_ATICLEAUX {
    short BRANCHNO;
    short ARTICLENO;
    short RANKING;
    short AUXBRANCHNO;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of CCODE *************************************/

struct I_CCODE {
    short BRANCHNO;
    short INFOCODE;
    short ARTICLEACTIV;
    short AUXDELIVERY;
    short SERACODE;
    short PRINTCODE;
    short XMLCODE;
    short XMLTEXT;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of CHECKIMEXBLOCKEXIST ***********************/

struct I_CHECKIMEXBLOCKEXIST {
    short ARTICLENO;
};
/* Sizetype  Structur (buf_desc) of CHECKIMPORTARTICLE ************************/

struct I_CHECKIMPORTARTICLE {
    short ARTIKEL_NR;
    short IMPORTARTICLE;
};
/* Sizetype  Structur (buf_desc) of CHECKLISTE5ZENTRAL ************************/

struct I_CHECKLISTE5ZENTRAL {
    short ARTIKEL_NR;
};
/* Sizetype  Structur (buf_desc) of CODEBLOCAGEINFO ***************************/

struct I_CODEBLOCAGEINFO {
    short PRINTCODE;
    short FILIALNR;
    short ARTIKEL_NR;
};
/* Sizetype  Structur (buf_desc) of DISPOINFO *********************************/

struct I_DISPOINFO {
    short BEZEICHNUNG;
    short DISPO_HINWEIS;
    short BEMERKUNG;
    short PZN;
    short ARTIKEL_NR;
    short HERSTELLER_NR;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of HERSTELLER ********************************/

struct I_HERSTELLER {
    short NAME;
    short ARTIKEL_NR;
};
/* Sizetype  Structur (buf_desc) of LPPRCODE **********************************/

struct I_LPPRCODE {
    short CODE_LPPR;
    short REIMBURSEMENT_VAL;
};
/* Sizetype  Structur (buf_desc) of MAXARTICLEQUOTA ***************************/

struct I_MAXARTICLEQUOTA {
    short ARTICLENO;
    short MAXQUOTA;
};
/* Sizetype  Structur (buf_desc) of OCCASION **********************************/

struct I_OCCASION {
    short CUSTOMERNO;
    short ARTICLENO;
    short BRANCHNO;
    short DISCOUNTVALUEPCT;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of PHARMGRP **********************************/

struct I_PHARMGRP {
    short PHARMACYGROUPID;
    short GROUP_NAME;
    short GROUP_TYPE;
    short PERCENT;
    short CONTRIBUTION;
    short CUSTOMERNO;
    short OMG_OWN_CONT;
    short PRICE_BASIS_PURCH;
    short RECLAIM_OMG_DISC;
    short SPECIALGROUP;
    short SPECIALGROUPREFNO;
    short GROUPING_VIS;
    short BRANCHNO;
};
/* Sizetype  Structur (buf_desc) of PREISANZTYP *******************************/

struct I_PREISANZTYP {
    short ARTIKEL_NR;
    short PREISEKAPO;
    short PREISEKGROSSO;
    short PREISEKGROSSONA;
    short PREIS_TYP;
};
/* Sizetype  Structur (buf_desc) of PRICEHIST *********************************/

struct I_PRICEHIST {
    short ARTIKEL_NR;
    short DATUMGUELTIGAB;
    short GROSSO;
    short AEP;
    short AVP;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of PROMOANZ **********************************/

struct I_PROMOANZ {
    short PROMOTION_NO;
    short NAME;
    short DESCRIPTION;
    short PROMOTION_TYPE;
};
/* Sizetype  Structur (buf_desc) of REIMPORT **********************************/

struct I_REIMPORT {
    short DARREICHFORM;
    short PREISEKAPO;
    short EINHEIT;
    short ARTIKEL_NAME;
    short BESTAND;
    short PZN;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STELLER ***********************************/

struct I_STELLER {
    short ARTICLE_NO_PACK;
    short ARTICLE_NO_ELEMENT;
    short QUANTITY;
    short FILIALNR;
    short BESTAND;
    short DARREICHFORM;
    short EINHEIT;
    short ARTIKEL_NAME;
    short ARTIKEL_LANGNAME;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STELLERTYP ********************************/

struct I_STELLERTYP {
    short ARTICLE_NO_PACK;
    short DATEFROM;
    short DATETO;
    short COMPACK_TYPE;
};
/* Sizetype  Structur (buf_desc) of STOCKRESERVATION **************************/

struct I_STOCKRESERVATION {
    short BRANCHNO;
    short CUSTOMERNO;
    short ARTICLE_CODE;
    short ARTICLENO;
    short RESERVEDQTY;
    short DATEFROM;
    short TIMEFROM;
    short DATETO;
    short TIMETO;
    short KDAUFTRAGNR;
    short RESERVTYPE;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STOCKRESERVATIONARTICLERESERV *************/

struct I_STOCKRESERVATIONARTICLERESERV {
    short BRANCHNO;
    short PHARMACYGROUPID;
    short ARTICLENO;
    short RESERVTYPE;
    short MAXQTY;
    short RESERVEDQTY;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STOCKRESERVATIONARTIKELLOKAL **************/

struct I_STOCKRESERVATIONARTIKELLOKAL {
    short FILIALNR;
    short ARTIKEL_NR;
    short BESTAND;
    short LAGERBEREICHNR;
    short STATIONNR;
    short LAGERFACHNR;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STOCKRESERVATIONIBTREQUEST ****************/

struct I_STOCKRESERVATIONIBTREQUEST {
    short IBTREQUESTID;
    short BRANCHNO;
    short CSCORDERNO;
    short CSCORDERPOSNO;
    short DATEFROM;
    short IBTBRANCHNO;
    short IBTCUSTOMERNO;
    short TIMEFROM;
    short PROCESSINGSTATE;
    short CUSTOMERNO;
    short ARTICLENO;
    short QUANTITY;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STOCKRESERVATIONNACHLIEFERPOS *************/

struct I_STOCKRESERVATIONNACHLIEFERPOS {
    short KDAUFTRAGNR;
    short POSNR;
    short DATUM;
    short POSTYP;
    short IDFNR;
    short ARTIKEL_NR;
    short MENGE;
    short STATUS;
    short FETCH_REL;
};

/* Sizetype  Structur (buf_desc) of STOCKRESERVATIONORDER *********************/

struct I_STOCKRESERVATIONORDER {
    short DATUM;
    short KDAUFTRAGNR;
    short KDAUFTRAGSTAT;
    short IDFNR;
    short FILIALNR;
    short KDAUFTRAGART;
    short KUNDENNR;
    short ZUGRUND;
    short FETCH_REL;
};

/* Sizetype  Structur (buf_desc) of SUPPLINFO *********************************/

struct I_SUPPLINFO {
    short ARTICLENO;
    short AVAILABILITYINFO;
    short PROGLIEFERDATUM;
    short LIEFERDATUM;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of DELAYEDART ********************************/

struct I_DELAYEDART {
    short BRANCHNO;
    short NARCOTIC;
    short COLDCHAIN;
    short COOL08;
    short COOL20;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of DISCOUNTANZ *******************************/

struct I_DISCOUNTANZ {
    short BRANCHNO;
    short ARTICLENO;
    short DISCOUNTGRPNO;
    short PHARMACYGROUPID;
    short CUSTOMERNO;
    short GRPDISCOUNTTYP;
    short DATEFROM;
    short DATETO;
    short BASEQTY;
    short DISCOUNTSPEC;
    short DISCOUNTTYPE;
    short DISCOUNTQTY;
    short DISCOUNTVALUEPCT;
    short PREIS_TYP;
    short DISCOUNTQTYPCT;
    short SURCHARGEPCT;
    short PHARMGRPEXCLUDED;
    short FIXEDPRICE;
    short REFUNDPCT;
    short INTERNALDISCOUNT;
    short DISCOUNTARTICLE;
    short UPDATESIGN;
    short BASE_VALUE;
    short BASE_MULT_STD_QTY;
    short NO_MULTIPLE_QTY;
    short FIXEDDISCOUNTVALUE;
    short MANUFACTURERNO;
    short ARTCATEGORYNO;
    short PAYMENTTARGETNO;
    short GROSSPROFITPCT;
    short ADDONDISCOUNTOK;
    short PAYMENTTERMTYPE;
    short TARGETQTY;
    short EXCEEDANCEPCT;
    short ARTICLE_NO_PACK;
    short REFUNDVALUE;
    short PROMOTION_NO;
    short DISCOUNTAPPLYTO;
    short DISCOUNTCALCFROM;
    short FETCH_REL;
};
/* Sizetype  Structur (buf_desc) of STOCKENTRY ********************************/

struct I_STOCKENTRY {
    short DATE;
    short BRANCHNO;
    short ARTICLENO;
    short BESTAND;
    short EINHEIT;
    short ARTIKEL_NAME;
    short FETCH_REL;
};
#ifdef ESQL_C
EXEC SQL END DECLARE SECTION;
#endif

/* structures of Buf_Desc *****************************************************/

/* Structur (buf_desc) of ARTBUYINGOPTIONS ************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTBUYINGOPTIONS_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L ,  11, 0 },
   { TYP_C, 1, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTBUYINGOPTIONS_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L ,  11, 0 },
   { TYP_C, 1, 0 },
};
#endif

/* Structur (buf_desc) of ARTCHARGE *******************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTCHARGE_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 25, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTCHARGE_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 25, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTINFBG ********************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTINFBG_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 5, 0 },
   { TYP_C, 50, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTINFBG_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 5, 0 },
   { TYP_C, 50, 0 },
};
#endif

/* Structur (buf_desc) of ARTINSERT *******************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTINSERT_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 256, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTINSERT_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 256, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTLANGNAME *****************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTLANGNAME_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 50, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTLANGNAME_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 50, 0 },
};
#endif

/* Structur (buf_desc) of ARTPRICE ********************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTPRICE_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTPRICE_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
};
#endif

/* Structur (buf_desc) of ARTPSYCHO *******************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTPSYCHO_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L ,  11, 0 },
   { TYP_C, 1, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTPSYCHO_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L ,  11, 0 },
   { TYP_C, 1, 0 },
};
#endif

/* Structur (buf_desc) of ARTICLEAGENTGROUP ***********************************/

#if defined (BUF_DESC)
static struct buf_desc ARTICLEAGENTGROUP_BES [] = {
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 50, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTICLEAGENTGROUP_BES [] = {
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 50, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTICLELPPRREIMB ************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTICLELPPRREIMB_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 15, 0 },
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_C, 400, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTICLELPPRREIMB_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 15, 0 },
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_C, 400, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTICLEQUOTADETAIL **********************************/

#if defined (BUF_DESC)
static struct buf_desc ARTICLEQUOTADETAIL_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTICLEQUOTADETAIL_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTICLEQUOTAEKG *************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTICLEQUOTAEKG_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTICLEQUOTAEKG_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTICLETAX ******************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTICLETAX_BES [] = {
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTICLETAX_BES [] = {
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTIKELLPPR *****************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTIKELLPPR_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 9, 3 },
   { TYP_C, 15, 0 },
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTIKELLPPR_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 9, 3 },
   { TYP_C, 15, 0 },
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTIKELQUOTA ****************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTIKELQUOTA_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 12, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 1, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTIKELQUOTA_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 12, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 1, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTIKELQUOTAPF **************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTIKELQUOTAPF_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTIKELQUOTAPF_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTIKELRESERVE **************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTIKELRESERVE_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTIKELRESERVE_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ARTIKELTEXT *****************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTIKELTEXT_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 240, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 480, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTIKELTEXT_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 240, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 480, 0 },
};
#endif

/* Structur (buf_desc) of ARTIKELVERFALL **************************************/

#if defined (BUF_DESC)
static struct buf_desc ARTIKELVERFALL_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ARTIKELVERFALL_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of ATICLEAUX *******************************************/

#if defined (BUF_DESC)
static struct buf_desc ATICLEAUX_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc ATICLEAUX_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of CCODE ***********************************************/

#if defined (BUF_DESC)
static struct buf_desc CCODE_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 2, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 20, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 5, 0 },
   { TYP_C, 100, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc CCODE_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 2, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 20, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 5, 0 },
   { TYP_C, 100, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of CHECKIMEXBLOCKEXIST *********************************/

#if defined (BUF_DESC)
static struct buf_desc CHECKIMEXBLOCKEXIST_BES [] = {
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc CHECKIMEXBLOCKEXIST_BES [] = {
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of CHECKIMPORTARTICLE **********************************/

#if defined (BUF_DESC)
static struct buf_desc CHECKIMPORTARTICLE_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc CHECKIMPORTARTICLE_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
};
#endif

/* Structur (buf_desc) of CHECKLISTE5ZENTRAL **********************************/

#if defined (BUF_DESC)
static struct buf_desc CHECKLISTE5ZENTRAL_BES [] = {
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc CHECKLISTE5ZENTRAL_BES [] = {
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of CODEBLOCAGEINFO *************************************/

#if defined (BUF_DESC)
static struct buf_desc CODEBLOCAGEINFO_BES [] = {
   { TYP_C, 30, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc CODEBLOCAGEINFO_BES [] = {
   { TYP_C, 30, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of DISPOINFO *******************************************/

#if defined (BUF_DESC)
static struct buf_desc DISPOINFO_BES [] = {
   { TYP_C, 30, 0 },
   { TYP_C, 240, 0 },
   { TYP_C, 240, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc DISPOINFO_BES [] = {
   { TYP_C, 30, 0 },
   { TYP_C, 240, 0 },
   { TYP_C, 240, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of HERSTELLER ******************************************/

#if defined (BUF_DESC)
static struct buf_desc HERSTELLER_BES [] = {
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc HERSTELLER_BES [] = {
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of LPPRCODE ********************************************/

#if defined (BUF_DESC)
static struct buf_desc LPPRCODE_BES [] = {
   { TYP_C, 15, 0 },
   { TYP_D, 9, 2 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc LPPRCODE_BES [] = {
   { TYP_C, 15, 0 },
   { TYP_D, 9, 2 },
};
#endif

/* Structur (buf_desc) of MAXARTICLEQUOTA *************************************/

#if defined (BUF_DESC)
static struct buf_desc MAXARTICLEQUOTA_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc MAXARTICLEQUOTA_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of OCCASION ********************************************/

#if defined (BUF_DESC)
static struct buf_desc OCCASION_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc OCCASION_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of PHARMGRP ********************************************/

#if defined (BUF_DESC)
static struct buf_desc PHARMGRP_BES [] = {
   { TYP_C, 3, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 5, 2 },
   { TYP_D, 3, 2 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc PHARMGRP_BES [] = {
   { TYP_C, 3, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 5, 2 },
   { TYP_D, 3, 2 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
};
#endif

/* Structur (buf_desc) of PREISANZTYP *****************************************/

#if defined (BUF_DESC)
static struct buf_desc PREISANZTYP_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc PREISANZTYP_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
};
#endif

/* Structur (buf_desc) of PRICEHIST *******************************************/

#if defined (BUF_DESC)
static struct buf_desc PRICEHIST_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc PRICEHIST_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_D, 9, 2 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of PROMOANZ ********************************************/

#if defined (BUF_DESC)
static struct buf_desc PROMOANZ_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 40, 0 },
   { TYP_S ,  6, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc PROMOANZ_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 40, 0 },
   { TYP_S ,  6, 0 },
};
#endif

/* Structur (buf_desc) of REIMPORT ********************************************/

#if defined (BUF_DESC)
static struct buf_desc REIMPORT_BES [] = {
   { TYP_C, 3, 0 },
   { TYP_D, 9, 2 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc REIMPORT_BES [] = {
   { TYP_C, 3, 0 },
   { TYP_D, 9, 2 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STELLER *********************************************/

#if defined (BUF_DESC)
static struct buf_desc STELLER_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 50, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STELLER_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_C, 50, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STELLERTYP ******************************************/

#if defined (BUF_DESC)
static struct buf_desc STELLERTYP_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STELLERTYP_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
};
#endif

/* Structur (buf_desc) of STOCKRESERVATION ************************************/

#if defined (BUF_DESC)
static struct buf_desc STOCKRESERVATION_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 25, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKRESERVATION_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 25, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STOCKRESERVATIONARTICLERESERV ***********************/

#if defined (BUF_DESC)
static struct buf_desc STOCKRESERVATIONARTICLERESERV_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKRESERVATIONARTICLERESERV_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STOCKRESERVATIONARTIKELLOKAL ************************/

#if defined (BUF_DESC)
static struct buf_desc STOCKRESERVATIONARTIKELLOKAL_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 2, 0 },
   { TYP_C, 10, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKRESERVATIONARTIKELLOKAL_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 2, 0 },
   { TYP_C, 10, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STOCKRESERVATIONIBTREQUEST **************************/

#if defined (BUF_DESC)
static struct buf_desc STOCKRESERVATIONIBTREQUEST_BES[] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKRESERVATIONIBTREQUEST_BES[] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STOCKRESERVATIONNACHLIEFERPOS ***********************/

#if defined (BUF_DESC)
static struct buf_desc STOCKRESERVATIONNACHLIEFERPOS_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKRESERVATIONNACHLIEFERPOS_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STOCKRESERVATIONORDER *******************************/

#if defined (BUF_DESC)
static struct buf_desc STOCKRESERVATIONORDER_BES[] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 16, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 2, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 16, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKRESERVATIONORDER_BES[] = {
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 16, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_C, 2, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 16, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of SUPPLINFO *******************************************/

#if defined (BUF_DESC)
static struct buf_desc SUPPLINFO_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 254, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc SUPPLINFO_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_C, 254, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of DELAYEDART ******************************************/

#if defined (BUF_DESC)
static struct buf_desc DELAYEDART_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc DELAYEDART_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of DISCOUNTANZ *****************************************/

#if defined (BUF_DESC)
static struct buf_desc DISCOUNTANZ_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_D, 5, 2 },
   { TYP_C, 3, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 5, 2 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 10, 2 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 9, 2 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc DISCOUNTANZ_BES [] = {
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 3, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_D, 5, 2 },
   { TYP_C, 3, 0 },
   { TYP_D, 9, 2 },
   { TYP_D, 5, 2 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 10, 2 },
   { TYP_L , 11, 0 },
   { TYP_C, 1, 0 },
   { TYP_D, 9, 2 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_D, 5, 2 },
   { TYP_C, 1, 0 },
   { TYP_C, 1, 0 },
   { TYP_L , 11, 0 },
   { TYP_D, 5, 2 },
   { TYP_L , 11, 0 },
   { TYP_D, 9, 2 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* Structur (buf_desc) of STOCKENTRY ******************************************/

#if defined (BUF_DESC)
static struct buf_desc STOCKENTRY_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#elif defined (C_BUF_DESC)
static struct buf_desc STOCKENTRY_BES [] = {
   { TYP_L , 11, 0 },
   { TYP_S ,  6, 0 },
   { TYP_L , 11, 0 },
   { TYP_L , 11, 0 },
   { TYP_C, 9, 0 },
   { TYP_C, 30, 0 },
   { TYP_L , 11, 0 },
};
#endif

/* description for datatypes of STOCKRESERVATION ******************************/

 #define STOCKRESERVATION_S390 \
         short BRANCHNO; \
         long CUSTOMERNO; \
         char ARTICLE_CODE[26]; \
         long ARTICLENO; \
         long RESERVEDQTY; \
         long DATEFROM; \
         long TIMEFROM; \
         long DATETO; \
         long TIMETO; \
         long KDAUFTRAGNR; \
         short RESERVTYPE; \
         long FETCH_REL;


/* description for datatypes of STOCKRESERVATIONARTICLERESERV *****************/

 #define STOCKRESERVATIONARTICLERESERV_S390 \
         short BRANCHNO; \
         char PHARMACYGROUPID[4]; \
         long ARTICLENO; \
         short RESERVTYPE; \
         long MAXQTY; \
         long RESERVEDQTY; \
         long FETCH_REL;


/* description for datatypes of STOCKRESERVATIONARTIKELLOKAL ******************/

 #define STOCKRESERVATIONARTIKELLOKAL_S390 \
         short FILIALNR; \
         long ARTIKEL_NR; \
         long BESTAND; \
         short LAGERBEREICHNR; \
         char STATIONNR[3]; \
         char LAGERFACHNR[11]; \
         long FETCH_REL;


/* description for datatypes of STOCKRESERVATIONIBTREQUEST ********************/

#define STOCKRESERVATIONIBTREQUEST_S390 \
         long IBTREQUESTID; \
         short BRANCHNO; \
         long CSCORDERNO; \
         long CSCORDERPOSNO; \
         long DATEFROM; \
         short IBTBRANCHNO; \
         long IBTCUSTOMERNO; \
         long TIMEFROM; \
         short PROCESSINGSTATE; \
         long CUSTOMERNO; \
         long ARTICLENO; \
         long QUANTITY; \
         long FETCH_REL;


/* description for datatypes of STOCKRESERVATIONNACHLIEFERPOS *****************/

 #define STOCKRESERVATIONNACHLIEFERPOS_S390 \
         long KDAUFTRAGNR; \
         long POSNR; \
         long DATUM; \
         short POSTYP; \
         long IDFNR; \
         long ARTIKEL_NR; \
         long MENGE; \
         long STATUS; \
         long FETCH_REL;


/* description for datatypes of STOCKRESERVATIONORDER *************************/

#define STOCKRESERVATIONORDER_S390 \
         long DATUM; \
         long KDAUFTRAGNR; \
         char KDAUFTRAGSTAT[17]; \
         long IDFNR; \
         short FILIALNR; \
         char KDAUFTRAGART[3]; \
         long KUNDENNR; \
         char ZUGRUND[17]; \
         long FETCH_REL;


/* Copy-Function Struct to single Data STOCKRESERVATION ***********************/

 #define STOCKRESERVATION_S390_COPY_TO_SINGLE(_x_) \
         BRANCHNO=_x_->BRANCHNO;\
         CUSTOMERNO=_x_->CUSTOMERNO;\
          strcpy(ARTICLE_CODE,_x_->ARTICLE_CODE);\
         ARTICLENO=_x_->ARTICLENO;\
         RESERVEDQTY=_x_->RESERVEDQTY;\
         DATEFROM=_x_->DATEFROM;\
         TIMEFROM=_x_->TIMEFROM;\
         DATETO=_x_->DATETO;\
         TIMETO=_x_->TIMETO;\
         KDAUFTRAGNR=_x_->KDAUFTRAGNR;\
         RESERVTYPE=_x_->RESERVTYPE;\
          FETCH_REL=_x_->FETCH_REL;\

 #define STOCKRESERVATION_S390_COPY_TO_STRUCT(_x_) \
          _x_->BRANCHNO=BRANCHNO;\
          _x_->CUSTOMERNO=CUSTOMERNO;\
          strcpy(_x_->ARTICLE_CODE,ARTICLE_CODE);\
          _x_->ARTICLENO=ARTICLENO;\
          _x_->RESERVEDQTY=RESERVEDQTY;\
          _x_->DATEFROM=DATEFROM;\
          _x_->TIMEFROM=TIMEFROM;\
          _x_->DATETO=DATETO;\
          _x_->TIMETO=TIMETO;\
          _x_->KDAUFTRAGNR=KDAUFTRAGNR;\
          _x_->RESERVTYPE=RESERVTYPE;\
          _x_->FETCH_REL=FETCH_REL;\


/* Copy-Function Struct to single Data STOCKRESERVATIONARTICLERESERV **********/

 #define STOCKRESERVATIONARTICLERESERV_S390_COPY_TO_SINGLE(_x_) \
         BRANCHNO=_x_->BRANCHNO;\
          strcpy(PHARMACYGROUPID,_x_->PHARMACYGROUPID);\
         ARTICLENO=_x_->ARTICLENO;\
         RESERVTYPE=_x_->RESERVTYPE;\
         MAXQTY=_x_->MAXQTY;\
         RESERVEDQTY=_x_->RESERVEDQTY;\
          FETCH_REL=_x_->FETCH_REL;\

 #define STOCKRESERVATIONARTICLERESERV_S390_COPY_TO_STRUCT(_x_) \
          _x_->BRANCHNO=BRANCHNO;\
          strcpy(_x_->PHARMACYGROUPID,PHARMACYGROUPID);\
          _x_->ARTICLENO=ARTICLENO;\
          _x_->RESERVTYPE=RESERVTYPE;\
          _x_->MAXQTY=MAXQTY;\
          _x_->RESERVEDQTY=RESERVEDQTY;\
          _x_->FETCH_REL=FETCH_REL;\


/* Copy-Function Struct to single Data STOCKRESERVATIONARTIKELLOKAL ***********/

 #define STOCKRESERVATIONARTIKELLOKAL_S390_COPY_TO_SINGLE(_x_) \
         FILIALNR=_x_->FILIALNR;\
         ARTIKEL_NR=_x_->ARTIKEL_NR;\
         BESTAND=_x_->BESTAND;\
         LAGERBEREICHNR=_x_->LAGERBEREICHNR;\
          strcpy(STATIONNR,_x_->STATIONNR);\
          strcpy(LAGERFACHNR,_x_->LAGERFACHNR);\
          FETCH_REL=_x_->FETCH_REL;\

 #define STOCKRESERVATIONARTIKELLOKAL_S390_COPY_TO_STRUCT(_x_) \
          _x_->FILIALNR=FILIALNR;\
          _x_->ARTIKEL_NR=ARTIKEL_NR;\
          _x_->BESTAND=BESTAND;\
          _x_->LAGERBEREICHNR=LAGERBEREICHNR;\
          strcpy(_x_->STATIONNR,STATIONNR);\
          strcpy(_x_->LAGERFACHNR,LAGERFACHNR);\
          _x_->FETCH_REL=FETCH_REL;\


/* Copy-Function Struct to single Data STOCKRESERVATIONIBTREQUEST *************/

#define STOCKRESERVATIONIBTREQUEST_S390_COPY_TO_SINGLE(_x_) \
         IBTREQUESTID=_x_->IBTREQUESTID;\
         BRANCHNO=_x_->BRANCHNO;\
         CSCORDERNO=_x_->CSCORDERNO;\
         CSCORDERPOSNO=_x_->CSCORDERPOSNO;\
         DATEFROM=_x_->DATEFROM;\
         IBTBRANCHNO=_x_->IBTBRANCHNO;\
         IBTCUSTOMERNO=_x_->IBTCUSTOMERNO;\
         TIMEFROM=_x_->TIMEFROM;\
         PROCESSINGSTATE=_x_->PROCESSINGSTATE;\
         CUSTOMERNO=_x_->CUSTOMERNO;\
         ARTICLENO=_x_->ARTICLENO;\
         QUANTITY=_x_->QUANTITY;\
          FETCH_REL=_x_->FETCH_REL;\

#define STOCKRESERVATIONIBTREQUEST_S390_COPY_TO_STRUCT(_x_) \
          _x_->IBTREQUESTID=IBTREQUESTID;\
          _x_->BRANCHNO=BRANCHNO;\
          _x_->CSCORDERNO=CSCORDERNO;\
          _x_->CSCORDERPOSNO=CSCORDERPOSNO;\
          _x_->DATEFROM=DATEFROM;\
          _x_->IBTBRANCHNO=IBTBRANCHNO;\
          _x_->IBTCUSTOMERNO=IBTCUSTOMERNO;\
          _x_->TIMEFROM=TIMEFROM;\
          _x_->PROCESSINGSTATE=PROCESSINGSTATE;\
          _x_->CUSTOMERNO=CUSTOMERNO;\
          _x_->ARTICLENO=ARTICLENO;\
          _x_->QUANTITY=QUANTITY;\
          _x_->FETCH_REL=FETCH_REL;\


/* Copy-Function Struct to single Data STOCKRESERVATIONNACHLIEFERPOS **********/

 #define STOCKRESERVATIONNACHLIEFERPOS_S390_COPY_TO_SINGLE(_x_) \
         KDAUFTRAGNR=_x_->KDAUFTRAGNR;\
         POSNR=_x_->POSNR;\
         DATUM=_x_->DATUM;\
         POSTYP=_x_->POSTYP;\
         IDFNR=_x_->IDFNR;\
         ARTIKEL_NR=_x_->ARTIKEL_NR;\
         MENGE=_x_->MENGE;\
         STATUS=_x_->STATUS;\
          FETCH_REL=_x_->FETCH_REL;\

 #define STOCKRESERVATIONNACHLIEFERPOS_S390_COPY_TO_STRUCT(_x_) \
          _x_->KDAUFTRAGNR=KDAUFTRAGNR;\
          _x_->POSNR=POSNR;\
          _x_->DATUM=DATUM;\
          _x_->POSTYP=POSTYP;\
          _x_->IDFNR=IDFNR;\
          _x_->ARTIKEL_NR=ARTIKEL_NR;\
          _x_->MENGE=MENGE;\
          _x_->STATUS=STATUS;\
          _x_->FETCH_REL=FETCH_REL;\


/* Copy-Function Struct to single Data STOCKRESERVATIONORDER ******************/

#define STOCKRESERVATIONORDER_S390_COPY_TO_SINGLE(_x_) \
         DATUM=_x_->DATUM;\
         KDAUFTRAGNR=_x_->KDAUFTRAGNR;\
          strcpy(KDAUFTRAGSTAT,_x_->KDAUFTRAGSTAT);\
         IDFNR=_x_->IDFNR;\
         FILIALNR=_x_->FILIALNR;\
          strcpy(KDAUFTRAGART,_x_->KDAUFTRAGART);\
         KUNDENNR=_x_->KUNDENNR;\
          strcpy(ZUGRUND,_x_->ZUGRUND);\
          FETCH_REL=_x_->FETCH_REL;\

#define STOCKRESERVATIONORDER_S390_COPY_TO_STRUCT(_x_) \
          _x_->DATUM=DATUM;\
          _x_->KDAUFTRAGNR=KDAUFTRAGNR;\
          strcpy(_x_->KDAUFTRAGSTAT,KDAUFTRAGSTAT);\
          _x_->IDFNR=IDFNR;\
          _x_->FILIALNR=FILIALNR;\
          strcpy(_x_->KDAUFTRAGART,KDAUFTRAGART);\
          _x_->KUNDENNR=KUNDENNR;\
          strcpy(_x_->ZUGRUND,ZUGRUND);\
          _x_->FETCH_REL=FETCH_REL;\

/* FunctionNumber-Define of ArtBuyingOptions **********************************/

#define ARTBUYINGOPTIONS_SELBUYINGOPTIONS 1747

/* FunctionNumber-Define of ArtCharge *****************************************/

#define ARTCHARGE_SELLIST 1527
#define ARTCHARGE_SELLISTQUA 1592

/* FunctionNumber-Define of ArtInfBG ******************************************/

#define ARTINFBG_SELARTINFBG 1552

/* FunctionNumber-Define of ArtInsert *****************************************/

#define ARTINSERT_DELETE 1500
#define ARTINSERT_INSERT 1499
#define ARTINSERT_SELBEILAGE 1498

/* FunctionNumber-Define of ArtLangName ***************************************/

#define ARTLANGNAME_SELLANGNAME 1515

/* FunctionNumber-Define of ArtPrice ******************************************/

#define ARTPRICE_SELPRICE 1583

/* FunctionNumber-Define of ArtPsycho *****************************************/

#define ARTPSYCHO_SELARTICLE 1574

/* FunctionNumber-Define of ArticleAgentGroup *********************************/

#define ARTICLEAGENTGROUP_SELAGENT 1488
#define ARTICLEAGENTGROUP_SELARTIKEL 1497
#define ARTICLEAGENTGROUP_SELLIST 1487

/* FunctionNumber-Define of ArticleLpprReimb **********************************/

#define ARTICLELPPRREIMB_SELLISTART 1737

/* FunctionNumber-Define of ArticleQuotaDetail ********************************/

#define ARTICLEQUOTADETAIL_SELCOUNT 1479
#define ARTICLEQUOTADETAIL_SELKUMVZDETAIL 1478

/* FunctionNumber-Define of ArticleQuotaEKG ***********************************/

#define ARTICLEQUOTAEKG_DELETE 1473
#define ARTICLEQUOTAEKG_DELETEALLEKG 1474
#define ARTICLEQUOTAEKG_INSERT 1472
#define ARTICLEQUOTAEKG_SELARTICLE 1476
#define ARTICLEQUOTAEKG_SELLISTEKG 1475
#define ARTICLEQUOTAEKG_UPDATE 1471

/* FunctionNumber-Define of ArticleTax ****************************************/

#define ARTICLETAX_SELTAX 1409

/* FunctionNumber-Define of ArtikelLPPR ***************************************/

#define ARTIKELLPPR_SELLIST 1439

/* FunctionNumber-Define of ArtikelQuota **************************************/

#define ARTIKELQUOTA_CHECKQUOTA 1466
#define ARTIKELQUOTA_DELETE 1356
#define ARTIKELQUOTA_DELETEALLART 1358
#define ARTIKELQUOTA_DELETEALLKND 1357
#define ARTIKELQUOTA_INSERT 1355
#define ARTIKELQUOTA_SELKUMVZ 1365
#define ARTIKELQUOTA_SELLISTALLNOBAT 1557
#define ARTIKELQUOTA_SELLISTART 1354
#define ARTIKELQUOTA_SELLISTARTNOBAT 1555
#define ARTIKELQUOTA_SELLISTKND 1353
#define ARTIKELQUOTA_SELLISTKNDNOBAT 1556
#define ARTIKELQUOTA_SELQUOTA 1360
#define ARTIKELQUOTA_UPDATE 1359

/* FunctionNumber-Define of ArtikelQuotaPf ************************************/

#define ARTIKELQUOTAPF_COPYQUOTA 1404
#define ARTIKELQUOTAPF_DELETEKUNDEEKG 1779
#define ARTIKELQUOTAPF_INSERTKLASSE 1364
#define ARTIKELQUOTAPF_INSERTKLASSE09 1425
#define ARTIKELQUOTAPF_INSERTKUNDEEKG 1507
#define ARTIKELQUOTAPF_UPDATEKUNDEEKG 1508
#define ARTIKELQUOTAPF_UPDATEQUOTA 1374
#define ARTIKELQUOTAPF_UPDATEQUOTA09 1430

/* FunctionNumber-Define of ArtikelReserve ************************************/

#define ARTIKELRESERVE_DELETE 1397
#define ARTIKELRESERVE_INSERT 1396
#define ARTIKELRESERVE_INSERTBESTAND 1402
#define ARTIKELRESERVE_RESERVSTOCKABS 1483
#define ARTIKELRESERVE_SELART 1399
#define ARTIKELRESERVE_SELARTKND 1400
#define ARTIKELRESERVE_SELLISTBESTAND 1401
#define ARTIKELRESERVE_UPDATE 1398

/* FunctionNumber-Define of ArtikelText ***************************************/

#define ARTIKELTEXT_SELECT 1375

/* FunctionNumber-Define of ArtikelVerfall ************************************/

#define ARTIKELVERFALL_CHECKSHORTEXPIRY 1575

/* FunctionNumber-Define of AticleAux *****************************************/

#define ATICLEAUX_DELETE 1465
#define ATICLEAUX_INSERT 1464
#define ATICLEAUX_SELLIST 1462
#define ATICLEAUX_UPDATE 1463

/* FunctionNumber-Define of CCode *********************************************/

#define CCODE_DELETE 1427
#define CCODE_INSERT 1428
#define CCODE_SEL 1426
#define CCODE_UPDATE 1429

/* FunctionNumber-Define of CheckImexblockExist *******************************/

#define CHECKIMEXBLOCKEXIST_SELEXIST 1774

/* FunctionNumber-Define of CheckImportArticle ********************************/

#define CHECKIMPORTARTICLE_SELIMPORT 1778

/* FunctionNumber-Define of CheckListe5Zentral ********************************/

#define CHECKLISTE5ZENTRAL_ISLISTE5 1599

/* FunctionNumber-Define of CodeblocageInfo ***********************************/

#define CODEBLOCAGEINFO_SELTEXT 1441

/* FunctionNumber-Define of DispoInfo *****************************************/

#define DISPOINFO_SELDISPOINFO 1480

/* FunctionNumber-Define of Hersteller ****************************************/

#define HERSTELLER_SELHERSTELLER 1550

/* FunctionNumber-Define of LpprCode ******************************************/

#define LPPRCODE_SEL 1444

/* FunctionNumber-Define of MaxArticleQuota ***********************************/

#define MAXARTICLEQUOTA_SELMAX 1395

/* FunctionNumber-Define of Occasion ******************************************/

#define OCCASION_SELLIST 1496

/* FunctionNumber-Define of PharmGrp ******************************************/

#define PHARMGRP_SEL 1442

/* FunctionNumber-Define of PreisAnzTyp ***************************************/

#define PREISANZTYP_SELPREIS 1519

/* FunctionNumber-Define of PriceHist *****************************************/

#define PRICEHIST_SEL 1443

/* FunctionNumber-Define of PromoAnz ******************************************/

#define PROMOANZ_SELPROMO 1518

/* FunctionNumber-Define of REIMPORT ******************************************/

#define REIMPORT_SELAUSWAHL 1238

/* FunctionNumber-Define of Steller *******************************************/

#define STELLER_SELLIST 1501

/* FunctionNumber-Define of StellerTyp ****************************************/

#define STELLERTYP_SELTYP 1530

/* FunctionNumber-Define of StockReservation **********************************/
#define STOCKRESERVATION_SELLISTALL 1806
#define STOCKRESERVATION_DELETEENTRY 1797
#define STOCKRESERVATION_SELLIST 1619
#define STOCKRESERVATION_SELSUM 1618

/* FunctionNumber-Define of StockReservationArticleReserv *********************/

#define STOCKRESERVATIONARTICLERESERV_SELARTICLERESERVATION 1804
#define STOCKRESERVATIONARTICLERESERV_UPDATEARTICLERESERVATION 1805

/* FunctionNumber-Define of StockReservationArtikelLokal **********************/

#define STOCKRESERVATIONARTIKELLOKAL_SELARTIKELLOKAL 1801
#define STOCKRESERVATIONARTIKELLOKAL_UPDATEARTIKELLOKAL 1802

/* FunctionNumber-Define of StockReservationIBTRequest ************************/

#define STOCKRESERVATIONIBTREQUEST_SELIBTREQUEST 1803

/* FunctionNumber-Define of StockReservationNachlieferPos *********************/

#define STOCKRESERVATIONNACHLIEFERPOS_DELETENACHLIEFERPOS 1800
#define STOCKRESERVATIONNACHLIEFERPOS_SELNACHLIEFERPOS 1799

/* FunctionNumber-Define of StockReservationOrder *****************************/

#define STOCKRESERVATIONORDER_SELORDER 1798

/* FunctionNumber-Define of StockReservedIBTRequest ***************************/


/* FunctionNumber-Define of SupplInfo *****************************************/

#define SUPPLINFO_SELSUPPINFO 1616

/* FunctionNumber-Define of delayedart ****************************************/

#define DELAYEDART_DELETE 1368
#define DELAYEDART_INSERT 1367
#define DELAYEDART_SEL 1366
#define DELAYEDART_UPDATE 1369

/* FunctionNumber-Define of discountanz ***************************************/

#define DISCOUNTANZ_SELLIST 1419
#define DISCOUNTANZ_SELLISTCST 1513
#define DISCOUNTANZ_SELLISTCSTEKG 1514
#define DISCOUNTANZ_SELLISTDG 1504
#define DISCOUNTANZ_SELLISTGRP 1420
#define DISCOUNTANZ_SELLISTGRPHERST 1503
#define DISCOUNTANZ_SELLISTHERST 1502
#define DISCOUNTANZ_SELLLISTGRPDG 1505

/* FunctionNumber-Define of stockentry ****************************************/

#define STOCKENTRY_SELLIST 1347

#ifdef PRZ_OLD_FUNCTION
/* Old-FunctionNumber-Define of ArtBuyingOptions ******************************/

#define SelBuyingOptions 1747

/* Old-FunctionNumber-Define of ArtCharge *************************************/

#define SelList 1527
#define SelListQua 1592

/* Old-FunctionNumber-Define of ArtInfBG **************************************/

#define SelArtInfBG 1552

/* Old-FunctionNumber-Define of ArtInsert *************************************/

#define Delete 1500
#define Insert 1499
#define SelBeilage 1498

/* Old-FunctionNumber-Define of ArtLangName ***********************************/

#define SelLangname 1515

/* Old-FunctionNumber-Define of ArtPrice **************************************/

#define SelPrice 1583

/* Old-FunctionNumber-Define of ArtPsycho *************************************/

#define SelArticle 1574

/* Old-FunctionNumber-Define of ArticleAgentGroup *****************************/

#define SelAgent 1488
#define SelArtikel 1497
#define SelList 1487

/* Old-FunctionNumber-Define of ArticleLpprReimb ******************************/

#define SelListArt 1737

/* Old-FunctionNumber-Define of ArticleQuotaDetail ****************************/

#define SelCount 1479
#define SelKumVzDetail 1478

/* Old-FunctionNumber-Define of ArticleQuotaEKG *******************************/

#define Delete 1473
#define DeleteAllEKG 1474
#define Insert 1472
#define SelArticle 1476
#define SelListEKG 1475
#define Update 1471

/* Old-FunctionNumber-Define of ArticleTax ************************************/

#define SelTax 1409

/* Old-FunctionNumber-Define of ArtikelLPPR ***********************************/

#define SelList 1439

/* Old-FunctionNumber-Define of ArtikelQuota **********************************/

#define CheckQuota 1466
#define Delete 1356
#define DeleteAllArt 1358
#define DeleteAllKnd 1357
#define Insert 1355
#define SelKumVz 1365
#define SelListAllNoBat 1557
#define SelListArt 1354
#define SelListArtNoBat 1555
#define SelListKnd 1353
#define SelListKndNoBat 1556
#define SelQuota 1360
#define Update 1359

/* Old-FunctionNumber-Define of ArtikelQuotaPf ********************************/

#define CopyQuota 1404
#define DeleteKundeEKG 1779
#define InsertKlasse 1364
#define InsertKlasse09 1425
#define InsertKundeEKG 1507
#define UpdateKundeEKG 1508
#define UpdateQuota 1374
#define UpdateQuota09 1430

/* Old-FunctionNumber-Define of ArtikelReserve ********************************/

#define Delete 1397
#define Insert 1396
#define InsertBestand 1402
#define ReservStockAbs 1483
#define SelArt 1399
#define SelArtKnd 1400
#define SelListBestand 1401
#define Update 1398

/* Old-FunctionNumber-Define of ArtikelText ***********************************/

#define Select 1375

/* Old-FunctionNumber-Define of ArtikelVerfall ********************************/

#define CheckShortExpiry 1575

/* Old-FunctionNumber-Define of AticleAux *************************************/

#define Delete 1465
#define Insert 1464
#define SelList 1462
#define Update 1463

/* Old-FunctionNumber-Define of CCode *****************************************/

#define Delete 1427
#define Insert 1428
#define Sel 1426
#define Update 1429

/* Old-FunctionNumber-Define of CheckImexblockExist ***************************/

#define SelExist 1774

/* Old-FunctionNumber-Define of CheckImportArticle ****************************/

#define SelImport 1778

/* Old-FunctionNumber-Define of CheckListe5Zentral ****************************/

#define IsListe5 1599

/* Old-FunctionNumber-Define of CodeblocageInfo *******************************/

#define SelText 1441

/* Old-FunctionNumber-Define of DispoInfo *************************************/

#define SelDispoInfo 1480

/* Old-FunctionNumber-Define of Hersteller ************************************/

#define SelHersteller 1550

/* Old-FunctionNumber-Define of LpprCode **************************************/

#define Sel 1444

/* Old-FunctionNumber-Define of MaxArticleQuota *******************************/

#define SelMax 1395

/* Old-FunctionNumber-Define of Occasion **************************************/

#define SelList 1496

/* Old-FunctionNumber-Define of PharmGrp **************************************/

#define Sel 1442

/* Old-FunctionNumber-Define of PreisAnzTyp ***********************************/

#define SelPreis 1519

/* Old-FunctionNumber-Define of PriceHist *************************************/

#define Sel 1443

/* Old-FunctionNumber-Define of PromoAnz **************************************/

#define SelPromo 1518

/* Old-FunctionNumber-Define of REIMPORT **************************************/

#define SelAuswahl 1238

/* Old-FunctionNumber-Define of Steller ***************************************/

#define SelList 1501

/* Old-FunctionNumber-Define of StellerTyp ************************************/

#define SelTyp 1530

/* Old-FunctionNumber-Define of StockReservation ******************************/

#define DeleteEntry 1797
#define SelListAll 1806
#define SelList 1619
#define SelSum 1618

/* Old-FunctionNumber-Define of StockReservationArticleReserv *****************/

#define SelArticleReservation 1804
#define UpdateArticleReservation 1805

/* Old-FunctionNumber-Define of StockReservationArtikelLokal ******************/

#define SelArtikelLokal 1801
#define UpdateArtikelLokal 1802

/* Old-FunctionNumber-Define of StockReservationIBTRequest ********************/

#define SelIBTRequest 1803

/* Old-FunctionNumber-Define of StockReservationNachlieferPos *****************/

#define DeleteNachlieferPos 1800
#define SelNachlieferPos 1799

/* Old-FunctionNumber-Define of StockReservationOrder *************************/

#define SelOrder 1798

/* Old-FunctionNumber-Define of SupplInfo *************************************/

#define SelSuppInfo 1616

/* Old-FunctionNumber-Define of delayedart ************************************/

#define Delete 1368
#define Insert 1367
#define Sel 1366
#define Update 1369

/* Old-FunctionNumber-Define of discountanz ***********************************/

#define SelList 1419
#define SelListCst 1513
#define SelListCstEKG 1514
#define SelListDG 1504
#define SelListGrp 1420
#define SelListGrpHerst 1503
#define SelListHerst 1502
#define SellListGrpDG 1505

/* Old-FunctionNumber-Define of stockentry ************************************/

#define SelList 1347

#endif

/* C++ Class ******************************************************************/

#ifdef TRANSCLASS

#include<vector>
using namespace std;

/* ppunixc */
#include <sockclient.h>
#include <ppstring.h>
#include <ppgeneric.h>

/* must be implemented */
void FehlerBehandlung(int rc, const char * const error_msg);

#ifndef __VIRTUAL_DADE_CLASS__
#define __VIRTUAL_DADE_CLASS__

class ppDadeVirtual {
public:
    virtual    ~ppDadeVirtual() {};
    virtual int SelList      (int FetchRel = 1, int pos = 0) = 0;
    virtual int SelListHist  (int FetchRel = 1, int pos = 0) = 0;
    virtual int SelListFuture(int FetchRel = 1, int pos = 0) = 0;
    virtual int Load         (int pos = 0                  ) = 0;
    virtual int Delete       (int pos = 0                  ) = 0;
    virtual int Save         (int pos = 0                  ) = 0;
};
#endif

class CARTBUYINGOPTIONS : public ppDadeVirtual {
public:
    artbuyingoptionsS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artbuyingoptionsS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artbuyingoptionsS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artbuyingoptionsS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artbuyingoptionsS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artbuyingoptionsS>::iterator
                 beginList() { return lst.begin(); }
    vector<artbuyingoptionsS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetEtartklasse1() const { return s.ETARTKLASSE1; }
    char         GetKzpsychostoffe() const { return s.KZPSYCHOSTOFFE[0]; }

    const artbuyingoptionsS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetEtartklasse1(long t) { s.ETARTKLASSE1 = t; }
    void         SetKzpsychostoffe(char t) { s.KZPSYCHOSTOFFE[0] = t; s.KZPSYCHOSTOFFE[1] = '\0';}

    void         SetStruct(const artbuyingoptionsS & t) { s = t; }

    int          SelBuyingOptions(int pos = 0) { int ret = UniqueServerCall(1747, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTBUYINGOPTIONS() {
        ::buf_default((void *)&s, ARTBUYINGOPTIONS_BES, ARTBUYINGOPTIONS_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTBUYINGOPTIONS() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTBUYINGOPTIONS_BES, ARTBUYINGOPTIONS_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1747 ) return UniqueServerCall(1747, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTBUYINGOPTIONS & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTBUYINGOPTIONS_BES, (int)ARTBUYINGOPTIONS_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTCHARGE : public ppDadeVirtual {
public:
    artchargeS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artchargeS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artchargeS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artchargeS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artchargeS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artchargeS>::iterator
                 beginList() { return lst.begin(); }
    vector<artchargeS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetExpirydate() const { return s.EXPIRYDATE; }
    const char*  GetChargennr(ppString & t) const { t = s.CHARGENNR; t.erasespace(ppString::END); return t.c_str(); }
    long         GetStock() const { return s.STOCK; }
    char         GetStatecharge() const { return s.STATECHARGE[0]; }

    const artchargeS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetExpirydate(long t) { s.EXPIRYDATE = t; }
    void         SetChargennr(const ppString & t) { ppGStrCopy(s.CHARGENNR, t.c_str(), L_ARTCHARGE_CHARGENNR); }
    void         SetStock(long t) { s.STOCK = t; }
    void         SetStatecharge(char t) { s.STATECHARGE[0] = t; s.STATECHARGE[1] = '\0';}

    void         SetStruct(const artchargeS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1527, FetchRel, pos); return ret; }
    int          SelListQua(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1592, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTCHARGE() {
        ::buf_default((void *)&s, ARTCHARGE_BES, ARTCHARGE_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTCHARGE() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTCHARGE_BES, ARTCHARGE_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTCHARGE_BES, (int)ARTCHARGE_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1527 ) return CursorServerCall(1527, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1592 ) return CursorServerCall(1592, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTCHARGE & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.CHARGENNR);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTCHARGE_BES, (int)ARTCHARGE_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTCHARGE c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTCHARGE_BES, (int)ARTCHARGE_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTINFBG : public ppDadeVirtual {
public:
    artinfbgS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artinfbgS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artinfbgS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artinfbgS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artinfbgS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artinfbgS>::iterator
                 beginList() { return lst.begin(); }
    vector<artinfbgS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    const char*  GetHealthfundcode(ppString & t) const { t = s.HEALTHFUNDCODE; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_langname(ppString & t) const { t = s.ARTIKEL_LANGNAME; t.erasespace(ppString::END); return t.c_str(); }

    const artinfbgS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetHealthfundcode(const ppString & t) { ppGStrCopy(s.HEALTHFUNDCODE, t.c_str(), L_ARTINFBG_HEALTHFUNDCODE); }
    void         SetArtikel_langname(const ppString & t) { ppGStrCopy(s.ARTIKEL_LANGNAME, t.c_str(), L_ARTINFBG_ARTIKEL_LANGNAME); }

    void         SetStruct(const artinfbgS & t) { s = t; }

    int          SelArtInfBG(int pos = 0) { int ret = UniqueServerCall(1552, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTINFBG() {
        ::buf_default((void *)&s, ARTINFBG_BES, ARTINFBG_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTINFBG() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTINFBG_BES, ARTINFBG_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1552 ) return UniqueServerCall(1552, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTINFBG & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.HEALTHFUNDCODE);
        ppGStripLast(d.ARTIKEL_LANGNAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTINFBG_BES, (int)ARTINFBG_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTINSERT : public ppDadeVirtual {
public:
    artinsertS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artinsertS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artinsertS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artinsertS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artinsertS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artinsertS>::iterator
                 beginList() { return lst.begin(); }
    vector<artinsertS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticleno() const { return s.ARTICLENO; }
    short        GetArtinfotype() const { return s.ARTINFOTYPE; }
    short        GetSequenceno() const { return s.SEQUENCENO; }
    const char*  GetInfotext(ppString & t) const { t = s.INFOTEXT; t.erasespace(ppString::END); return t.c_str(); }

    const artinsertS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetArtinfotype(short t) { s.ARTINFOTYPE = t; }
    void         SetSequenceno(short t) { s.SEQUENCENO = t; }
    void         SetInfotext(const ppString & t) { ppGStrCopy(s.INFOTEXT, t.c_str(), L_ARTINSERT_INFOTEXT); }

    void         SetStruct(const artinsertS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Delete(int pos = 0) { return UniqueServerCall(1500, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1499, pos); Strip(s); return ret; }
    int          SelBeilage(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1498, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTINSERT() {
        ::buf_default((void *)&s, ARTINSERT_BES, ARTINSERT_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTINSERT() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTINSERT_BES, ARTINSERT_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTINSERT_BES, (int)ARTINSERT_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1500 ) return UniqueServerCall(1500, pos);
        if ( fkt_nr == 1499 ) return UniqueServerCall(1499, pos);
        if ( fkt_nr == 1498 ) return CursorServerCall(1498, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTINSERT & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.INFOTEXT);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTINSERT_BES, (int)ARTINSERT_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTINSERT c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTINSERT_BES, (int)ARTINSERT_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTLANGNAME : public ppDadeVirtual {
public:
    artlangnameS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artlangnameS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artlangnameS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artlangnameS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artlangnameS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artlangnameS>::iterator
                 beginList() { return lst.begin(); }
    vector<artlangnameS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    const char*  GetArtikel_langname(ppString & t) const { t = s.ARTIKEL_LANGNAME; t.erasespace(ppString::END); return t.c_str(); }

    const artlangnameS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetArtikel_langname(const ppString & t) { ppGStrCopy(s.ARTIKEL_LANGNAME, t.c_str(), L_ARTLANGNAME_ARTIKEL_LANGNAME); }

    void         SetStruct(const artlangnameS & t) { s = t; }

    int          SelLangname(int pos = 0) { int ret = UniqueServerCall(1515, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTLANGNAME() {
        ::buf_default((void *)&s, ARTLANGNAME_BES, ARTLANGNAME_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTLANGNAME() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTLANGNAME_BES, ARTLANGNAME_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1515 ) return UniqueServerCall(1515, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTLANGNAME & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.ARTIKEL_LANGNAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTLANGNAME_BES, (int)ARTLANGNAME_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTPRICE : public ppDadeVirtual {
public:
    artpriceS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artpriceS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artpriceS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artpriceS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artpriceS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artpriceS>::iterator
                 beginList() { return lst.begin(); }
    vector<artpriceS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    double       GetPreisekapo() const { return s.PREISEKAPO; }
    double       GetPreisekgrosso() const { return s.PREISEKGROSSO; }
    short        GetPreis_typ() const { return s.PREIS_TYP; }

    const artpriceS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetPreisekapo(double t) { s.PREISEKAPO = t; }
    void         SetPreisekgrosso(double t) { s.PREISEKGROSSO = t; }
    void         SetPreis_typ(short t) { s.PREIS_TYP = t; }

    void         SetStruct(const artpriceS & t) { s = t; }

    int          SelPrice(int pos = 0) { int ret = UniqueServerCall(1583, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTPRICE() {
        ::buf_default((void *)&s, ARTPRICE_BES, ARTPRICE_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTPRICE() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTPRICE_BES, ARTPRICE_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1583 ) return UniqueServerCall(1583, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTPRICE & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTPRICE_BES, (int)ARTPRICE_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTPSYCHO : public ppDadeVirtual {
public:
    artpsychoS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artpsychoS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artpsychoS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artpsychoS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artpsychoS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artpsychoS>::iterator
                 beginList() { return lst.begin(); }
    vector<artpsychoS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetEtartklasse1() const { return s.ETARTKLASSE1; }
    char         GetKzpsychostoffe() const { return s.KZPSYCHOSTOFFE[0]; }

    const artpsychoS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetEtartklasse1(long t) { s.ETARTKLASSE1 = t; }
    void         SetKzpsychostoffe(char t) { s.KZPSYCHOSTOFFE[0] = t; s.KZPSYCHOSTOFFE[1] = '\0';}

    void         SetStruct(const artpsychoS & t) { s = t; }

    int          SelArticle(int pos = 0) { int ret = UniqueServerCall(1574, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTPSYCHO() {
        ::buf_default((void *)&s, ARTPSYCHO_BES, ARTPSYCHO_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTPSYCHO() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTPSYCHO_BES, ARTPSYCHO_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1574 ) return UniqueServerCall(1574, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTPSYCHO & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTPSYCHO_BES, (int)ARTPSYCHO_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTICLEAGENTGROUP : public ppDadeVirtual {
public:
    articleagentgroupS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<articleagentgroupS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articleagentgroupS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     articleagentgroupS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articleagentgroupS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<articleagentgroupS>::iterator
                 beginList() { return lst.begin(); }
    vector<articleagentgroupS>::iterator
                 endList  () { return lst.end  (); }

    double       GetPreisekapo() const { return s.PREISEKAPO; }
    short        GetFilialnr() const { return s.FILIALNR; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetBestand() const { return s.BESTAND; }
    const char*  GetDarreichform(ppString & t) const { t = s.DARREICHFORM; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetWirkstoff_nr(ppString & t) const { t = s.WIRKSTOFF_NR; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_langname(ppString & t) const { t = s.ARTIKEL_LANGNAME; t.erasespace(ppString::END); return t.c_str(); }

    const articleagentgroupS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetPreisekapo(double t) { s.PREISEKAPO = t; }
    void         SetFilialnr(short t) { s.FILIALNR = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetBestand(long t) { s.BESTAND = t; }
    void         SetDarreichform(const ppString & t) { ppGStrCopy(s.DARREICHFORM, t.c_str(), L_ARTICLEAGENTGROUP_DARREICHFORM); }
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_ARTICLEAGENTGROUP_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_ARTICLEAGENTGROUP_ARTIKEL_NAME); }
    void         SetWirkstoff_nr(const ppString & t) { ppGStrCopy(s.WIRKSTOFF_NR, t.c_str(), L_ARTICLEAGENTGROUP_WIRKSTOFF_NR); }
    void         SetArtikel_langname(const ppString & t) { ppGStrCopy(s.ARTIKEL_LANGNAME, t.c_str(), L_ARTICLEAGENTGROUP_ARTIKEL_LANGNAME); }

    void         SetStruct(const articleagentgroupS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelAgent(int pos = 0) { int ret = UniqueServerCall(1488, pos); Strip(s); return ret; }
    int          SelArtikel(int pos = 0) { int ret = UniqueServerCall(1497, pos); Strip(s); return ret; }
    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1487, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTICLEAGENTGROUP() {
        ::buf_default((void *)&s, ARTICLEAGENTGROUP_BES, ARTICLEAGENTGROUP_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTICLEAGENTGROUP() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTICLEAGENTGROUP_BES, ARTICLEAGENTGROUP_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLEAGENTGROUP_BES, (int)ARTICLEAGENTGROUP_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1488 ) return UniqueServerCall(1488, pos);
        if ( fkt_nr == 1497 ) return UniqueServerCall(1497, pos);
        if ( fkt_nr == 1487 ) return CursorServerCall(1487, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTICLEAGENTGROUP & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.DARREICHFORM);
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
        ppGStripLast(d.WIRKSTOFF_NR);
        ppGStripLast(d.ARTIKEL_LANGNAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTICLEAGENTGROUP_BES, (int)ARTICLEAGENTGROUP_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTICLEAGENTGROUP c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLEAGENTGROUP_BES, (int)ARTICLEAGENTGROUP_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTICLELPPRREIMB : public ppDadeVirtual {
public:
    articlelpprreimbS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<articlelpprreimbS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articlelpprreimbS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     articlelpprreimbS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articlelpprreimbS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<articlelpprreimbS>::iterator
                 beginList() { return lst.begin(); }
    vector<articlelpprreimbS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticleno() const { return s.ARTICLENO; }
    const char*  GetCode_lppr(ppString & t) const { t = s.CODE_LPPR; t.erasespace(ppString::END); return t.c_str(); }
    long         GetDatefrom() const { return s.DATEFROM; }
    double       GetReimbursement_val() const { return s.REIMBURSEMENT_VAL; }
    const char*  GetLppr_desc(ppString & t) const { t = s.LPPR_DESC; t.erasespace(ppString::END); return t.c_str(); }
    short        GetReimbcalcflag() const { return s.REIMBCALCFLAG; }

    const articlelpprreimbS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetCode_lppr(const ppString & t) { ppGStrCopy(s.CODE_LPPR, t.c_str(), L_ARTICLELPPRREIMB_CODE_LPPR); }
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetReimbursement_val(double t) { s.REIMBURSEMENT_VAL = t; }
    void         SetLppr_desc(const ppString & t) { ppGStrCopy(s.LPPR_DESC, t.c_str(), L_ARTICLELPPRREIMB_LPPR_DESC); }
    void         SetReimbcalcflag(short t) { s.REIMBCALCFLAG = t; }

    void         SetStruct(const articlelpprreimbS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelListArt(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1737, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTICLELPPRREIMB() {
        ::buf_default((void *)&s, ARTICLELPPRREIMB_BES, ARTICLELPPRREIMB_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTICLELPPRREIMB() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTICLELPPRREIMB_BES, ARTICLELPPRREIMB_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLELPPRREIMB_BES, (int)ARTICLELPPRREIMB_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1737 ) return CursorServerCall(1737, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTICLELPPRREIMB & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.CODE_LPPR);
        ppGStripLast(d.LPPR_DESC);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTICLELPPRREIMB_BES, (int)ARTICLELPPRREIMB_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTICLELPPRREIMB c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLELPPRREIMB_BES, (int)ARTICLELPPRREIMB_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTICLEQUOTADETAIL : public ppDadeVirtual {
public:
    articlequotadetailS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<articlequotadetailS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articlequotadetailS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     articlequotadetailS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articlequotadetailS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<articlequotadetailS>::iterator
                 beginList() { return lst.begin(); }
    vector<articlequotadetailS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetQuota() const { return s.QUOTA; }
    char         GetValidity() const { return s.VALIDITY[0]; }
    const char*  GetKzkdklasse(ppString & t) const { t = s.KZKDKLASSE; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }

    const articlequotadetailS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetQuota(long t) { s.QUOTA = t; }
    void         SetValidity(char t) { s.VALIDITY[0] = t; s.VALIDITY[1] = '\0';}
    void         SetKzkdklasse(const ppString & t) { ppGStrCopy(s.KZKDKLASSE, t.c_str(), L_ARTICLEQUOTADETAIL_KZKDKLASSE); }
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_ARTICLEQUOTADETAIL_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_ARTICLEQUOTADETAIL_ARTIKEL_NAME); }

    void         SetStruct(const articlequotadetailS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelCount(int pos = 0) { int ret = UniqueServerCall(1479, pos); Strip(s); return ret; }
    int          SelKumVzDetail(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1478, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTICLEQUOTADETAIL() {
        ::buf_default((void *)&s, ARTICLEQUOTADETAIL_BES, ARTICLEQUOTADETAIL_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTICLEQUOTADETAIL() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTICLEQUOTADETAIL_BES, ARTICLEQUOTADETAIL_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLEQUOTADETAIL_BES, (int)ARTICLEQUOTADETAIL_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1479 ) return UniqueServerCall(1479, pos);
        if ( fkt_nr == 1478 ) return CursorServerCall(1478, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTICLEQUOTADETAIL & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.KZKDKLASSE);
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTICLEQUOTADETAIL_BES, (int)ARTICLEQUOTADETAIL_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTICLEQUOTADETAIL c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLEQUOTADETAIL_BES, (int)ARTICLEQUOTADETAIL_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTICLEQUOTAEKG : public ppDadeVirtual {
public:
    articlequotaekgS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<articlequotaekgS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articlequotaekgS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     articlequotaekgS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articlequotaekgS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<articlequotaekgS>::iterator
                 beginList() { return lst.begin(); }
    vector<articlequotaekgS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    const char*  GetGroup_name(ppString & t) const { t = s.GROUP_NAME; t.erasespace(ppString::END); return t.c_str(); }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetQuota() const { return s.QUOTA; }
    long         GetKumqty() const { return s.KUMQTY; }
    char         GetValidity() const { return s.VALIDITY[0]; }
    long         GetDateupdate() const { return s.DATEUPDATE; }
    long         GetUid_anlage() const { return s.UID_ANLAGE; }
    long         GetDatefrom() const { return s.DATEFROM; }
    long         GetDateto() const { return s.DATETO; }
    const char*  GetPharmacygroupid(ppString & t) const { t = s.PHARMACYGROUPID; t.erasespace(ppString::END); return t.c_str(); }
    char         GetSnobatchchange() const { return s.SNOBATCHCHANGE[0]; }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }

    const articlequotaekgS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetGroup_name(const ppString & t) { ppGStrCopy(s.GROUP_NAME, t.c_str(), L_ARTICLEQUOTAEKG_GROUP_NAME); }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetQuota(long t) { s.QUOTA = t; }
    void         SetKumqty(long t) { s.KUMQTY = t; }
    void         SetValidity(char t) { s.VALIDITY[0] = t; s.VALIDITY[1] = '\0';}
    void         SetDateupdate(long t) { s.DATEUPDATE = t; }
    void         SetUid_anlage(long t) { s.UID_ANLAGE = t; }
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetDateto(long t) { s.DATETO = t; }
    void         SetPharmacygroupid(const ppString & t) { ppGStrCopy(s.PHARMACYGROUPID, t.c_str(), L_ARTICLEQUOTAEKG_PHARMACYGROUPID); }
    void         SetSnobatchchange(char t) { s.SNOBATCHCHANGE[0] = t; s.SNOBATCHCHANGE[1] = '\0';}
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_ARTICLEQUOTAEKG_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_ARTICLEQUOTAEKG_ARTIKEL_NAME); }

    void         SetStruct(const articlequotaekgS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Delete(int pos = 0) { return UniqueServerCall(1473, pos); }
    int          DeleteAllEKG(int pos = 0) { return UniqueServerCall(1474, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1472, pos); Strip(s); return ret; }
    int          SelArticle(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1476, FetchRel, pos); return ret; }
    int          SelListEKG(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1475, FetchRel, pos); return ret; }
    int          Update(int pos = 0) { int ret = UniqueServerCall(1471, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTICLEQUOTAEKG() {
        ::buf_default((void *)&s, ARTICLEQUOTAEKG_BES, ARTICLEQUOTAEKG_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTICLEQUOTAEKG() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTICLEQUOTAEKG_BES, ARTICLEQUOTAEKG_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLEQUOTAEKG_BES, (int)ARTICLEQUOTAEKG_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1473 ) return UniqueServerCall(1473, pos);
        if ( fkt_nr == 1474 ) return UniqueServerCall(1474, pos);
        if ( fkt_nr == 1472 ) return UniqueServerCall(1472, pos);
        if ( fkt_nr == 1476 ) return CursorServerCall(1476, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1475 ) return CursorServerCall(1475, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1471 ) return UniqueServerCall(1471, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTICLEQUOTAEKG & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.GROUP_NAME);
        ppGStripLast(d.PHARMACYGROUPID);
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTICLEQUOTAEKG_BES, (int)ARTICLEQUOTAEKG_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTICLEQUOTAEKG c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTICLEQUOTAEKG_BES, (int)ARTICLEQUOTAEKG_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTICLETAX : public ppDadeVirtual {
public:
    articletaxS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<articletaxS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articletaxS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     articletaxS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< articletaxS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<articletaxS>::iterator
                 beginList() { return lst.begin(); }
    vector<articletaxS>::iterator
                 endList  () { return lst.end  (); }

    double       GetSalestaxrate() const { return s.SALESTAXRATE; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }

    const articletaxS &
                 GetStruct() const { return s; }
    void         SetSalestaxrate(double t) { s.SALESTAXRATE = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }

    void         SetStruct(const articletaxS & t) { s = t; }

    int          SelTax(int pos = 0) { int ret = UniqueServerCall(1409, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTICLETAX() {
        ::buf_default((void *)&s, ARTICLETAX_BES, ARTICLETAX_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTICLETAX() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTICLETAX_BES, ARTICLETAX_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1409 ) return UniqueServerCall(1409, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTICLETAX & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTICLETAX_BES, (int)ARTICLETAX_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTIKELLPPR : public ppDadeVirtual {
public:
    artikellpprS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artikellpprS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikellpprS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artikellpprS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikellpprS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artikellpprS>::iterator
                 beginList() { return lst.begin(); }
    vector<artikellpprS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticleno() const { return s.ARTICLENO; }
    char         GetReimbursement_type() const { return s.REIMBURSEMENT_TYPE[0]; }
    double       GetReimbursementprice() const { return s.REIMBURSEMENTPRICE; }
    const char*  GetCode_lppr(ppString & t) const { t = s.CODE_LPPR; t.erasespace(ppString::END); return t.c_str(); }
    double       GetReimbursement_perc() const { return s.REIMBURSEMENT_PERC; }

    const artikellpprS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetReimbursement_type(char t) { s.REIMBURSEMENT_TYPE[0] = t; s.REIMBURSEMENT_TYPE[1] = '\0';}
    void         SetReimbursementprice(double t) { s.REIMBURSEMENTPRICE = t; }
    void         SetCode_lppr(const ppString & t) { ppGStrCopy(s.CODE_LPPR, t.c_str(), L_ARTIKELLPPR_CODE_LPPR); }
    void         SetReimbursement_perc(double t) { s.REIMBURSEMENT_PERC = t; }

    void         SetStruct(const artikellpprS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1439, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTIKELLPPR() {
        ::buf_default((void *)&s, ARTIKELLPPR_BES, ARTIKELLPPR_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTIKELLPPR() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTIKELLPPR_BES, ARTIKELLPPR_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTIKELLPPR_BES, (int)ARTIKELLPPR_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1439 ) return CursorServerCall(1439, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTIKELLPPR & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.CODE_LPPR);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTIKELLPPR_BES, (int)ARTIKELLPPR_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTIKELLPPR c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTIKELLPPR_BES, (int)ARTIKELLPPR_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTIKELQUOTA : public ppDadeVirtual {
public:
    artikelquotaS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artikelquotaS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelquotaS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artikelquotaS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelquotaS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artikelquotaS>::iterator
                 beginList() { return lst.begin(); }
    vector<artikelquotaS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    const char*  GetMatchcode(ppString & t) const { t = s.MATCHCODE; t.erasespace(ppString::END); return t.c_str(); }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetQuota() const { return s.QUOTA; }
    long         GetKumqty() const { return s.KUMQTY; }
    char         GetValidity() const { return s.VALIDITY[0]; }
    long         GetDateupdate() const { return s.DATEUPDATE; }
    long         GetUid_anlage() const { return s.UID_ANLAGE; }
    char         GetSdafuequota() const { return s.SDAFUEQUOTA[0]; }
    long         GetDatefrom() const { return s.DATEFROM; }
    long         GetDateto() const { return s.DATETO; }
    const char*  GetPharmacygroupid(ppString & t) const { t = s.PHARMACYGROUPID; t.erasespace(ppString::END); return t.c_str(); }
    char         GetSnobatchchange() const { return s.SNOBATCHCHANGE[0]; }
    short        GetQuotainheritance() const { return s.QUOTAINHERITANCE; }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }

    const artikelquotaS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetMatchcode(const ppString & t) { ppGStrCopy(s.MATCHCODE, t.c_str(), L_ARTIKELQUOTA_MATCHCODE); }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetQuota(long t) { s.QUOTA = t; }
    void         SetKumqty(long t) { s.KUMQTY = t; }
    void         SetValidity(char t) { s.VALIDITY[0] = t; s.VALIDITY[1] = '\0';}
    void         SetDateupdate(long t) { s.DATEUPDATE = t; }
    void         SetUid_anlage(long t) { s.UID_ANLAGE = t; }
    void         SetSdafuequota(char t) { s.SDAFUEQUOTA[0] = t; s.SDAFUEQUOTA[1] = '\0';}
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetDateto(long t) { s.DATETO = t; }
    void         SetPharmacygroupid(const ppString & t) { ppGStrCopy(s.PHARMACYGROUPID, t.c_str(), L_ARTIKELQUOTA_PHARMACYGROUPID); }
    void         SetSnobatchchange(char t) { s.SNOBATCHCHANGE[0] = t; s.SNOBATCHCHANGE[1] = '\0';}
    void         SetQuotainheritance(short t) { s.QUOTAINHERITANCE = t; }
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_ARTIKELQUOTA_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_ARTIKELQUOTA_ARTIKEL_NAME); }

    void         SetStruct(const artikelquotaS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          CheckQuota(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1466, FetchRel, pos); return ret; }
    int          Delete(int pos = 0) { return UniqueServerCall(1356, pos); }
    int          DeleteAllArt(int pos = 0) { return UniqueServerCall(1358, pos); }
    int          DeleteAllKnd(int pos = 0) { return UniqueServerCall(1357, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1355, pos); Strip(s); return ret; }
    int          SelKumVz(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1365, FetchRel, pos); return ret; }
    int          SelListAllNoBat(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1557, FetchRel, pos); return ret; }
    int          SelListArt(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1354, FetchRel, pos); return ret; }
    int          SelListArtNoBat(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1555, FetchRel, pos); return ret; }
    int          SelListKnd(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1353, FetchRel, pos); return ret; }
    int          SelListKndNoBat(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1556, FetchRel, pos); return ret; }
    int          SelQuota(int pos = 0) { int ret = UniqueServerCall(1360, pos); Strip(s); return ret; }
    int          Update(int pos = 0) { int ret = UniqueServerCall(1359, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTIKELQUOTA() {
        ::buf_default((void *)&s, ARTIKELQUOTA_BES, ARTIKELQUOTA_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTIKELQUOTA() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTIKELQUOTA_BES, ARTIKELQUOTA_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTIKELQUOTA_BES, (int)ARTIKELQUOTA_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1466 ) return CursorServerCall(1466, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1356 ) return UniqueServerCall(1356, pos);
        if ( fkt_nr == 1358 ) return UniqueServerCall(1358, pos);
        if ( fkt_nr == 1357 ) return UniqueServerCall(1357, pos);
        if ( fkt_nr == 1355 ) return UniqueServerCall(1355, pos);
        if ( fkt_nr == 1365 ) return CursorServerCall(1365, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1557 ) return CursorServerCall(1557, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1354 ) return CursorServerCall(1354, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1555 ) return CursorServerCall(1555, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1353 ) return CursorServerCall(1353, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1556 ) return CursorServerCall(1556, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1360 ) return UniqueServerCall(1360, pos);
        if ( fkt_nr == 1359 ) return UniqueServerCall(1359, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTIKELQUOTA & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.MATCHCODE);
        ppGStripLast(d.PHARMACYGROUPID);
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTIKELQUOTA_BES, (int)ARTIKELQUOTA_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTIKELQUOTA c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTIKELQUOTA_BES, (int)ARTIKELQUOTA_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTIKELQUOTAPF : public ppDadeVirtual {
public:
    artikelquotapfS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artikelquotapfS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelquotapfS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artikelquotapfS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelquotapfS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artikelquotapfS>::iterator
                 beginList() { return lst.begin(); }
    vector<artikelquotapfS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetQuota() const { return s.QUOTA; }
    long         GetKumqty() const { return s.KUMQTY; }
    char         GetValidity() const { return s.VALIDITY[0]; }
    long         GetDateupdate() const { return s.DATEUPDATE; }
    long         GetUid_anlage() const { return s.UID_ANLAGE; }
    char         GetSdafuequota() const { return s.SDAFUEQUOTA[0]; }
    long         GetDatefrom() const { return s.DATEFROM; }
    long         GetDateto() const { return s.DATETO; }
    char         GetSnobatchchange() const { return s.SNOBATCHCHANGE[0]; }
    const char*  GetKzkdklasse(ppString & t) const { t = s.KZKDKLASSE; t.erasespace(ppString::END); return t.c_str(); }
    long         GetWert() const { return s.WERT; }

    const artikelquotapfS &
                 GetStruct() const { return s; }
    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetQuota(long t) { s.QUOTA = t; }
    void         SetKumqty(long t) { s.KUMQTY = t; }
    void         SetValidity(char t) { s.VALIDITY[0] = t; s.VALIDITY[1] = '\0';}
    void         SetDateupdate(long t) { s.DATEUPDATE = t; }
    void         SetUid_anlage(long t) { s.UID_ANLAGE = t; }
    void         SetSdafuequota(char t) { s.SDAFUEQUOTA[0] = t; s.SDAFUEQUOTA[1] = '\0';}
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetDateto(long t) { s.DATETO = t; }
    void         SetSnobatchchange(char t) { s.SNOBATCHCHANGE[0] = t; s.SNOBATCHCHANGE[1] = '\0';}
    void         SetKzkdklasse(const ppString & t) { ppGStrCopy(s.KZKDKLASSE, t.c_str(), L_ARTIKELQUOTAPF_KZKDKLASSE); }
    void         SetWert(long t) { s.WERT = t; }

    void         SetStruct(const artikelquotapfS & t) { s = t; }

    int          CopyQuota(int pos = 0) { int ret = UniqueServerCall(1404, pos); Strip(s); return ret; }
    int          DeleteKundeEKG(int pos = 0) { int ret = UniqueServerCall(1779, pos); Strip(s); return ret; }
    int          InsertKlasse(int pos = 0) { int ret = UniqueServerCall(1364, pos); Strip(s); return ret; }
    int          InsertKlasse09(int pos = 0) { int ret = UniqueServerCall(1425, pos); Strip(s); return ret; }
    int          InsertKundeEKG(int pos = 0) { int ret = UniqueServerCall(1507, pos); Strip(s); return ret; }
    int          UpdateKundeEKG(int pos = 0) { int ret = UniqueServerCall(1508, pos); Strip(s); return ret; }
    int          UpdateQuota(int pos = 0) { int ret = UniqueServerCall(1374, pos); Strip(s); return ret; }
    int          UpdateQuota09(int pos = 0) { int ret = UniqueServerCall(1430, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTIKELQUOTAPF() {
        ::buf_default((void *)&s, ARTIKELQUOTAPF_BES, ARTIKELQUOTAPF_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTIKELQUOTAPF() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTIKELQUOTAPF_BES, ARTIKELQUOTAPF_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1404 ) return UniqueServerCall(1404, pos);
        if ( fkt_nr == 1779 ) return UniqueServerCall(1779, pos);
        if ( fkt_nr == 1364 ) return UniqueServerCall(1364, pos);
        if ( fkt_nr == 1425 ) return UniqueServerCall(1425, pos);
        if ( fkt_nr == 1507 ) return UniqueServerCall(1507, pos);
        if ( fkt_nr == 1508 ) return UniqueServerCall(1508, pos);
        if ( fkt_nr == 1374 ) return UniqueServerCall(1374, pos);
        if ( fkt_nr == 1430 ) return UniqueServerCall(1430, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTIKELQUOTAPF & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.KZKDKLASSE);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTIKELQUOTAPF_BES, (int)ARTIKELQUOTAPF_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTIKELRESERVE : public ppDadeVirtual {
public:
    artikelreserveS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artikelreserveS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelreserveS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artikelreserveS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelreserveS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artikelreserveS>::iterator
                 beginList() { return lst.begin(); }
    vector<artikelreserveS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    const char*  GetPharmacygroupid(ppString & t) const { t = s.PHARMACYGROUPID; t.erasespace(ppString::END); return t.c_str(); }
    long         GetArticleno() const { return s.ARTICLENO; }
    short        GetReservtype() const { return s.RESERVTYPE; }
    long         GetMaxqty() const { return s.MAXQTY; }
    long         GetReservedqty() const { return s.RESERVEDQTY; }
    short        GetReservepct() const { return s.RESERVEPCT; }

    const artikelreserveS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetPharmacygroupid(const ppString & t) { ppGStrCopy(s.PHARMACYGROUPID, t.c_str(), L_ARTIKELRESERVE_PHARMACYGROUPID); }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetReservtype(short t) { s.RESERVTYPE = t; }
    void         SetMaxqty(long t) { s.MAXQTY = t; }
    void         SetReservedqty(long t) { s.RESERVEDQTY = t; }
    void         SetReservepct(short t) { s.RESERVEPCT = t; }

    void         SetStruct(const artikelreserveS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Delete(int pos = 0) { return UniqueServerCall(1397, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1396, pos); Strip(s); return ret; }
    int          InsertBestand(int pos = 0) { int ret = UniqueServerCall(1402, pos); Strip(s); return ret; }
    int          ReservStockAbs(int pos = 0) { int ret = UniqueServerCall(1483, pos); Strip(s); return ret; }
    int          SelArt(int pos = 0) { int ret = UniqueServerCall(1399, pos); Strip(s); return ret; }
    int          SelArtKnd(int pos = 0) { int ret = UniqueServerCall(1400, pos); Strip(s); return ret; }
    int          SelListBestand(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1401, FetchRel, pos); return ret; }
    int          Update(int pos = 0) { int ret = UniqueServerCall(1398, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTIKELRESERVE() {
        ::buf_default((void *)&s, ARTIKELRESERVE_BES, ARTIKELRESERVE_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTIKELRESERVE() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTIKELRESERVE_BES, ARTIKELRESERVE_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTIKELRESERVE_BES, (int)ARTIKELRESERVE_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1397 ) return UniqueServerCall(1397, pos);
        if ( fkt_nr == 1396 ) return UniqueServerCall(1396, pos);
        if ( fkt_nr == 1402 ) return UniqueServerCall(1402, pos);
        if ( fkt_nr == 1483 ) return UniqueServerCall(1483, pos);
        if ( fkt_nr == 1399 ) return UniqueServerCall(1399, pos);
        if ( fkt_nr == 1400 ) return UniqueServerCall(1400, pos);
        if ( fkt_nr == 1401 ) return CursorServerCall(1401, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1398 ) return UniqueServerCall(1398, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTIKELRESERVE & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.PHARMACYGROUPID);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTIKELRESERVE_BES, (int)ARTIKELRESERVE_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CARTIKELRESERVE c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ARTIKELRESERVE_BES, (int)ARTIKELRESERVE_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CARTIKELTEXT : public ppDadeVirtual {
public:
    artikeltextS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artikeltextS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikeltextS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artikeltextS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikeltextS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artikeltextS>::iterator
                 beginList() { return lst.begin(); }
    vector<artikeltextS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    short        GetTextkey() const { return s.TEXTKEY; }
    const char*  GetText(ppString & t) const { t = s.TEXT; t.erasespace(ppString::END); return t.c_str(); }
    char         GetDisplayonscreen() const { return s.DISPLAYONSCREEN[0]; }
    const char*  GetTexthospital(ppString & t) const { t = s.TEXTHOSPITAL; t.erasespace(ppString::END); return t.c_str(); }

    const artikeltextS &
                 GetStruct() const { return s; }
    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetTextkey(short t) { s.TEXTKEY = t; }
    void         SetText(const ppString & t) { ppGStrCopy(s.TEXT, t.c_str(), L_ARTIKELTEXT_TEXT); }
    void         SetDisplayonscreen(char t) { s.DISPLAYONSCREEN[0] = t; s.DISPLAYONSCREEN[1] = '\0';}
    void         SetTexthospital(const ppString & t) { ppGStrCopy(s.TEXTHOSPITAL, t.c_str(), L_ARTIKELTEXT_TEXTHOSPITAL); }

    void         SetStruct(const artikeltextS & t) { s = t; }

    int          Select(int pos = 0) { int ret = UniqueServerCall(1375, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTIKELTEXT() {
        ::buf_default((void *)&s, ARTIKELTEXT_BES, ARTIKELTEXT_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTIKELTEXT() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTIKELTEXT_BES, ARTIKELTEXT_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1375 ) return UniqueServerCall(1375, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTIKELTEXT & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.TEXT);
        ppGStripLast(d.TEXTHOSPITAL);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTIKELTEXT_BES, (int)ARTIKELTEXT_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CARTIKELVERFALL : public ppDadeVirtual {
public:
    artikelverfallS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<artikelverfallS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelverfallS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     artikelverfallS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< artikelverfallS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<artikelverfallS>::iterator
                 beginList() { return lst.begin(); }
    vector<artikelverfallS>::iterator
                 endList  () { return lst.end  (); }

    short        GetFilialnr() const { return s.FILIALNR; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetDatumverfall() const { return s.DATUMVERFALL; }

    const artikelverfallS &
                 GetStruct() const { return s; }
    void         SetFilialnr(short t) { s.FILIALNR = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetDatumverfall(long t) { s.DATUMVERFALL = t; }

    void         SetStruct(const artikelverfallS & t) { s = t; }

    int          CheckShortExpiry(int pos = 0) { int ret = UniqueServerCall(1575, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CARTIKELVERFALL() {
        ::buf_default((void *)&s, ARTIKELVERFALL_BES, ARTIKELVERFALL_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CARTIKELVERFALL() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ARTIKELVERFALL_BES, ARTIKELVERFALL_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1575 ) return UniqueServerCall(1575, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ARTIKELVERFALL & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ARTIKELVERFALL_BES, (int)ARTIKELVERFALL_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CATICLEAUX : public ppDadeVirtual {
public:
    aticleauxS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<aticleauxS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< aticleauxS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     aticleauxS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< aticleauxS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<aticleauxS>::iterator
                 beginList() { return lst.begin(); }
    vector<aticleauxS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    short        GetRanking() const { return s.RANKING; }
    short        GetAuxbranchno() const { return s.AUXBRANCHNO; }

    const aticleauxS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetRanking(short t) { s.RANKING = t; }
    void         SetAuxbranchno(short t) { s.AUXBRANCHNO = t; }

    void         SetStruct(const aticleauxS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Delete(int pos = 0) { return UniqueServerCall(1465, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1464, pos); Strip(s); return ret; }
    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1462, FetchRel, pos); return ret; }
    int          Update(int pos = 0) { int ret = UniqueServerCall(1463, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CATICLEAUX() {
        ::buf_default((void *)&s, ATICLEAUX_BES, ATICLEAUX_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CATICLEAUX() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, ATICLEAUX_BES, ATICLEAUX_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ATICLEAUX_BES, (int)ATICLEAUX_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1465 ) return UniqueServerCall(1465, pos);
        if ( fkt_nr == 1464 ) return UniqueServerCall(1464, pos);
        if ( fkt_nr == 1462 ) return CursorServerCall(1462, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1463 ) return UniqueServerCall(1463, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_ATICLEAUX & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, ATICLEAUX_BES, (int)ATICLEAUX_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CATICLEAUX c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, ATICLEAUX_BES, (int)ATICLEAUX_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CCCODE : public ppDadeVirtual {
public:
    ccodeS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<ccodeS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< ccodeS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     ccodeS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< ccodeS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<ccodeS>::iterator
                 beginList() { return lst.begin(); }
    vector<ccodeS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    const char*  GetInfocode(ppString & t) const { t = s.INFOCODE; t.erasespace(ppString::END); return t.c_str(); }
    char         GetArticleactiv() const { return s.ARTICLEACTIV[0]; }
    char         GetAuxdelivery() const { return s.AUXDELIVERY[0]; }
    const char*  GetSeracode(ppString & t) const { t = s.SERACODE; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetPrintcode(ppString & t) const { t = s.PRINTCODE; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetXmlcode(ppString & t) const { t = s.XMLCODE; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetXmltext(ppString & t) const { t = s.XMLTEXT; t.erasespace(ppString::END); return t.c_str(); }

    const ccodeS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetInfocode(const ppString & t) { ppGStrCopy(s.INFOCODE, t.c_str(), L_CCODE_INFOCODE); }
    void         SetArticleactiv(char t) { s.ARTICLEACTIV[0] = t; s.ARTICLEACTIV[1] = '\0';}
    void         SetAuxdelivery(char t) { s.AUXDELIVERY[0] = t; s.AUXDELIVERY[1] = '\0';}
    void         SetSeracode(const ppString & t) { ppGStrCopy(s.SERACODE, t.c_str(), L_CCODE_SERACODE); }
    void         SetPrintcode(const ppString & t) { ppGStrCopy(s.PRINTCODE, t.c_str(), L_CCODE_PRINTCODE); }
    void         SetXmlcode(const ppString & t) { ppGStrCopy(s.XMLCODE, t.c_str(), L_CCODE_XMLCODE); }
    void         SetXmltext(const ppString & t) { ppGStrCopy(s.XMLTEXT, t.c_str(), L_CCODE_XMLTEXT); }

    void         SetStruct(const ccodeS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Delete(int pos = 0) { return UniqueServerCall(1427, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1428, pos); Strip(s); return ret; }
    int          Sel(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1426, FetchRel, pos); return ret; }
    int          Update(int pos = 0) { int ret = UniqueServerCall(1429, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CCCODE() {
        ::buf_default((void *)&s, CCODE_BES, CCODE_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CCCODE() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, CCODE_BES, CCODE_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, CCODE_BES, (int)CCODE_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1427 ) return UniqueServerCall(1427, pos);
        if ( fkt_nr == 1428 ) return UniqueServerCall(1428, pos);
        if ( fkt_nr == 1426 ) return CursorServerCall(1426, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1429 ) return UniqueServerCall(1429, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_CCODE & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.INFOCODE);
        ppGStripLast(d.SERACODE);
        ppGStripLast(d.PRINTCODE);
        ppGStripLast(d.XMLCODE);
        ppGStripLast(d.XMLTEXT);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, CCODE_BES, (int)CCODE_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CCCODE c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, CCODE_BES, (int)CCODE_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CCHECKIMEXBLOCKEXIST : public ppDadeVirtual {
public:
    checkimexblockexistS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<checkimexblockexistS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< checkimexblockexistS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     checkimexblockexistS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< checkimexblockexistS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<checkimexblockexistS>::iterator
                 beginList() { return lst.begin(); }
    vector<checkimexblockexistS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticleno() const { return s.ARTICLENO; }

    const checkimexblockexistS &
                 GetStruct() const { return s; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }

    void         SetStruct(const checkimexblockexistS & t) { s = t; }

    int          SelExist(int pos = 0) { int ret = UniqueServerCall(1774, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CCHECKIMEXBLOCKEXIST() {
        ::buf_default((void *)&s, CHECKIMEXBLOCKEXIST_BES, CHECKIMEXBLOCKEXIST_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CCHECKIMEXBLOCKEXIST() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, CHECKIMEXBLOCKEXIST_BES, CHECKIMEXBLOCKEXIST_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1774 ) return UniqueServerCall(1774, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_CHECKIMEXBLOCKEXIST & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, CHECKIMEXBLOCKEXIST_BES, (int)CHECKIMEXBLOCKEXIST_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CCHECKIMPORTARTICLE : public ppDadeVirtual {
public:
    checkimportarticleS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<checkimportarticleS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< checkimportarticleS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     checkimportarticleS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< checkimportarticleS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<checkimportarticleS>::iterator
                 beginList() { return lst.begin(); }
    vector<checkimportarticleS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    short        GetImportarticle() const { return s.IMPORTARTICLE; }

    const checkimportarticleS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetImportarticle(short t) { s.IMPORTARTICLE = t; }

    void         SetStruct(const checkimportarticleS & t) { s = t; }

    int          SelImport(int pos = 0) { int ret = UniqueServerCall(1778, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CCHECKIMPORTARTICLE() {
        ::buf_default((void *)&s, CHECKIMPORTARTICLE_BES, CHECKIMPORTARTICLE_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CCHECKIMPORTARTICLE() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, CHECKIMPORTARTICLE_BES, CHECKIMPORTARTICLE_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1778 ) return UniqueServerCall(1778, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_CHECKIMPORTARTICLE & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, CHECKIMPORTARTICLE_BES, (int)CHECKIMPORTARTICLE_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CCHECKLISTE5ZENTRAL : public ppDadeVirtual {
public:
    checkliste5zentralS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<checkliste5zentralS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< checkliste5zentralS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     checkliste5zentralS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< checkliste5zentralS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<checkliste5zentralS>::iterator
                 beginList() { return lst.begin(); }
    vector<checkliste5zentralS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }

    const checkliste5zentralS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }

    void         SetStruct(const checkliste5zentralS & t) { s = t; }

    int          IsListe5(int pos = 0) { int ret = UniqueServerCall(1599, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CCHECKLISTE5ZENTRAL() {
        ::buf_default((void *)&s, CHECKLISTE5ZENTRAL_BES, CHECKLISTE5ZENTRAL_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CCHECKLISTE5ZENTRAL() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, CHECKLISTE5ZENTRAL_BES, CHECKLISTE5ZENTRAL_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1599 ) return UniqueServerCall(1599, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_CHECKLISTE5ZENTRAL & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, CHECKLISTE5ZENTRAL_BES, (int)CHECKLISTE5ZENTRAL_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CCODEBLOCAGEINFO : public ppDadeVirtual {
public:
    codeblocageinfoS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<codeblocageinfoS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< codeblocageinfoS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     codeblocageinfoS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< codeblocageinfoS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<codeblocageinfoS>::iterator
                 beginList() { return lst.begin(); }
    vector<codeblocageinfoS>::iterator
                 endList  () { return lst.end  (); }

    const char*  GetPrintcode(ppString & t) const { t = s.PRINTCODE; t.erasespace(ppString::END); return t.c_str(); }
    short        GetFilialnr() const { return s.FILIALNR; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }

    const codeblocageinfoS &
                 GetStruct() const { return s; }
    void         SetPrintcode(const ppString & t) { ppGStrCopy(s.PRINTCODE, t.c_str(), L_CODEBLOCAGEINFO_PRINTCODE); }
    void         SetFilialnr(short t) { s.FILIALNR = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }

    void         SetStruct(const codeblocageinfoS & t) { s = t; }

    int          SelText(int pos = 0) { int ret = UniqueServerCall(1441, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CCODEBLOCAGEINFO() {
        ::buf_default((void *)&s, CODEBLOCAGEINFO_BES, CODEBLOCAGEINFO_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CCODEBLOCAGEINFO() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, CODEBLOCAGEINFO_BES, CODEBLOCAGEINFO_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1441 ) return UniqueServerCall(1441, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_CODEBLOCAGEINFO & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.PRINTCODE);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, CODEBLOCAGEINFO_BES, (int)CODEBLOCAGEINFO_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CDISPOINFO : public ppDadeVirtual {
public:
    dispoinfoS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<dispoinfoS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< dispoinfoS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     dispoinfoS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< dispoinfoS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<dispoinfoS>::iterator
                 beginList() { return lst.begin(); }
    vector<dispoinfoS>::iterator
                 endList  () { return lst.end  (); }

    const char*  GetBezeichnung(ppString & t) const { t = s.BEZEICHNUNG; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetDispo_hinweis(ppString & t) const { t = s.DISPO_HINWEIS; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetBemerkung(ppString & t) const { t = s.BEMERKUNG; t.erasespace(ppString::END); return t.c_str(); }
    long         GetPzn() const { return s.PZN; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetHersteller_nr() const { return s.HERSTELLER_NR; }

    const dispoinfoS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBezeichnung(const ppString & t) { ppGStrCopy(s.BEZEICHNUNG, t.c_str(), L_DISPOINFO_BEZEICHNUNG); }
    void         SetDispo_hinweis(const ppString & t) { ppGStrCopy(s.DISPO_HINWEIS, t.c_str(), L_DISPOINFO_DISPO_HINWEIS); }
    void         SetBemerkung(const ppString & t) { ppGStrCopy(s.BEMERKUNG, t.c_str(), L_DISPOINFO_BEMERKUNG); }
    void         SetPzn(long t) { s.PZN = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetHersteller_nr(long t) { s.HERSTELLER_NR = t; }

    void         SetStruct(const dispoinfoS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelDispoInfo(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1480, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CDISPOINFO() {
        ::buf_default((void *)&s, DISPOINFO_BES, DISPOINFO_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CDISPOINFO() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, DISPOINFO_BES, DISPOINFO_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, DISPOINFO_BES, (int)DISPOINFO_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1480 ) return CursorServerCall(1480, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_DISPOINFO & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.BEZEICHNUNG);
        ppGStripLast(d.DISPO_HINWEIS);
        ppGStripLast(d.BEMERKUNG);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, DISPOINFO_BES, (int)DISPOINFO_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CDISPOINFO c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, DISPOINFO_BES, (int)DISPOINFO_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CHERSTELLER : public ppDadeVirtual {
public:
    herstellerS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<herstellerS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< herstellerS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     herstellerS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< herstellerS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<herstellerS>::iterator
                 beginList() { return lst.begin(); }
    vector<herstellerS>::iterator
                 endList  () { return lst.end  (); }

    const char*  GetName(ppString & t) const { t = s.NAME; t.erasespace(ppString::END); return t.c_str(); }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }

    const herstellerS &
                 GetStruct() const { return s; }
    void         SetName(const ppString & t) { ppGStrCopy(s.NAME, t.c_str(), L_HERSTELLER_NAME); }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }

    void         SetStruct(const herstellerS & t) { s = t; }

    int          SelHersteller(int pos = 0) { int ret = UniqueServerCall(1550, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CHERSTELLER() {
        ::buf_default((void *)&s, HERSTELLER_BES, HERSTELLER_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CHERSTELLER() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, HERSTELLER_BES, HERSTELLER_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1550 ) return UniqueServerCall(1550, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_HERSTELLER & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, HERSTELLER_BES, (int)HERSTELLER_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CLPPRCODE : public ppDadeVirtual {
public:
    lpprcodeS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<lpprcodeS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< lpprcodeS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     lpprcodeS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< lpprcodeS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<lpprcodeS>::iterator
                 beginList() { return lst.begin(); }
    vector<lpprcodeS>::iterator
                 endList  () { return lst.end  (); }

    const char*  GetCode_lppr(ppString & t) const { t = s.CODE_LPPR; t.erasespace(ppString::END); return t.c_str(); }
    double       GetReimbursement_val() const { return s.REIMBURSEMENT_VAL; }

    const lpprcodeS &
                 GetStruct() const { return s; }
    void         SetCode_lppr(const ppString & t) { ppGStrCopy(s.CODE_LPPR, t.c_str(), L_LPPRCODE_CODE_LPPR); }
    void         SetReimbursement_val(double t) { s.REIMBURSEMENT_VAL = t; }

    void         SetStruct(const lpprcodeS & t) { s = t; }

    int          Sel(int pos = 0) { int ret = UniqueServerCall(1444, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CLPPRCODE() {
        ::buf_default((void *)&s, LPPRCODE_BES, LPPRCODE_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CLPPRCODE() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, LPPRCODE_BES, LPPRCODE_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1444 ) return UniqueServerCall(1444, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_LPPRCODE & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.CODE_LPPR);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, LPPRCODE_BES, (int)LPPRCODE_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CMAXARTICLEQUOTA : public ppDadeVirtual {
public:
    maxarticlequotaS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<maxarticlequotaS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< maxarticlequotaS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     maxarticlequotaS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< maxarticlequotaS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<maxarticlequotaS>::iterator
                 beginList() { return lst.begin(); }
    vector<maxarticlequotaS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetMaxquota() const { return s.MAXQUOTA; }

    const maxarticlequotaS &
                 GetStruct() const { return s; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetMaxquota(long t) { s.MAXQUOTA = t; }

    void         SetStruct(const maxarticlequotaS & t) { s = t; }

    int          SelMax(int pos = 0) { int ret = UniqueServerCall(1395, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CMAXARTICLEQUOTA() {
        ::buf_default((void *)&s, MAXARTICLEQUOTA_BES, MAXARTICLEQUOTA_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CMAXARTICLEQUOTA() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, MAXARTICLEQUOTA_BES, MAXARTICLEQUOTA_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1395 ) return UniqueServerCall(1395, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_MAXARTICLEQUOTA & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, MAXARTICLEQUOTA_BES, (int)MAXARTICLEQUOTA_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class COCCASION : public ppDadeVirtual {
public:
    occasionS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<occasionS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< occasionS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     occasionS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< occasionS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<occasionS>::iterator
                 beginList() { return lst.begin(); }
    vector<occasionS>::iterator
                 endList  () { return lst.end  (); }

    long         GetCustomerno() const { return s.CUSTOMERNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    short        GetBranchno() const { return s.BRANCHNO; }
    double       GetDiscountvaluepct() const { return s.DISCOUNTVALUEPCT; }

    const occasionS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetDiscountvaluepct(double t) { s.DISCOUNTVALUEPCT = t; }

    void         SetStruct(const occasionS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1496, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    COCCASION() {
        ::buf_default((void *)&s, OCCASION_BES, OCCASION_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~COCCASION() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, OCCASION_BES, OCCASION_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, OCCASION_BES, (int)OCCASION_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1496 ) return CursorServerCall(1496, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_OCCASION & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, OCCASION_BES, (int)OCCASION_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        COCCASION c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, OCCASION_BES, (int)OCCASION_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CPHARMGRP : public ppDadeVirtual {
public:
    pharmgrpS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<pharmgrpS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< pharmgrpS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     pharmgrpS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< pharmgrpS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<pharmgrpS>::iterator
                 beginList() { return lst.begin(); }
    vector<pharmgrpS>::iterator
                 endList  () { return lst.end  (); }

    const char*  GetPharmacygroupid(ppString & t) const { t = s.PHARMACYGROUPID; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetGroup_name(ppString & t) const { t = s.GROUP_NAME; t.erasespace(ppString::END); return t.c_str(); }
    char         GetGroup_type() const { return s.GROUP_TYPE[0]; }
    double       GetPercent() const { return s.PERCENT; }
    double       GetContribution() const { return s.CONTRIBUTION; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    char         GetOmg_own_cont() const { return s.OMG_OWN_CONT[0]; }
    char         GetPrice_basis_purch() const { return s.PRICE_BASIS_PURCH[0]; }
    char         GetReclaim_omg_disc() const { return s.RECLAIM_OMG_DISC[0]; }
    short        GetSpecialgroup() const { return s.SPECIALGROUP; }
    long         GetSpecialgrouprefno() const { return s.SPECIALGROUPREFNO; }
    short        GetGrouping_vis() const { return s.GROUPING_VIS; }
    short        GetBranchno() const { return s.BRANCHNO; }

    const pharmgrpS &
                 GetStruct() const { return s; }
    void         SetPharmacygroupid(const ppString & t) { ppGStrCopy(s.PHARMACYGROUPID, t.c_str(), L_PHARMGRP_PHARMACYGROUPID); }
    void         SetGroup_name(const ppString & t) { ppGStrCopy(s.GROUP_NAME, t.c_str(), L_PHARMGRP_GROUP_NAME); }
    void         SetGroup_type(char t) { s.GROUP_TYPE[0] = t; s.GROUP_TYPE[1] = '\0';}
    void         SetPercent(double t) { s.PERCENT = t; }
    void         SetContribution(double t) { s.CONTRIBUTION = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetOmg_own_cont(char t) { s.OMG_OWN_CONT[0] = t; s.OMG_OWN_CONT[1] = '\0';}
    void         SetPrice_basis_purch(char t) { s.PRICE_BASIS_PURCH[0] = t; s.PRICE_BASIS_PURCH[1] = '\0';}
    void         SetReclaim_omg_disc(char t) { s.RECLAIM_OMG_DISC[0] = t; s.RECLAIM_OMG_DISC[1] = '\0';}
    void         SetSpecialgroup(short t) { s.SPECIALGROUP = t; }
    void         SetSpecialgrouprefno(long t) { s.SPECIALGROUPREFNO = t; }
    void         SetGrouping_vis(short t) { s.GROUPING_VIS = t; }
    void         SetBranchno(short t) { s.BRANCHNO = t; }

    void         SetStruct(const pharmgrpS & t) { s = t; }

    int          Sel(int pos = 0) { int ret = UniqueServerCall(1442, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CPHARMGRP() {
        ::buf_default((void *)&s, PHARMGRP_BES, PHARMGRP_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CPHARMGRP() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, PHARMGRP_BES, PHARMGRP_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1442 ) return UniqueServerCall(1442, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_PHARMGRP & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.PHARMACYGROUPID);
        ppGStripLast(d.GROUP_NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, PHARMGRP_BES, (int)PHARMGRP_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CPREISANZTYP : public ppDadeVirtual {
public:
    preisanztypS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<preisanztypS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< preisanztypS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     preisanztypS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< preisanztypS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<preisanztypS>::iterator
                 beginList() { return lst.begin(); }
    vector<preisanztypS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    double       GetPreisekapo() const { return s.PREISEKAPO; }
    double       GetPreisekgrosso() const { return s.PREISEKGROSSO; }
    double       GetPreisekgrossona() const { return s.PREISEKGROSSONA; }
    short        GetPreis_typ() const { return s.PREIS_TYP; }

    const preisanztypS &
                 GetStruct() const { return s; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetPreisekapo(double t) { s.PREISEKAPO = t; }
    void         SetPreisekgrosso(double t) { s.PREISEKGROSSO = t; }
    void         SetPreisekgrossona(double t) { s.PREISEKGROSSONA = t; }
    void         SetPreis_typ(short t) { s.PREIS_TYP = t; }

    void         SetStruct(const preisanztypS & t) { s = t; }

    int          SelPreis(int pos = 0) { int ret = UniqueServerCall(1519, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CPREISANZTYP() {
        ::buf_default((void *)&s, PREISANZTYP_BES, PREISANZTYP_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CPREISANZTYP() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, PREISANZTYP_BES, PREISANZTYP_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1519 ) return UniqueServerCall(1519, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_PREISANZTYP & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, PREISANZTYP_BES, (int)PREISANZTYP_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CPRICEHIST : public ppDadeVirtual {
public:
    pricehistS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<pricehistS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< pricehistS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     pricehistS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< pricehistS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<pricehistS>::iterator
                 beginList() { return lst.begin(); }
    vector<pricehistS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetDatumgueltigab() const { return s.DATUMGUELTIGAB; }
    double       GetGrosso() const { return s.GROSSO; }
    double       GetAep() const { return s.AEP; }
    double       GetAvp() const { return s.AVP; }

    const pricehistS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetDatumgueltigab(long t) { s.DATUMGUELTIGAB = t; }
    void         SetGrosso(double t) { s.GROSSO = t; }
    void         SetAep(double t) { s.AEP = t; }
    void         SetAvp(double t) { s.AVP = t; }

    void         SetStruct(const pricehistS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Sel(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1443, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CPRICEHIST() {
        ::buf_default((void *)&s, PRICEHIST_BES, PRICEHIST_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CPRICEHIST() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, PRICEHIST_BES, PRICEHIST_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, PRICEHIST_BES, (int)PRICEHIST_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1443 ) return CursorServerCall(1443, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_PRICEHIST & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, PRICEHIST_BES, (int)PRICEHIST_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CPRICEHIST c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, PRICEHIST_BES, (int)PRICEHIST_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CPROMOANZ : public ppDadeVirtual {
public:
    promoanzS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<promoanzS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< promoanzS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     promoanzS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< promoanzS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<promoanzS>::iterator
                 beginList() { return lst.begin(); }
    vector<promoanzS>::iterator
                 endList  () { return lst.end  (); }

    short        GetPromotion_no() const { return s.PROMOTION_NO; }
    const char*  GetName(ppString & t) const { t = s.NAME; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetDescription(ppString & t) const { t = s.DESCRIPTION; t.erasespace(ppString::END); return t.c_str(); }
    short        GetPromotion_type() const { return s.PROMOTION_TYPE; }

    const promoanzS &
                 GetStruct() const { return s; }
    void         SetPromotion_no(short t) { s.PROMOTION_NO = t; }
    void         SetName(const ppString & t) { ppGStrCopy(s.NAME, t.c_str(), L_PROMOANZ_NAME); }
    void         SetDescription(const ppString & t) { ppGStrCopy(s.DESCRIPTION, t.c_str(), L_PROMOANZ_DESCRIPTION); }
    void         SetPromotion_type(short t) { s.PROMOTION_TYPE = t; }

    void         SetStruct(const promoanzS & t) { s = t; }

    int          SelPromo(int pos = 0) { int ret = UniqueServerCall(1518, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CPROMOANZ() {
        ::buf_default((void *)&s, PROMOANZ_BES, PROMOANZ_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CPROMOANZ() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, PROMOANZ_BES, PROMOANZ_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1518 ) return UniqueServerCall(1518, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_PROMOANZ & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.NAME);
        ppGStripLast(d.DESCRIPTION);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, PROMOANZ_BES, (int)PROMOANZ_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CREIMPORT : public ppDadeVirtual {
public:
    reimportS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<reimportS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< reimportS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     reimportS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< reimportS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<reimportS>::iterator
                 beginList() { return lst.begin(); }
    vector<reimportS>::iterator
                 endList  () { return lst.end  (); }

    const char*  GetDarreichform(ppString & t) const { t = s.DARREICHFORM; t.erasespace(ppString::END); return t.c_str(); }
    double       GetPreisekapo() const { return s.PREISEKAPO; }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }
    long         GetBestand() const { return s.BESTAND; }
    long         GetPzn() const { return s.PZN; }

    const reimportS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetDarreichform(const ppString & t) { ppGStrCopy(s.DARREICHFORM, t.c_str(), L_REIMPORT_DARREICHFORM); }
    void         SetPreisekapo(double t) { s.PREISEKAPO = t; }
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_REIMPORT_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_REIMPORT_ARTIKEL_NAME); }
    void         SetBestand(long t) { s.BESTAND = t; }
    void         SetPzn(long t) { s.PZN = t; }

    void         SetStruct(const reimportS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelAuswahl(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1238, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CREIMPORT() {
        ::buf_default((void *)&s, REIMPORT_BES, REIMPORT_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CREIMPORT() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, REIMPORT_BES, REIMPORT_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, REIMPORT_BES, (int)REIMPORT_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1238 ) return CursorServerCall(1238, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_REIMPORT & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.DARREICHFORM);
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, REIMPORT_BES, (int)REIMPORT_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CREIMPORT c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, REIMPORT_BES, (int)REIMPORT_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTELLER : public ppDadeVirtual {
public:
    stellerS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stellerS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stellerS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stellerS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stellerS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stellerS>::iterator
                 beginList() { return lst.begin(); }
    vector<stellerS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticle_no_pack() const { return s.ARTICLE_NO_PACK; }
    long         GetArticle_no_element() const { return s.ARTICLE_NO_ELEMENT; }
    long         GetQuantity() const { return s.QUANTITY; }
    short        GetFilialnr() const { return s.FILIALNR; }
    long         GetBestand() const { return s.BESTAND; }
    const char*  GetDarreichform(ppString & t) const { t = s.DARREICHFORM; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_langname(ppString & t) const { t = s.ARTIKEL_LANGNAME; t.erasespace(ppString::END); return t.c_str(); }

    const stellerS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetArticle_no_pack(long t) { s.ARTICLE_NO_PACK = t; }
    void         SetArticle_no_element(long t) { s.ARTICLE_NO_ELEMENT = t; }
    void         SetQuantity(long t) { s.QUANTITY = t; }
    void         SetFilialnr(short t) { s.FILIALNR = t; }
    void         SetBestand(long t) { s.BESTAND = t; }
    void         SetDarreichform(const ppString & t) { ppGStrCopy(s.DARREICHFORM, t.c_str(), L_STELLER_DARREICHFORM); }
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_STELLER_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_STELLER_ARTIKEL_NAME); }
    void         SetArtikel_langname(const ppString & t) { ppGStrCopy(s.ARTIKEL_LANGNAME, t.c_str(), L_STELLER_ARTIKEL_LANGNAME); }

    void         SetStruct(const stellerS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1501, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTELLER() {
        ::buf_default((void *)&s, STELLER_BES, STELLER_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTELLER() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STELLER_BES, STELLER_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STELLER_BES, (int)STELLER_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1501 ) return CursorServerCall(1501, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STELLER & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.DARREICHFORM);
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
        ppGStripLast(d.ARTIKEL_LANGNAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STELLER_BES, (int)STELLER_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTELLER c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STELLER_BES, (int)STELLER_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTELLERTYP : public ppDadeVirtual {
public:
    stellertypS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stellertypS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stellertypS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stellertypS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stellertypS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stellertypS>::iterator
                 beginList() { return lst.begin(); }
    vector<stellertypS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticle_no_pack() const { return s.ARTICLE_NO_PACK; }
    long         GetDatefrom() const { return s.DATEFROM; }
    long         GetDateto() const { return s.DATETO; }
    short        GetCompack_type() const { return s.COMPACK_TYPE; }

    const stellertypS &
                 GetStruct() const { return s; }
    void         SetArticle_no_pack(long t) { s.ARTICLE_NO_PACK = t; }
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetDateto(long t) { s.DATETO = t; }
    void         SetCompack_type(short t) { s.COMPACK_TYPE = t; }

    void         SetStruct(const stellertypS & t) { s = t; }

    int          SelTyp(int pos = 0) { int ret = UniqueServerCall(1530, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTELLERTYP() {
        ::buf_default((void *)&s, STELLERTYP_BES, STELLERTYP_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTELLERTYP() {
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STELLERTYP_BES, STELLERTYP_ANZ);
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1530 ) return UniqueServerCall(1530, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STELLERTYP & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STELLERTYP_BES, (int)STELLERTYP_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }
};

class CSTOCKRESERVATION : public ppDadeVirtual {
public:
    stockreservationS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockreservationS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stockreservationS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stockreservationS>::iterator
                 beginList() { return lst.begin(); }
    vector<stockreservationS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    const char*  GetArticle_code(ppString & t) const { t = s.ARTICLE_CODE; t.erasespace(ppString::END); return t.c_str(); }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetReservedqty() const { return s.RESERVEDQTY; }
    long         GetDatefrom() const { return s.DATEFROM; }
    long         GetTimefrom() const { return s.TIMEFROM; }
    long         GetDateto() const { return s.DATETO; }
    long         GetTimeto() const { return s.TIMETO; }
    long         GetKdauftragnr() const { return s.KDAUFTRAGNR; }
    short        GetReservtype() const { return s.RESERVTYPE; }

    const stockreservationS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetArticle_code(const ppString & t) { ppGStrCopy(s.ARTICLE_CODE, t.c_str(), L_STOCKRESERVATION_ARTICLE_CODE); }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetReservedqty(long t) { s.RESERVEDQTY = t; }
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetTimefrom(long t) { s.TIMEFROM = t; }
    void         SetDateto(long t) { s.DATETO = t; }
    void         SetTimeto(long t) { s.TIMETO = t; }
    void         SetKdauftragnr(long t) { s.KDAUFTRAGNR = t; }
    void         SetReservtype(short t) { s.RESERVTYPE = t; }

    void         SetStruct(const stockreservationS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          DeleteEntry(int pos = 0) { int ret = UniqueServerCall(1797, pos); Strip(s); return ret; }
    int          SelSum(int pos = 0) { int ret = UniqueServerCall(1618, pos); Strip(s); return ret; }
    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1619, FetchRel, pos); return ret; }
    int          SelListAll(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1806, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKRESERVATION() {
        ::buf_default((void *)&s, STOCKRESERVATION_BES, STOCKRESERVATION_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKRESERVATION() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STOCKRESERVATION_BES, STOCKRESERVATION_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATION_BES, (int)STOCKRESERVATION_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1797 ) return UniqueServerCall(1797, pos);
        if ( fkt_nr == 1806 ) return CursorServerCall(1806, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1619 ) return CursorServerCall(1619, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1618 ) return UniqueServerCall(1618, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STOCKRESERVATION & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.ARTICLE_CODE);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STOCKRESERVATION_BES, (int)STOCKRESERVATION_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKRESERVATION c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATION_BES, (int)STOCKRESERVATION_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTOCKRESERVATIONARTICLERESERV : public ppDadeVirtual {
public:
    stockreservationarticlereservS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockreservationarticlereservS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationarticlereservS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stockreservationarticlereservS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationarticlereservS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stockreservationarticlereservS>::iterator
                 beginList() { return lst.begin(); }
    vector<stockreservationarticlereservS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    const char*  GetPharmacygroupid(ppString & t) const { t = s.PHARMACYGROUPID; t.erasespace(ppString::END); return t.c_str(); }
    long         GetArticleno() const { return s.ARTICLENO; }
    short        GetReservtype() const { return s.RESERVTYPE; }
    long         GetMaxqty() const { return s.MAXQTY; }
    long         GetReservedqty() const { return s.RESERVEDQTY; }

    const stockreservationarticlereservS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetPharmacygroupid(const ppString & t) { ppGStrCopy(s.PHARMACYGROUPID, t.c_str(), L_STOCKRESERVATIONARTICLERESERV_PHARMACYGROUPID); }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetReservtype(short t) { s.RESERVTYPE = t; }
    void         SetMaxqty(long t) { s.MAXQTY = t; }
    void         SetReservedqty(long t) { s.RESERVEDQTY = t; }

    void         SetStruct(const stockreservationarticlereservS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelArticleReservation(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1804, FetchRel, pos); return ret; }
    int          UpdateArticleReservation(int pos = 0) { int ret = UniqueServerCall(1805, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKRESERVATIONARTICLERESERV() {
        ::buf_default((void *)&s, STOCKRESERVATIONARTICLERESERV_BES, STOCKRESERVATIONARTICLERESERV_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKRESERVATIONARTICLERESERV() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STOCKRESERVATIONARTICLERESERV_BES, STOCKRESERVATIONARTICLERESERV_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATIONARTICLERESERV_BES, (int)STOCKRESERVATIONARTICLERESERV_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1804 ) return CursorServerCall(1804, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1805 ) return UniqueServerCall(1805, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STOCKRESERVATIONARTICLERESERV & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.PHARMACYGROUPID);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STOCKRESERVATIONARTICLERESERV_BES, (int)STOCKRESERVATIONARTICLERESERV_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKRESERVATIONARTICLERESERV c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATIONARTICLERESERV_BES, (int)STOCKRESERVATIONARTICLERESERV_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTOCKRESERVATIONARTIKELLOKAL : public ppDadeVirtual {
public:
    stockreservationartikellokalS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockreservationartikellokalS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationartikellokalS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stockreservationartikellokalS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationartikellokalS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stockreservationartikellokalS>::iterator
                 beginList() { return lst.begin(); }
    vector<stockreservationartikellokalS>::iterator
                 endList  () { return lst.end  (); }

    short        GetFilialnr() const { return s.FILIALNR; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetBestand() const { return s.BESTAND; }
    short        GetLagerbereichnr() const { return s.LAGERBEREICHNR; }
    const char*  GetStationnr(ppString & t) const { t = s.STATIONNR; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetLagerfachnr(ppString & t) const { t = s.LAGERFACHNR; t.erasespace(ppString::END); return t.c_str(); }

    const stockreservationartikellokalS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetFilialnr(short t) { s.FILIALNR = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetBestand(long t) { s.BESTAND = t; }
    void         SetLagerbereichnr(short t) { s.LAGERBEREICHNR = t; }
    void         SetStationnr(const ppString & t) { ppGStrCopy(s.STATIONNR, t.c_str(), L_STOCKRESERVATIONARTIKELLOKAL_STATIONNR); }
    void         SetLagerfachnr(const ppString & t) { ppGStrCopy(s.LAGERFACHNR, t.c_str(), L_STOCKRESERVATIONARTIKELLOKAL_LAGERFACHNR); }

    void         SetStruct(const stockreservationartikellokalS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelArtikelLokal(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1801, FetchRel, pos); return ret; }
    int          UpdateArtikelLokal(int pos = 0) { int ret = UniqueServerCall(1802, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKRESERVATIONARTIKELLOKAL() {
        ::buf_default((void *)&s, STOCKRESERVATIONARTIKELLOKAL_BES, STOCKRESERVATIONARTIKELLOKAL_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKRESERVATIONARTIKELLOKAL() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STOCKRESERVATIONARTIKELLOKAL_BES, STOCKRESERVATIONARTIKELLOKAL_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATIONARTIKELLOKAL_BES, (int)STOCKRESERVATIONARTIKELLOKAL_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1801 ) return CursorServerCall(1801, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1802 ) return UniqueServerCall(1802, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STOCKRESERVATIONARTIKELLOKAL & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.STATIONNR);
        ppGStripLast(d.LAGERFACHNR);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STOCKRESERVATIONARTIKELLOKAL_BES, (int)STOCKRESERVATIONARTIKELLOKAL_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKRESERVATIONARTIKELLOKAL c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATIONARTIKELLOKAL_BES, (int)STOCKRESERVATIONARTIKELLOKAL_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTOCKRESERVATIONIBTREQUEST : public ppDadeVirtual {
public:
    stockreservationibtrequestS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockreservationibtrequestS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
        if (GetSize() <= i)
            return false;
        s = lst.at(i);
        return true;
    }
    bool         SetList(const unsigned int i) {
        if (GetSize() <= i)
            return false;
        vector< stockreservationibtrequestS >::iterator it = lst.begin() + i;
        *it = s;
        return true;
    }
    bool         InsList() {
        Strip(s);
        stockreservationibtrequestS c = s;
        lst.insert(lst.end(), c);
        AnzPos++;
        return true;
    }
    bool         DelList(const unsigned int i) {
        if (GetSize() <= i)
            return false;
        vector< stockreservationibtrequestS >::iterator it = lst.begin() + i;
        if (it != lst.end())
            lst.erase(it);
        if (--AnzPos < 0)
            AnzPos = 0;
        return true;
    }

    vector<stockreservationibtrequestS>::iterator
        beginList() { return lst.begin(); }
    vector<stockreservationibtrequestS>::iterator
        endList() { return lst.end(); }

    long         GetIbtrequestid() const { return s.IBTREQUESTID; }
    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetCscorderno() const { return s.CSCORDERNO; }
    long         GetCscorderposno() const { return s.CSCORDERPOSNO; }
    long         GetDatefrom() const { return s.DATEFROM; }
    short        GetIbtbranchno() const { return s.IBTBRANCHNO; }
    long         GetIbtcustomerno() const { return s.IBTCUSTOMERNO; }
    long         GetTimefrom() const { return s.TIMEFROM; }
    short        GetProcessingstate() const { return s.PROCESSINGSTATE; }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetQuantity() const { return s.QUANTITY; }

    const stockreservationibtrequestS&
        GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetIbtrequestid(long t) { s.IBTREQUESTID = t; }
    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetCscorderno(long t) { s.CSCORDERNO = t; }
    void         SetCscorderposno(long t) { s.CSCORDERPOSNO = t; }
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetIbtbranchno(short t) { s.IBTBRANCHNO = t; }
    void         SetIbtcustomerno(long t) { s.IBTCUSTOMERNO = t; }
    void         SetTimefrom(long t) { s.TIMEFROM = t; }
    void         SetProcessingstate(short t) { s.PROCESSINGSTATE = t; }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetQuantity(long t) { s.QUANTITY = t; }

    void         SetStruct(const stockreservationibtrequestS& t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelIbtRequest(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1803, FetchRel, pos); return ret; }


    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKRESERVATIONIBTREQUEST() {
        ::buf_default((void*)&s, STOCKRESERVATIONIBTREQUEST_BES, STOCKRESERVATIONIBTREQUEST_ANZ);
        bOpenCursor = false;
        bEndOfSelect = false;
        FncNumber = 0;
        CursorPos = 0;
        AnzPos = 0;
        rc = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKRESERVATIONIBTREQUEST() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void*)&s, STOCKRESERVATIONIBTREQUEST_BES, STOCKRESERVATIONIBTREQUEST_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if (!bOpenCursor)
            return 0;
        s.FETCH_REL = 0;
#ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void*)&s, STOCKRESERVATIONIBTREQUEST_BES, (int)STOCKRESERVATIONIBTREQUEST_ANZ, error_msg);
#else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void*)&s, error_msg, &rc);
#endif
        bOpenCursor = false;
        bEndOfSelect = false;
        FncNumber = 0;
        CursorPos = 0;
        AnzPos = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
#ifdef WIN32
        rc = ::ServerNr(pos, fkt_nr, (void*)&s, STOCKRESERVATIONIBTREQUEST_BES, (int)STOCKRESERVATIONIBTREQUEST_ANZ, error_msg);
#else
        rc = ::Server(fkt_nr, (void*)&s, STOCKRESERVATIONIBTREQUEST_BES, (int)STOCKRESERVATIONIBTREQUEST_ANZ, error_msg);
#endif
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

private:
    void Strip(N_STOCKRESERVATIONIBTREQUEST& d) {
        d = d;
#ifdef WIN32
#endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
#ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNr, (void*)&s, STOCKRESERVATIONIBTREQUEST_BES, (int)STOCKRESERVATIONIBTREQUEST_ANZ, error_msg);
#else
        pos = pos;
        rc = DistributorFunSelect(FncNr, (void*)&s, error_msg, &rc);
#endif
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    int CursorServerCall(int FncNr, int FetchRel = 1, int pos = 0) {
        if (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel < 0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKRESERVATIONIBTREQUEST c;
        if (bOpenCursor && FncNumber != FncNr)
            CloseCursor(pos);
        if (bOpenCursor)
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber = FncNr;
            AnzPos = 0;
            lst.clear();
        }
        if ((CursorPos == AnzPos) && bEndOfSelect) {
            rc = 1;
            return 1;
        }
        else if (CursorPos < AnzPos) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
#ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void*)&s, STOCKRESERVATIONIBTREQUEST_BES, (int)STOCKRESERVATIONIBTREQUEST_ANZ, error_msg);
#else
        rc = DistributorFunSelect(FncNumber, (void*)&s, error_msg, &rc);
#endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
            0 :
            CursorPos + FetchRel - 1;
        if (CursorPos >= AnzPos) {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTOCKRESERVATIONNACHLIEFERPOS : public ppDadeVirtual {
public:
    stockreservationnachlieferposS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockreservationnachlieferposS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationnachlieferposS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stockreservationnachlieferposS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockreservationnachlieferposS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stockreservationnachlieferposS>::iterator
                 beginList() { return lst.begin(); }
    vector<stockreservationnachlieferposS>::iterator
                 endList  () { return lst.end  (); }

    long         GetKdauftragnr() const { return s.KDAUFTRAGNR; }
    long         GetPosnr() const { return s.POSNR; }
    long         GetDatum() const { return s.DATUM; }
    short        GetPostyp() const { return s.POSTYP; }
    long         GetIdfnr() const { return s.IDFNR; }
    long         GetArtikel_nr() const { return s.ARTIKEL_NR; }
    long         GetMenge() const { return s.MENGE; }
    long         GetStatus() const { return s.STATUS; }

    const stockreservationnachlieferposS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetKdauftragnr(long t) { s.KDAUFTRAGNR = t; }
    void         SetPosnr(long t) { s.POSNR = t; }
    void         SetDatum(long t) { s.DATUM = t; }
    void         SetPostyp(short t) { s.POSTYP = t; }
    void         SetIdfnr(long t) { s.IDFNR = t; }
    void         SetArtikel_nr(long t) { s.ARTIKEL_NR = t; }
    void         SetMenge(long t) { s.MENGE = t; }
    void         SetStatus(long t) { s.STATUS = t; }

    void         SetStruct(const stockreservationnachlieferposS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          DeleteNachlieferPos(int pos = 0) { int ret = UniqueServerCall(1800, pos); Strip(s); return ret; }
    int          SelNachlieferPos(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(STOCKRESERVATIONNACHLIEFERPOS_SELNACHLIEFERPOS, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKRESERVATIONNACHLIEFERPOS() {
        ::buf_default((void *)&s, STOCKRESERVATIONNACHLIEFERPOS_BES, STOCKRESERVATIONNACHLIEFERPOS_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKRESERVATIONNACHLIEFERPOS() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STOCKRESERVATIONNACHLIEFERPOS_BES, STOCKRESERVATIONNACHLIEFERPOS_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATIONNACHLIEFERPOS_BES, (int)STOCKRESERVATIONNACHLIEFERPOS_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1800 ) return UniqueServerCall(1800, pos);
        if ( fkt_nr == 1799 ) return CursorServerCall(1799, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STOCKRESERVATIONNACHLIEFERPOS & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STOCKRESERVATIONNACHLIEFERPOS_BES, (int)STOCKRESERVATIONNACHLIEFERPOS_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKRESERVATIONNACHLIEFERPOS c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKRESERVATIONNACHLIEFERPOS_BES, (int)STOCKRESERVATIONNACHLIEFERPOS_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTOCKRESERVATIONORDER : public ppDadeVirtual {
public:
    stockreservationorderS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockreservationorderS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
        if (GetSize() <= i)
            return false;
        s = lst.at(i);
        return true;
    }
    bool         SetList(const unsigned int i) {
        if (GetSize() <= i)
            return false;
        vector< stockreservationorderS >::iterator it = lst.begin() + i;
        *it = s;
        return true;
    }
    bool         InsList() {
        Strip(s);
        stockreservationorderS c = s;
        lst.insert(lst.end(), c);
        AnzPos++;
        return true;
    }
    bool         DelList(const unsigned int i) {
        if (GetSize() <= i)
            return false;
        vector< stockreservationorderS >::iterator it = lst.begin() + i;
        if (it != lst.end())
            lst.erase(it);
        if (--AnzPos < 0)
            AnzPos = 0;
        return true;
    }

    vector<stockreservationorderS>::iterator
        beginList() { return lst.begin(); }
    vector<stockreservationorderS>::iterator
        endList() { return lst.end(); }

    long         GetDatum() const { return s.DATUM; }
    long         GetKdauftragnr() const { return s.KDAUFTRAGNR; }
    const char* GetKdauftragstat(ppString& t) const { t = s.KDAUFTRAGSTAT; t.erasespace(ppString::END); return t.c_str(); }
    long         GetIdfnr() const { return s.IDFNR; }
    short        GetFilialnr() const { return s.FILIALNR; }
    const char* GetKdauftragart(ppString& t) const { t = s.KDAUFTRAGART; t.erasespace(ppString::END); return t.c_str(); }
    long         GetKundennr() const { return s.KUNDENNR; }
    const char* GetZugrund(ppString& t) const { t = s.ZUGRUND; t.erasespace(ppString::END); return t.c_str(); }

    const stockreservationorderS&
        GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetDatum(long t) { s.DATUM = t; }
    void         SetKdauftragnr(long t) { s.KDAUFTRAGNR = t; }
    void         SetKdauftragstat(const ppString& t) { ppGStrCopy(s.KDAUFTRAGSTAT, t.c_str(), L_STOCKRESERVATIONORDER_KDAUFTRAGSTAT); }
    void         SetIdfnr(long t) { s.IDFNR = t; }
    void         SetFilialnr(short t) { s.FILIALNR = t; }
    void         SetKdauftragart(const ppString& t) { ppGStrCopy(s.KDAUFTRAGART, t.c_str(), L_STOCKRESERVATIONORDER_KDAUFTRAGART); }
    void         SetKundennr(long t) { s.KUNDENNR = t; }
    void         SetZugrund(const ppString& t) { ppGStrCopy(s.ZUGRUND, t.c_str(), L_STOCKRESERVATIONORDER_ZUGRUND); }

    void         SetStruct(const stockreservationorderS& t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }
    int          SelOrder(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1798, FetchRel, pos); return ret; }


    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKRESERVATIONORDER() {
        ::buf_default((void*)&s, STOCKRESERVATIONORDER_BES, STOCKRESERVATIONORDER_ANZ);
        bOpenCursor = false;
        bEndOfSelect = false;
        FncNumber = 0;
        CursorPos = 0;
        AnzPos = 0;
        rc = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKRESERVATIONORDER() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void*)&s, STOCKRESERVATIONORDER_BES, STOCKRESERVATIONORDER_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if (!bOpenCursor)
            return 0;
        s.FETCH_REL = 0;
#ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void*)&s, STOCKRESERVATIONORDER_BES, (int)STOCKRESERVATIONORDER_ANZ, error_msg);
#else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void*)&s, error_msg, &rc);
#endif
        bOpenCursor = false;
        bEndOfSelect = false;
        FncNumber = 0;
        CursorPos = 0;
        AnzPos = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if (fkt_nr == 1798) return CursorServerCall(1798, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
    }

private:
    void Strip(N_STOCKRESERVATIONORDER& d) {
        d = d;
#ifdef WIN32
        ppGStripLast(d.KDAUFTRAGSTAT);
        ppGStripLast(d.KDAUFTRAGART);
        ppGStripLast(d.ZUGRUND);
#endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
#ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNr, (void*)&s, STOCKRESERVATIONORDER_BES, (int)STOCKRESERVATIONORDER_ANZ, error_msg);
#else
        pos = pos;
        rc = DistributorFunSelect(FncNr, (void*)&s, error_msg, &rc);
#endif
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    int CursorServerCall(int FncNr, int FetchRel = 1, int pos = 0) {
        if (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel < 0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKRESERVATIONORDER c;
        if (bOpenCursor && FncNumber != FncNr)
            CloseCursor(pos);
        if (bOpenCursor)
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber = FncNr;
            AnzPos = 0;
            lst.clear();
        }
        if ((CursorPos == AnzPos) && bEndOfSelect) {
            rc = 1;
            return 1;
        }
        else if (CursorPos < AnzPos) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
#ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void*)&s, STOCKRESERVATIONORDER_BES, (int)STOCKRESERVATIONORDER_ANZ, error_msg);
#else
        rc = DistributorFunSelect(FncNumber, (void*)&s, error_msg, &rc);
#endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
            0 :
            CursorPos + FetchRel - 1;
        if (CursorPos >= AnzPos) {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSUPPLINFO : public ppDadeVirtual {
public:
    supplinfoS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<supplinfoS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< supplinfoS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     supplinfoS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< supplinfoS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<supplinfoS>::iterator
                 beginList() { return lst.begin(); }
    vector<supplinfoS>::iterator
                 endList  () { return lst.end  (); }

    long         GetArticleno() const { return s.ARTICLENO; }
    const char*  GetAvailabilityinfo(ppString & t) const { t = s.AVAILABILITYINFO; t.erasespace(ppString::END); return t.c_str(); }
    long         GetProglieferdatum() const { return s.PROGLIEFERDATUM; }
    long         GetLieferdatum() const { return s.LIEFERDATUM; }

    const supplinfoS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetAvailabilityinfo(const ppString & t) { ppGStrCopy(s.AVAILABILITYINFO, t.c_str(), L_SUPPLINFO_AVAILABILITYINFO); }
    void         SetProglieferdatum(long t) { s.PROGLIEFERDATUM = t; }
    void         SetLieferdatum(long t) { s.LIEFERDATUM = t; }

    void         SetStruct(const supplinfoS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelSuppInfo(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1616, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSUPPLINFO() {
        ::buf_default((void *)&s, SUPPLINFO_BES, SUPPLINFO_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSUPPLINFO() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, SUPPLINFO_BES, SUPPLINFO_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, SUPPLINFO_BES, (int)SUPPLINFO_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1616 ) return CursorServerCall(1616, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_SUPPLINFO & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.AVAILABILITYINFO);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, SUPPLINFO_BES, (int)SUPPLINFO_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSUPPLINFO c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, SUPPLINFO_BES, (int)SUPPLINFO_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CDELAYEDART : public ppDadeVirtual {
public:
    delayedartS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<delayedartS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< delayedartS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     delayedartS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< delayedartS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<delayedartS>::iterator
                 beginList() { return lst.begin(); }
    vector<delayedartS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    char         GetNarcotic() const { return s.NARCOTIC[0]; }
    char         GetColdchain() const { return s.COLDCHAIN[0]; }
    char         GetCool08() const { return s.COOL08[0]; }
    char         GetCool20() const { return s.COOL20[0]; }

    const delayedartS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetNarcotic(char t) { s.NARCOTIC[0] = t; s.NARCOTIC[1] = '\0';}
    void         SetColdchain(char t) { s.COLDCHAIN[0] = t; s.COLDCHAIN[1] = '\0';}
    void         SetCool08(char t) { s.COOL08[0] = t; s.COOL08[1] = '\0';}
    void         SetCool20(char t) { s.COOL20[0] = t; s.COOL20[1] = '\0';}

    void         SetStruct(const delayedartS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          Delete(int pos = 0) { return UniqueServerCall(1368, pos); }
    int          Insert(int pos = 0) { int ret = UniqueServerCall(1367, pos); Strip(s); return ret; }
    int          Sel(int pos = 0) { int ret = UniqueServerCall(1366, pos); Strip(s); return ret; }
    int          Update(int pos = 0) { int ret = UniqueServerCall(1369, pos); Strip(s); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          SelList(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CDELAYEDART() {
        ::buf_default((void *)&s, DELAYEDART_BES, DELAYEDART_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CDELAYEDART() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, DELAYEDART_BES, DELAYEDART_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, DELAYEDART_BES, (int)DELAYEDART_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1368 ) return UniqueServerCall(1368, pos);
        if ( fkt_nr == 1367 ) return UniqueServerCall(1367, pos);
        if ( fkt_nr == 1366 ) return UniqueServerCall(1366, pos);
        if ( fkt_nr == 1369 ) return UniqueServerCall(1369, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_DELAYEDART & d) {
        d = d;
    #ifdef WIN32
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, DELAYEDART_BES, (int)DELAYEDART_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CDELAYEDART c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, DELAYEDART_BES, (int)DELAYEDART_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CDISCOUNTANZ : public ppDadeVirtual {
public:
    discountanzS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<discountanzS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< discountanzS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     discountanzS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< discountanzS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<discountanzS>::iterator
                 beginList() { return lst.begin(); }
    vector<discountanzS>::iterator
                 endList  () { return lst.end  (); }

    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetDiscountgrpno() const { return s.DISCOUNTGRPNO; }
    const char*  GetPharmacygroupid(ppString & t) const { t = s.PHARMACYGROUPID; t.erasespace(ppString::END); return t.c_str(); }
    long         GetCustomerno() const { return s.CUSTOMERNO; }
    short        GetGrpdiscounttyp() const { return s.GRPDISCOUNTTYP; }
    long         GetDatefrom() const { return s.DATEFROM; }
    long         GetDateto() const { return s.DATETO; }
    long         GetBaseqty() const { return s.BASEQTY; }
    short        GetDiscountspec() const { return s.DISCOUNTSPEC; }
    short        GetDiscounttype() const { return s.DISCOUNTTYPE; }
    short        GetDiscountqty() const { return s.DISCOUNTQTY; }
    double       GetDiscountvaluepct() const { return s.DISCOUNTVALUEPCT; }
    short        GetPreis_typ() const { return s.PREIS_TYP; }
    double       GetDiscountqtypct() const { return s.DISCOUNTQTYPCT; }
    double       GetSurchargepct() const { return s.SURCHARGEPCT; }
    const char*  GetPharmgrpexcluded(ppString & t) const { t = s.PHARMGRPEXCLUDED; t.erasespace(ppString::END); return t.c_str(); }
    double       GetFixedprice() const { return s.FIXEDPRICE; }
    double       GetRefundpct() const { return s.REFUNDPCT; }
    char         GetInternaldiscount() const { return s.INTERNALDISCOUNT[0]; }
    long         GetDiscountarticle() const { return s.DISCOUNTARTICLE; }
    char         GetUpdatesign() const { return s.UPDATESIGN[0]; }
    double       GetBase_value() const { return s.BASE_VALUE; }
    long         GetBase_mult_std_qty() const { return s.BASE_MULT_STD_QTY; }
    char         GetNo_multiple_qty() const { return s.NO_MULTIPLE_QTY[0]; }
    double       GetFixeddiscountvalue() const { return s.FIXEDDISCOUNTVALUE; }
    long         GetManufacturerno() const { return s.MANUFACTURERNO; }
    long         GetArtcategoryno() const { return s.ARTCATEGORYNO; }
    short        GetPaymenttargetno() const { return s.PAYMENTTARGETNO; }
    double       GetGrossprofitpct() const { return s.GROSSPROFITPCT; }
    char         GetAddondiscountok() const { return s.ADDONDISCOUNTOK[0]; }
    char         GetPaymenttermtype() const { return s.PAYMENTTERMTYPE[0]; }
    long         GetTargetqty() const { return s.TARGETQTY; }
    double       GetExceedancepct() const { return s.EXCEEDANCEPCT; }
    long         GetArticle_no_pack() const { return s.ARTICLE_NO_PACK; }
    double       GetRefundvalue() const { return s.REFUNDVALUE; }
    short        GetPromotion_no() const { return s.PROMOTION_NO; }
    short        GetDiscountapplyto() const { return s.DISCOUNTAPPLYTO; }
    short        GetDiscountcalcfrom() const { return s.DISCOUNTCALCFROM; }

    const discountanzS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetDiscountgrpno(long t) { s.DISCOUNTGRPNO = t; }
    void         SetPharmacygroupid(const ppString & t) { ppGStrCopy(s.PHARMACYGROUPID, t.c_str(), L_DISCOUNTANZ_PHARMACYGROUPID); }
    void         SetCustomerno(long t) { s.CUSTOMERNO = t; }
    void         SetGrpdiscounttyp(short t) { s.GRPDISCOUNTTYP = t; }
    void         SetDatefrom(long t) { s.DATEFROM = t; }
    void         SetDateto(long t) { s.DATETO = t; }
    void         SetBaseqty(long t) { s.BASEQTY = t; }
    void         SetDiscountspec(short t) { s.DISCOUNTSPEC = t; }
    void         SetDiscounttype(short t) { s.DISCOUNTTYPE = t; }
    void         SetDiscountqty(short t) { s.DISCOUNTQTY = t; }
    void         SetDiscountvaluepct(double t) { s.DISCOUNTVALUEPCT = t; }
    void         SetPreis_typ(short t) { s.PREIS_TYP = t; }
    void         SetDiscountqtypct(double t) { s.DISCOUNTQTYPCT = t; }
    void         SetSurchargepct(double t) { s.SURCHARGEPCT = t; }
    void         SetPharmgrpexcluded(const ppString & t) { ppGStrCopy(s.PHARMGRPEXCLUDED, t.c_str(), L_DISCOUNTANZ_PHARMGRPEXCLUDED); }
    void         SetFixedprice(double t) { s.FIXEDPRICE = t; }
    void         SetRefundpct(double t) { s.REFUNDPCT = t; }
    void         SetInternaldiscount(char t) { s.INTERNALDISCOUNT[0] = t; s.INTERNALDISCOUNT[1] = '\0';}
    void         SetDiscountarticle(long t) { s.DISCOUNTARTICLE = t; }
    void         SetUpdatesign(char t) { s.UPDATESIGN[0] = t; s.UPDATESIGN[1] = '\0';}
    void         SetBase_value(double t) { s.BASE_VALUE = t; }
    void         SetBase_mult_std_qty(long t) { s.BASE_MULT_STD_QTY = t; }
    void         SetNo_multiple_qty(char t) { s.NO_MULTIPLE_QTY[0] = t; s.NO_MULTIPLE_QTY[1] = '\0';}
    void         SetFixeddiscountvalue(double t) { s.FIXEDDISCOUNTVALUE = t; }
    void         SetManufacturerno(long t) { s.MANUFACTURERNO = t; }
    void         SetArtcategoryno(long t) { s.ARTCATEGORYNO = t; }
    void         SetPaymenttargetno(short t) { s.PAYMENTTARGETNO = t; }
    void         SetGrossprofitpct(double t) { s.GROSSPROFITPCT = t; }
    void         SetAddondiscountok(char t) { s.ADDONDISCOUNTOK[0] = t; s.ADDONDISCOUNTOK[1] = '\0';}
    void         SetPaymenttermtype(char t) { s.PAYMENTTERMTYPE[0] = t; s.PAYMENTTERMTYPE[1] = '\0';}
    void         SetTargetqty(long t) { s.TARGETQTY = t; }
    void         SetExceedancepct(double t) { s.EXCEEDANCEPCT = t; }
    void         SetArticle_no_pack(long t) { s.ARTICLE_NO_PACK = t; }
    void         SetRefundvalue(double t) { s.REFUNDVALUE = t; }
    void         SetPromotion_no(short t) { s.PROMOTION_NO = t; }
    void         SetDiscountapplyto(short t) { s.DISCOUNTAPPLYTO = t; }
    void         SetDiscountcalcfrom(short t) { s.DISCOUNTCALCFROM = t; }

    void         SetStruct(const discountanzS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1419, FetchRel, pos); return ret; }
    int          SelListCst(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1513, FetchRel, pos); return ret; }
    int          SelListCstEKG(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1514, FetchRel, pos); return ret; }
    int          SelListDG(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1504, FetchRel, pos); return ret; }
    int          SelListGrp(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1420, FetchRel, pos); return ret; }
    int          SelListGrpHerst(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1503, FetchRel, pos); return ret; }
    int          SelListHerst(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1502, FetchRel, pos); return ret; }
    int          SellListGrpDG(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1505, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CDISCOUNTANZ() {
        ::buf_default((void *)&s, DISCOUNTANZ_BES, DISCOUNTANZ_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CDISCOUNTANZ() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, DISCOUNTANZ_BES, DISCOUNTANZ_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, DISCOUNTANZ_BES, (int)DISCOUNTANZ_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1419 ) return CursorServerCall(1419, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1513 ) return CursorServerCall(1513, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1514 ) return CursorServerCall(1514, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1504 ) return CursorServerCall(1504, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1420 ) return CursorServerCall(1420, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1503 ) return CursorServerCall(1503, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1502 ) return CursorServerCall(1502, (int)s.FETCH_REL, pos);
        if ( fkt_nr == 1505 ) return CursorServerCall(1505, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_DISCOUNTANZ & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.PHARMACYGROUPID);
        ppGStripLast(d.PHARMGRPEXCLUDED);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, DISCOUNTANZ_BES, (int)DISCOUNTANZ_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CDISCOUNTANZ c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, DISCOUNTANZ_BES, (int)DISCOUNTANZ_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};

class CSTOCKENTRY : public ppDadeVirtual {
public:
    stockentryS s;
    int  rc;
    char error_msg[81];
private:
    bool bOpenCursor;
    bool bEndOfSelect;
    int  FncNumber;
    int  CursorPos;
    int  AnzPos;
    vector<stockentryS> lst; // class list

public:
    unsigned int GetSize() const { return static_cast<unsigned int>(lst.size()); };
    void         ClearStruct() { s.clear(); }
    bool         SetData(unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     s = lst.at(i);
                     return true;
                 }
    bool         SetList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockentryS >::iterator it = lst.begin() + i;
                     *it = s;
                     return true;
                 }
    bool         InsList() {
                     Strip(s);
                     stockentryS c = s;
                     lst.insert(lst.end(), c);
                     AnzPos++;
                     return true;
                 }
    bool         DelList(const unsigned int i) {
                     if (GetSize() <= i)
                         return false;
                     vector< stockentryS >::iterator it = lst.begin() + i;
                     if (it != lst.end())
                         lst.erase(it);
                     if (--AnzPos < 0)
                         AnzPos = 0;
                     return true;
                 }

    vector<stockentryS>::iterator
                 beginList() { return lst.begin(); }
    vector<stockentryS>::iterator
                 endList  () { return lst.end  (); }

    long         GetDate() const { return s.DATE; }
    short        GetBranchno() const { return s.BRANCHNO; }
    long         GetArticleno() const { return s.ARTICLENO; }
    long         GetBestand() const { return s.BESTAND; }
    const char*  GetEinheit(ppString & t) const { t = s.EINHEIT; t.erasespace(ppString::END); return t.c_str(); }
    const char*  GetArtikel_name(ppString & t) const { t = s.ARTIKEL_NAME; t.erasespace(ppString::END); return t.c_str(); }

    const stockentryS &
                 GetStruct() const { return s; }
    long         GetFetch_rel() const { return s.FETCH_REL; }

    void         SetDate(long t) { s.DATE = t; }
    void         SetBranchno(short t) { s.BRANCHNO = t; }
    void         SetArticleno(long t) { s.ARTICLENO = t; }
    void         SetBestand(long t) { s.BESTAND = t; }
    void         SetEinheit(const ppString & t) { ppGStrCopy(s.EINHEIT, t.c_str(), L_STOCKENTRY_EINHEIT); }
    void         SetArtikel_name(const ppString & t) { ppGStrCopy(s.ARTIKEL_NAME, t.c_str(), L_STOCKENTRY_ARTIKEL_NAME); }

    void         SetStruct(const stockentryS & t) { s = t; }
    void         SetFetch_rel(const long t) { s.FETCH_REL = t; }

    int          SelList(int FetchRel = 1, int pos = 0) { int ret = CursorServerCall(1347, FetchRel, pos); return ret; }

    // virtual functions
public:
    int          Load(int pos = 0) { pos = pos; return 1; }
    int          Save(int pos = 0) { pos = pos; return 1; }
    int          Delete(int pos = 0) { pos = pos; return 1; }
    int          SelListHist(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }
    int          SelListFuture(int FetchRel = 1, int pos = 0) { FetchRel = FetchRel; pos = pos; return 1; }

    // constructor
    CSTOCKENTRY() {
        ::buf_default((void *)&s, STOCKENTRY_BES, STOCKENTRY_ANZ);
        bOpenCursor   = false;
        bEndOfSelect  = false;
        FncNumber     = 0;
        CursorPos     = 0;
        AnzPos        = 0;
        rc            = 0;
        s.clear();
    }

    // destructor
    virtual ~CSTOCKENTRY() {
        CloseCursor();
    }

    // buffer init
    void buf_default() {
        ::buf_default((void *)&s, STOCKENTRY_BES, STOCKENTRY_ANZ);
    }

    // close db cursor
    int CloseCursor(int pos = 0) {
        if ( !bOpenCursor )
            return 0;
        s.FETCH_REL = 0;
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKENTRY_BES, (int)STOCKENTRY_ANZ, error_msg);
    #else
        pos = pos;
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        bOpenCursor  = false;
        bEndOfSelect = false;
        FncNumber    = 0;
        CursorPos    = 0;
        AnzPos       = 0;
        if (rc < 0)
            FehlerBehandlung(rc, error_msg);
        return rc;
    }

    // socket server call
    int Server(int fkt_nr, int pos = 0) {
        if ( fkt_nr == 1347 ) return CursorServerCall(1347, (int)s.FETCH_REL, pos);
        FehlerBehandlung(-1, "False function number!");
        return -1;
     }

private:
    void Strip(N_STOCKENTRY & d) {
        d = d;
    #ifdef WIN32
        ppGStripLast(d.EINHEIT);
        ppGStripLast(d.ARTIKEL_NAME);
    #endif
    }

    int UniqueServerCall(int FncNr, int pos = 0) {
    #ifndef __DADE_LOAD__
       rc = ::ServerNr(pos, FncNr, (void *)&s, STOCKENTRY_BES, (int)STOCKENTRY_ANZ, error_msg);
    #else
       pos = pos;
       rc = DistributorFunSelect(FncNr, (void *)&s, error_msg, &rc);
    #endif
       if (rc < 0)
           FehlerBehandlung( rc, error_msg );
       return rc;
    }

    int CursorServerCall(int FncNr,int FetchRel = 1, int pos = 0) {
        if      (FetchRel == 0) return CloseCursor(pos);
        else if (FetchRel == 1) return GetNext(pos, FncNr);
        else if (FetchRel <  0) return ChangeCursor(FetchRel);
        else {
            FehlerBehandlung(-1, "False cursor position!");
            return -1;
        }
    }

    int GetNext(int pos, int FncNr) {
        CSTOCKENTRY c;
        if ( bOpenCursor && FncNumber != FncNr )
            CloseCursor(pos);
        if( bOpenCursor )
            s.FETCH_REL = 1;
        else {
            s.FETCH_REL = 2;
            bOpenCursor = true;
            FncNumber   = FncNr;
            AnzPos      = 0;
            lst.clear();
        }
        if ( (CursorPos == AnzPos) && bEndOfSelect ) {
            rc = 1;
            return 1;
        }
        else if( CursorPos < AnzPos ) {
            s = lst.at(CursorPos);
            CursorPos++;
            return 0;
        }
    #ifndef __DADE_LOAD__
        rc = ::ServerNr(pos, FncNumber, (void *)&s, STOCKENTRY_BES, (int)STOCKENTRY_ANZ, error_msg);
    #else
        rc = DistributorFunSelect(FncNumber, (void *)&s, error_msg, &rc);
    #endif
        if (rc == 0) {
            Strip(s);
            c.s = s;
            lst.insert(lst.end(), c.s);
            bEndOfSelect = false;
            CursorPos++;
            AnzPos++;
        }
        else if (rc == 1)
            bEndOfSelect = true;
        else if (rc < 0)
            FehlerBehandlung( rc, error_msg );
        return rc;
    }

    // FetchRel is a negative value
    int ChangeCursor(int FetchRel) {
        CursorPos = (CursorPos + FetchRel) < 0 ?
                     0                         :
                     CursorPos + FetchRel - 1;
        if ( CursorPos >= AnzPos ) {
            FehlerBehandlung (-1, "False cursor position!");
            return -1;
        }
        s = lst.at(CursorPos);
        CursorPos++;
        rc = 0;
        return 0;
    }
};
#endif    // TRANSCLASS

#endif   // GUARD
